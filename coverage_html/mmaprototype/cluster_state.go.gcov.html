<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage_mmaprototype.lcov - mmaprototype/cluster_state.go</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../index.html" title="Click to go to top-level">top level</a> - <a href="index.html" title="Click to go to directory mmaprototype">mmaprototype</a> - cluster_state.go</td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage_mmaprototype.lcov</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryMed">78.9&nbsp;%</td>
            <td class="headerCovTableEntry">1272</td>
            <td class="headerCovTableEntry">1003</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2025-11-21 11:59:09</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryHi">-</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
          </tr>
                  <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">            Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>              : // Copyright 2023 The Cockroach Authors.</span>
<span id="L2"><span class="lineNum">       2</span>              : //</span>
<span id="L3"><span class="lineNum">       3</span>              : // Use of this software is governed by the CockroachDB Software License</span>
<span id="L4"><span class="lineNum">       4</span>              : // included in the /LICENSE file.</span>
<span id="L5"><span class="lineNum">       5</span>              : </span>
<span id="L6"><span class="lineNum">       6</span>              : package mmaprototype</span>
<span id="L7"><span class="lineNum">       7</span>              : </span>
<span id="L8"><span class="lineNum">       8</span>              : import (</span>
<span id="L9"><span class="lineNum">       9</span>              :         &quot;cmp&quot;</span>
<span id="L10"><span class="lineNum">      10</span>              :         &quot;context&quot;</span>
<span id="L11"><span class="lineNum">      11</span>              :         &quot;fmt&quot;</span>
<span id="L12"><span class="lineNum">      12</span>              :         &quot;math&quot;</span>
<span id="L13"><span class="lineNum">      13</span>              :         &quot;slices&quot;</span>
<span id="L14"><span class="lineNum">      14</span>              :         &quot;strings&quot;</span>
<span id="L15"><span class="lineNum">      15</span>              :         &quot;time&quot;</span>
<span id="L16"><span class="lineNum">      16</span>              : </span>
<span id="L17"><span class="lineNum">      17</span>              :         &quot;github.com/cockroachdb/cockroach/pkg/roachpb&quot;</span>
<span id="L18"><span class="lineNum">      18</span>              :         &quot;github.com/cockroachdb/cockroach/pkg/util/log&quot;</span>
<span id="L19"><span class="lineNum">      19</span>              :         &quot;github.com/cockroachdb/cockroach/pkg/util/timeutil&quot;</span>
<span id="L20"><span class="lineNum">      20</span>              :         &quot;github.com/cockroachdb/errors&quot;</span>
<span id="L21"><span class="lineNum">      21</span>              :         &quot;github.com/cockroachdb/redact&quot;</span>
<span id="L22"><span class="lineNum">      22</span>              : )</span>
<span id="L23"><span class="lineNum">      23</span>              : </span>
<span id="L24"><span class="lineNum">      24</span>              : // These values can sometimes be used in ReplicaType, ReplicaIDAndType,</span>
<span id="L25"><span class="lineNum">      25</span>              : // ReplicaState, specifically when used in the context of a</span>
<span id="L26"><span class="lineNum">      26</span>              : // pendingReplicaChange.</span>
<span id="L27"><span class="lineNum">      27</span>              : //</span>
<span id="L28"><span class="lineNum">      28</span>              : // NB: In practice, the kvserver code never generates 0 as a valid ReplicaID.</span>
<span id="L29"><span class="lineNum">      29</span>              : // The MMA code does not special case 0 to be an invalid value, because as of</span>
<span id="L30"><span class="lineNum">      30</span>              : // the time of writing this comment, the 0 value being invalid was an</span>
<span id="L31"><span class="lineNum">      31</span>              : // undocumented invariant of the kvserver code. Instead, the code here uses</span>
<span id="L32"><span class="lineNum">      32</span>              : // two negative values to represent special cases.</span>
<span id="L33"><span class="lineNum">      33</span>              : const (</span>
<span id="L34"><span class="lineNum">      34</span>              :         // unknownReplicaID is used with a change that proposes to add a replica</span>
<span id="L35"><span class="lineNum">      35</span>              :         // (since it does not know the future ReplicaID).</span>
<span id="L36"><span class="lineNum">      36</span>              :         unknownReplicaID roachpb.ReplicaID = -1</span>
<span id="L37"><span class="lineNum">      37</span>              :         // noReplicaID is used with a change that is removing a replica.</span>
<span id="L38"><span class="lineNum">      38</span>              :         noReplicaID roachpb.ReplicaID = -2</span>
<span id="L39"><span class="lineNum">      39</span>              : )</span>
<span id="L40"><span class="lineNum">      40</span>              : </span>
<span id="L41"><span class="lineNum">      41</span>              : type ReplicaType struct {</span>
<span id="L42"><span class="lineNum">      42</span>              :         ReplicaType   roachpb.ReplicaType</span>
<span id="L43"><span class="lineNum">      43</span>              :         IsLeaseholder bool</span>
<span id="L44"><span class="lineNum">      44</span>              : }</span>
<span id="L45"><span class="lineNum">      45</span>              : </span>
<span id="L46"><span class="lineNum">      46</span>              : type ReplicaIDAndType struct {</span>
<span id="L47"><span class="lineNum">      47</span>              :         // ReplicaID can be set to unknownReplicaID or noReplicaID.</span>
<span id="L48"><span class="lineNum">      48</span>              :         roachpb.ReplicaID</span>
<span id="L49"><span class="lineNum">      49</span>              :         // In general, all roachpb.ReplicaTypes can be represented here. Some</span>
<span id="L50"><span class="lineNum">      50</span>              :         // contexts that use ReplicaIDAndType may only represent a subset of</span>
<span id="L51"><span class="lineNum">      51</span>              :         // roachpb.ReplicaTypes -- the commentary in those contexts will specify if</span>
<span id="L52"><span class="lineNum">      52</span>              :         // that is the case.</span>
<span id="L53"><span class="lineNum">      53</span>              :         ReplicaType</span>
<span id="L54"><span class="lineNum">      54</span>              : }</span>
<span id="L55"><span class="lineNum">      55</span>              : </span>
<span id="L56"><span class="lineNum">      56</span>              : // SafeFormat implements the redact.SafeFormatter interface.</span>
<span id="L57"><span class="lineNum">      57</span> <span class="tlaGNC">         176 : func (rit ReplicaIDAndType) SafeFormat(w redact.SafePrinter, _ rune) {</span></span>
<span id="L58"><span class="lineNum">      58</span> <span class="tlaGNC">         176 :         w.Print(&quot;replica-id=&quot;)</span></span>
<span id="L59"><span class="lineNum">      59</span> <span class="tlaGNC">         176 :         switch rit.ReplicaID {</span></span>
<span id="L60"><span class="lineNum">      60</span> <span class="tlaGNC">          33 :         case unknownReplicaID:</span></span>
<span id="L61"><span class="lineNum">      61</span> <span class="tlaGNC">          33 :                 w.Print(&quot;unknown&quot;)</span></span>
<span id="L62"><span class="lineNum">      62</span> <span class="tlaGNC">          65 :         case noReplicaID:</span></span>
<span id="L63"><span class="lineNum">      63</span> <span class="tlaGNC">          65 :                 w.Print(&quot;none&quot;)</span></span>
<span id="L64"><span class="lineNum">      64</span> <span class="tlaGNC">          78 :         default:</span></span>
<span id="L65"><span class="lineNum">      65</span> <span class="tlaGNC">          78 :                 w.Print(rit.ReplicaID)</span></span>
<span id="L66"><span class="lineNum">      66</span>              :         }</span>
<span id="L67"><span class="lineNum">      67</span> <span class="tlaGNC">         176 :         w.Printf(&quot; type=%v&quot;, rit.ReplicaType.ReplicaType)</span></span>
<span id="L68"><span class="lineNum">      68</span> <span class="tlaGNC">         176 :         if rit.IsLeaseholder {</span></span>
<span id="L69"><span class="lineNum">      69</span> <span class="tlaGNC">          77 :                 w.Print(&quot; leaseholder=true&quot;)</span></span>
<span id="L70"><span class="lineNum">      70</span> <span class="tlaGNC">          77 :         }</span></span>
<span id="L71"><span class="lineNum">      71</span>              : }</span>
<span id="L72"><span class="lineNum">      72</span>              : </span>
<span id="L73"><span class="lineNum">      73</span> <span class="tlaGNC">         136 : func (rit ReplicaIDAndType) String() string {</span></span>
<span id="L74"><span class="lineNum">      74</span> <span class="tlaGNC">         136 :         return redact.StringWithoutMarkers(rit)</span></span>
<span id="L75"><span class="lineNum">      75</span> <span class="tlaGNC">         136 : }</span></span>
<span id="L76"><span class="lineNum">      76</span>              : </span>
<span id="L77"><span class="lineNum">      77</span>              : // subsumesChange returns true if rit subsumes next, where next is the state</span>
<span id="L78"><span class="lineNum">      78</span>              : // after the proposed change, and rit is the current observed state.</span>
<span id="L79"><span class="lineNum">      79</span>              : //</span>
<span id="L80"><span class="lineNum">      80</span>              : // NB: this method uses a value receiver since it mutates the value as part of</span>
<span id="L81"><span class="lineNum">      81</span>              : // its computation.</span>
<span id="L82"><span class="lineNum">      82</span> <span class="tlaGNC">          14 : func (rit ReplicaIDAndType) subsumesChange(next ReplicaIDAndType) bool {</span></span>
<span id="L83"><span class="lineNum">      83</span> <span class="tlaGNC">          14 :         if rit.ReplicaID == noReplicaID &amp;&amp; next.ReplicaID == noReplicaID {</span></span>
<span id="L84"><span class="lineNum">      84</span> <span class="tlaGNC">           2 :                 // Removal has happened.</span></span>
<span id="L85"><span class="lineNum">      85</span> <span class="tlaGNC">           2 :                 return true</span></span>
<span id="L86"><span class="lineNum">      86</span> <span class="tlaGNC">           2 :         }</span></span>
<span id="L87"><span class="lineNum">      87</span> <span class="tlaGNC">          12 :         notSubsumed := (rit.ReplicaID == noReplicaID &amp;&amp; next.ReplicaID != noReplicaID) ||</span></span>
<span id="L88"><span class="lineNum">      88</span> <span class="tlaGNC">          12 :                 (rit.ReplicaID != noReplicaID &amp;&amp; next.ReplicaID == noReplicaID)</span></span>
<span id="L89"><span class="lineNum">      89</span> <span class="tlaGNC">          12 :         if notSubsumed {</span></span>
<span id="L90"><span class="lineNum">      90</span> <span class="tlaGNC">           7 :                 return false</span></span>
<span id="L91"><span class="lineNum">      91</span> <span class="tlaGNC">           7 :         }</span></span>
<span id="L92"><span class="lineNum">      92</span>              :         // Both rit and next have replicaIDs != noReplicaID. We don't actually care</span>
<span id="L93"><span class="lineNum">      93</span>              :         // about the replicaID's since we don't control them. If the replicaTypes</span>
<span id="L94"><span class="lineNum">      94</span>              :         // are as expected, and if we were either not trying to change the</span>
<span id="L95"><span class="lineNum">      95</span>              :         // leaseholder, or that leaseholder change has happened, then the change has</span>
<span id="L96"><span class="lineNum">      96</span>              :         // been subsumed.</span>
<span id="L97"><span class="lineNum">      97</span> <span class="tlaGNC">           5 :         switch rit.ReplicaType.ReplicaType {</span></span>
<span id="L98"><span class="lineNum">      98</span> <span class="tlaUNC">           0 :         case roachpb.VOTER_INCOMING:</span></span>
<span id="L99"><span class="lineNum">      99</span> <span class="tlaUNC">           0 :                 // Already a voter, so consider the change done.</span></span>
<span id="L100"><span class="lineNum">     100</span> <span class="tlaUNC">           0 :                 rit.ReplicaType.ReplicaType = roachpb.VOTER_FULL</span></span>
<span id="L101"><span class="lineNum">     101</span>              :         }</span>
<span id="L102"><span class="lineNum">     102</span>              :         // NB: rit.replicaType.ReplicaType equal to LEARNER, VOTER_DEMOTING* are</span>
<span id="L103"><span class="lineNum">     103</span>              :         // left as-is. If next is trying to remove a replica, this change has not</span>
<span id="L104"><span class="lineNum">     104</span>              :         // finished yet, and the store is still seeing the load corresponding to the</span>
<span id="L105"><span class="lineNum">     105</span>              :         // state it is exiting. If next is trying to demote to a NON_VOTER, but</span>
<span id="L106"><span class="lineNum">     106</span>              :         // rit.ReplicaType.ReplicaType is equal to VOTER_DEMOTING_NON_VOTER, then it</span>
<span id="L107"><span class="lineNum">     107</span>              :         // is still a voter, so the change is not yet done.</span>
<span id="L108"><span class="lineNum">     108</span>              : </span>
<span id="L109"><span class="lineNum">     109</span> <span class="tlaGNC">           5 :         if rit.ReplicaType.ReplicaType == next.ReplicaType.ReplicaType &amp;&amp;</span></span>
<span id="L110"><span class="lineNum">     110</span> <span class="tlaGNC">           5 :                 rit.IsLeaseholder == next.IsLeaseholder {</span></span>
<span id="L111"><span class="lineNum">     111</span> <span class="tlaGNC">           3 :                 return true</span></span>
<span id="L112"><span class="lineNum">     112</span> <span class="tlaGNC">           3 :         }</span></span>
<span id="L113"><span class="lineNum">     113</span> <span class="tlaGNC">           2 :         return false</span></span>
<span id="L114"><span class="lineNum">     114</span>              : }</span>
<span id="L115"><span class="lineNum">     115</span>              : </span>
<span id="L116"><span class="lineNum">     116</span>              : type ReplicaState struct {</span>
<span id="L117"><span class="lineNum">     117</span>              :         ReplicaIDAndType</span>
<span id="L118"><span class="lineNum">     118</span>              :         // LeaseDisposition can be set for a VOTER_FULL replica and communicates the</span>
<span id="L119"><span class="lineNum">     119</span>              :         // availability of this replica for lease transfers.</span>
<span id="L120"><span class="lineNum">     120</span>              :         LeaseDisposition LeaseDisposition</span>
<span id="L121"><span class="lineNum">     121</span>              : }</span>
<span id="L122"><span class="lineNum">     122</span>              : </span>
<span id="L123"><span class="lineNum">     123</span>              : // changeID is a unique ID, in the context of this data-structure and when</span>
<span id="L124"><span class="lineNum">     124</span>              : // receiving updates about enactment having happened or having been rejected</span>
<span id="L125"><span class="lineNum">     125</span>              : // (by the component responsible for change enactment).</span>
<span id="L126"><span class="lineNum">     126</span>              : type changeID uint64</span>
<span id="L127"><span class="lineNum">     127</span>              : </span>
<span id="L128"><span class="lineNum">     128</span>              : type ReplicaChangeType int</span>
<span id="L129"><span class="lineNum">     129</span>              : </span>
<span id="L130"><span class="lineNum">     130</span>              : const (</span>
<span id="L131"><span class="lineNum">     131</span>              :         Unknown ReplicaChangeType = iota</span>
<span id="L132"><span class="lineNum">     132</span>              :         AddLease</span>
<span id="L133"><span class="lineNum">     133</span>              :         RemoveLease</span>
<span id="L134"><span class="lineNum">     134</span>              :         // AddReplica represents a single replica being added.</span>
<span id="L135"><span class="lineNum">     135</span>              :         AddReplica</span>
<span id="L136"><span class="lineNum">     136</span>              :         // RemoveReplica represents a single replica being removed.</span>
<span id="L137"><span class="lineNum">     137</span>              :         RemoveReplica</span>
<span id="L138"><span class="lineNum">     138</span>              :         // ChangeReplica represents a promotion to VOTER or demotion to NON_VOTER.</span>
<span id="L139"><span class="lineNum">     139</span>              :         // It can also be shedding or acquiring the lease.</span>
<span id="L140"><span class="lineNum">     140</span>              :         ChangeReplica</span>
<span id="L141"><span class="lineNum">     141</span>              : )</span>
<span id="L142"><span class="lineNum">     142</span>              : </span>
<span id="L143"><span class="lineNum">     143</span> <span class="tlaGNC">          20 : func (s ReplicaChangeType) String() string {</span></span>
<span id="L144"><span class="lineNum">     144</span> <span class="tlaGNC">          20 :         switch s {</span></span>
<span id="L145"><span class="lineNum">     145</span> <span class="tlaUNC">           0 :         case Unknown:</span></span>
<span id="L146"><span class="lineNum">     146</span> <span class="tlaUNC">           0 :                 return &quot;Unknown&quot;</span></span>
<span id="L147"><span class="lineNum">     147</span> <span class="tlaGNC">           1 :         case AddLease:</span></span>
<span id="L148"><span class="lineNum">     148</span> <span class="tlaGNC">           1 :                 return &quot;AddLease&quot;</span></span>
<span id="L149"><span class="lineNum">     149</span> <span class="tlaGNC">           1 :         case RemoveLease:</span></span>
<span id="L150"><span class="lineNum">     150</span> <span class="tlaGNC">           1 :                 return &quot;RemoveLease&quot;</span></span>
<span id="L151"><span class="lineNum">     151</span> <span class="tlaGNC">           6 :         case AddReplica:</span></span>
<span id="L152"><span class="lineNum">     152</span> <span class="tlaGNC">           6 :                 return &quot;AddReplica&quot;</span></span>
<span id="L153"><span class="lineNum">     153</span> <span class="tlaGNC">          12 :         case RemoveReplica:</span></span>
<span id="L154"><span class="lineNum">     154</span> <span class="tlaGNC">          12 :                 return &quot;RemoveReplica&quot;</span></span>
<span id="L155"><span class="lineNum">     155</span> <span class="tlaUNC">           0 :         case ChangeReplica:</span></span>
<span id="L156"><span class="lineNum">     156</span> <span class="tlaUNC">           0 :                 return &quot;ChangeReplica&quot;</span></span>
<span id="L157"><span class="lineNum">     157</span> <span class="tlaUNC">           0 :         default:</span></span>
<span id="L158"><span class="lineNum">     158</span> <span class="tlaUNC">           0 :                 panic(&quot;unknown ReplicaChangeType&quot;)</span></span>
<span id="L159"><span class="lineNum">     159</span>              :         }</span>
<span id="L160"><span class="lineNum">     160</span>              : }</span>
<span id="L161"><span class="lineNum">     161</span>              : </span>
<span id="L162"><span class="lineNum">     162</span> <span class="tlaGNC">         198 : func replicaExists(replicaID roachpb.ReplicaID) bool {</span></span>
<span id="L163"><span class="lineNum">     163</span> <span class="tlaGNC">         198 :         return replicaID &gt;= 0 || replicaID == unknownReplicaID</span></span>
<span id="L164"><span class="lineNum">     164</span> <span class="tlaGNC">         198 : }</span></span>
<span id="L165"><span class="lineNum">     165</span>              : </span>
<span id="L166"><span class="lineNum">     166</span>              : // ReplicaChange describes a change to a replica.</span>
<span id="L167"><span class="lineNum">     167</span>              : type ReplicaChange struct {</span>
<span id="L168"><span class="lineNum">     168</span>              :         // The load this change adds to a store. The values will be negative if the</span>
<span id="L169"><span class="lineNum">     169</span>              :         // load is being removed.</span>
<span id="L170"><span class="lineNum">     170</span>              :         loadDelta          LoadVector</span>
<span id="L171"><span class="lineNum">     171</span>              :         secondaryLoadDelta SecondaryLoadVector</span>
<span id="L172"><span class="lineNum">     172</span>              : </span>
<span id="L173"><span class="lineNum">     173</span>              :         // target is the target {store,node} for the change.</span>
<span id="L174"><span class="lineNum">     174</span>              :         target roachpb.ReplicationTarget</span>
<span id="L175"><span class="lineNum">     175</span>              :         // rangeID is the same as that in the PendingRangeChange.RangeID this change</span>
<span id="L176"><span class="lineNum">     176</span>              :         // is part of. It is duplicated here since the individual</span>
<span id="L177"><span class="lineNum">     177</span>              :         // pendingReplicaChanges are kept in various maps keyed by the changeID, and</span>
<span id="L178"><span class="lineNum">     178</span>              :         // having the RangeID field on each change is convenient.</span>
<span id="L179"><span class="lineNum">     179</span>              :         rangeID roachpb.RangeID</span>
<span id="L180"><span class="lineNum">     180</span>              : </span>
<span id="L181"><span class="lineNum">     181</span>              :         // NB: 0 is not a valid ReplicaID, but this component does not care about</span>
<span id="L182"><span class="lineNum">     182</span>              :         // this level of detail (the special constants defined above use negative</span>
<span id="L183"><span class="lineNum">     183</span>              :         // ReplicaID values as markers).</span>
<span id="L184"><span class="lineNum">     184</span>              :         //</span>
<span id="L185"><span class="lineNum">     185</span>              :         // We define exists(replicaID) =</span>
<span id="L186"><span class="lineNum">     186</span>              :         //  replicaID &gt;= 0 || replicaID == unknownReplicaID.</span>
<span id="L187"><span class="lineNum">     187</span>              :         //</span>
<span id="L188"><span class="lineNum">     188</span>              :         // Only following cases can happen:</span>
<span id="L189"><span class="lineNum">     189</span>              :         //</span>
<span id="L190"><span class="lineNum">     190</span>              :         // - exists(prev.replicaID) &amp;&amp; next.replicaID == noReplicaID: outgoing</span>
<span id="L191"><span class="lineNum">     191</span>              :         //   replica. prev.IsLeaseholder can be true or false, since we can transfer</span>
<span id="L192"><span class="lineNum">     192</span>              :         //   the lease as part of moving the replica. ReplicaChangeType is</span>
<span id="L193"><span class="lineNum">     193</span>              :         //   RemoveReplica.</span>
<span id="L194"><span class="lineNum">     194</span>              :         //</span>
<span id="L195"><span class="lineNum">     195</span>              :         // - prev.replicaID == noReplicaID &amp;&amp; next.replicaID == unknownReplicaID:</span>
<span id="L196"><span class="lineNum">     196</span>              :         //   incoming replica, next.ReplicaType must be VOTER_FULL or NON_VOTER.</span>
<span id="L197"><span class="lineNum">     197</span>              :         //   next.IsLeaseholder can be true or false. ReplicaChangeType is</span>
<span id="L198"><span class="lineNum">     198</span>              :         //   AddReplica.</span>
<span id="L199"><span class="lineNum">     199</span>              :         //</span>
<span id="L200"><span class="lineNum">     200</span>              :         // - exists(prev.replicaID) &amp;&amp; exists(next.replicaID):</span>
<span id="L201"><span class="lineNum">     201</span>              :         //   - If prev.ReplicaType == next.ReplicaType, ReplicaChangeType must be</span>
<span id="L202"><span class="lineNum">     202</span>              :         //     AddLease or RemoveLease, with a change in the IsLeaseholder bit.</span>
<span id="L203"><span class="lineNum">     203</span>              :         //   - If prev.ReplicaType != next.ReplicaType, ReplicaChangeType is</span>
<span id="L204"><span class="lineNum">     204</span>              :         //     ChangeReplica, and this is a promotion/demotion. The IsLeaseholder</span>
<span id="L205"><span class="lineNum">     205</span>              :         //     bit can change or be false in both prev and next (it can't be true in</span>
<span id="L206"><span class="lineNum">     206</span>              :         //     both since a promoted replica can't have been the leaseholder and a</span>
<span id="L207"><span class="lineNum">     207</span>              :         //     replica being demoted cannot retain the lease).</span>
<span id="L208"><span class="lineNum">     208</span>              :         //</span>
<span id="L209"><span class="lineNum">     209</span>              :         // NB: The prev value is always the state before the change. This is the</span>
<span id="L210"><span class="lineNum">     210</span>              :         // source of truth provided by the leaseholder in the RangeMsg, so will</span>
<span id="L211"><span class="lineNum">     211</span>              :         // have real ReplicaIDs (if already a replica) and real ReplicaTypes</span>
<span id="L212"><span class="lineNum">     212</span>              :         // (including types beyond VOTER_FULL and NON_VOTER). This source-of-truth</span>
<span id="L213"><span class="lineNum">     213</span>              :         // claim is guaranteed by REQUIREMENT(change-computation) documented</span>
<span id="L214"><span class="lineNum">     214</span>              :         // elsewhere, and the fact that new changes are computed only when there</span>
<span id="L215"><span class="lineNum">     215</span>              :         // are no pending changes for a range.</span>
<span id="L216"><span class="lineNum">     216</span>              :         //</span>
<span id="L217"><span class="lineNum">     217</span>              :         // The ReplicaType in next is either the zero value (for removals), or</span>
<span id="L218"><span class="lineNum">     218</span>              :         // {VOTER_FULL, NON_VOTER} for additions/change, i.e., it represents the</span>
<span id="L219"><span class="lineNum">     219</span>              :         // final goal state.</span>
<span id="L220"><span class="lineNum">     220</span>              :         //</span>
<span id="L221"><span class="lineNum">     221</span>              :         // TODO(tbg): in MakeLeaseTransferChanges, next.ReplicaType.ReplicaType is</span>
<span id="L222"><span class="lineNum">     222</span>              :         // simply the current value, and not necessarily {VOTER_FULL, NON_VOTER}.</span>
<span id="L223"><span class="lineNum">     223</span>              :         // So the above comment is incorrect. We should clean this up.</span>
<span id="L224"><span class="lineNum">     224</span>              :         prev ReplicaState</span>
<span id="L225"><span class="lineNum">     225</span>              :         next ReplicaIDAndType</span>
<span id="L226"><span class="lineNum">     226</span>              : }</span>
<span id="L227"><span class="lineNum">     227</span>              : </span>
<span id="L228"><span class="lineNum">     228</span> <span class="tlaUNC">           0 : func (rc ReplicaChange) String() string {</span></span>
<span id="L229"><span class="lineNum">     229</span> <span class="tlaUNC">           0 :         return redact.StringWithoutMarkers(rc)</span></span>
<span id="L230"><span class="lineNum">     230</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L231"><span class="lineNum">     231</span>              : </span>
<span id="L232"><span class="lineNum">     232</span>              : // SafeFormat implements the redact.SafeFormatter interface.</span>
<span id="L233"><span class="lineNum">     233</span> <span class="tlaGNC">          20 : func (rc ReplicaChange) SafeFormat(w redact.SafePrinter, _ rune) {</span></span>
<span id="L234"><span class="lineNum">     234</span> <span class="tlaGNC">          20 :         w.Printf(&quot;r%v type: %v target store %v (%v)-&gt;(%v)&quot;, rc.rangeID, rc.replicaChangeType(), rc.target, rc.prev, rc.next)</span></span>
<span id="L235"><span class="lineNum">     235</span> <span class="tlaGNC">          20 : }</span></span>
<span id="L236"><span class="lineNum">     236</span>              : </span>
<span id="L237"><span class="lineNum">     237</span>              : // isRemoval returns true if the change is a removal of a replica.</span>
<span id="L238"><span class="lineNum">     238</span> <span class="tlaGNC">          39 : func (rc ReplicaChange) isRemoval() bool {</span></span>
<span id="L239"><span class="lineNum">     239</span> <span class="tlaGNC">          39 :         return rc.replicaChangeType() == RemoveReplica</span></span>
<span id="L240"><span class="lineNum">     240</span> <span class="tlaGNC">          39 : }</span></span>
<span id="L241"><span class="lineNum">     241</span>              : </span>
<span id="L242"><span class="lineNum">     242</span>              : // isAddition returns true if the change is an addition of a replica.</span>
<span id="L243"><span class="lineNum">     243</span> <span class="tlaGNC">          18 : func (rc ReplicaChange) isAddition() bool {</span></span>
<span id="L244"><span class="lineNum">     244</span> <span class="tlaGNC">          18 :         return rc.replicaChangeType() == AddReplica</span></span>
<span id="L245"><span class="lineNum">     245</span> <span class="tlaGNC">          18 : }</span></span>
<span id="L246"><span class="lineNum">     246</span>              : </span>
<span id="L247"><span class="lineNum">     247</span>              : // isUpdate returns true if the change is an update to the replica type or</span>
<span id="L248"><span class="lineNum">     248</span>              : // leaseholder status. This includes promotion/demotion changes.</span>
<span id="L249"><span class="lineNum">     249</span> <span class="tlaGNC">          10 : func (rc ReplicaChange) isUpdate() bool {</span></span>
<span id="L250"><span class="lineNum">     250</span> <span class="tlaGNC">          10 :         changeType := rc.replicaChangeType()</span></span>
<span id="L251"><span class="lineNum">     251</span> <span class="tlaGNC">          10 :         return changeType == AddLease || changeType == RemoveLease || changeType == ChangeReplica</span></span>
<span id="L252"><span class="lineNum">     252</span> <span class="tlaGNC">          10 : }</span></span>
<span id="L253"><span class="lineNum">     253</span>              : </span>
<span id="L254"><span class="lineNum">     254</span> <span class="tlaGNC">          99 : func (rc ReplicaChange) replicaChangeType() ReplicaChangeType {</span></span>
<span id="L255"><span class="lineNum">     255</span> <span class="tlaGNC">          99 :         prevExists := replicaExists(rc.prev.ReplicaID)</span></span>
<span id="L256"><span class="lineNum">     256</span> <span class="tlaGNC">          99 :         nextExists := replicaExists(rc.next.ReplicaID)</span></span>
<span id="L257"><span class="lineNum">     257</span> <span class="tlaGNC">          99 :         if !prevExists &amp;&amp; !nextExists {</span></span>
<span id="L258"><span class="lineNum">     258</span> <span class="tlaUNC">           0 :                 return Unknown</span></span>
<span id="L259"><span class="lineNum">     259</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L260"><span class="lineNum">     260</span> <span class="tlaGNC">          99 :         if prevExists &amp;&amp; !nextExists {</span></span>
<span id="L261"><span class="lineNum">     261</span> <span class="tlaGNC">          31 :                 return RemoveReplica</span></span>
<span id="L262"><span class="lineNum">     262</span> <span class="tlaGNC">          31 :         }</span></span>
<span id="L263"><span class="lineNum">     263</span>              :         // INVARIANT: nextExists.</span>
<span id="L264"><span class="lineNum">     264</span>              : </span>
<span id="L265"><span class="lineNum">     265</span> <span class="tlaGNC">          68 :         if !prevExists {</span></span>
<span id="L266"><span class="lineNum">     266</span> <span class="tlaGNC">          38 :                 return AddReplica</span></span>
<span id="L267"><span class="lineNum">     267</span> <span class="tlaGNC">          38 :         }</span></span>
<span id="L268"><span class="lineNum">     268</span> <span class="tlaGNC">          30 :         if rc.prev.ReplicaType.ReplicaType == rc.next.ReplicaType.ReplicaType {</span></span>
<span id="L269"><span class="lineNum">     269</span> <span class="tlaGNC">          30 :                 if rc.prev.ReplicaType.IsLeaseholder == rc.next.ReplicaType.IsLeaseholder {</span></span>
<span id="L270"><span class="lineNum">     270</span> <span class="tlaUNC">           0 :                         return Unknown</span></span>
<span id="L271"><span class="lineNum">     271</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L272"><span class="lineNum">     272</span> <span class="tlaGNC">          30 :                 if rc.next.IsLeaseholder {</span></span>
<span id="L273"><span class="lineNum">     273</span> <span class="tlaGNC">          15 :                         return AddLease</span></span>
<span id="L274"><span class="lineNum">     274</span> <span class="tlaGNC">          15 :                 }</span></span>
<span id="L275"><span class="lineNum">     275</span> <span class="tlaGNC">          15 :                 return RemoveLease</span></span>
<span id="L276"><span class="lineNum">     276</span>              :         }</span>
<span id="L277"><span class="lineNum">     277</span> <span class="tlaUNC">           0 :         return ChangeReplica</span></span>
<span id="L278"><span class="lineNum">     278</span>              : }</span>
<span id="L279"><span class="lineNum">     279</span>              : </span>
<span id="L280"><span class="lineNum">     280</span>              : func MakeLeaseTransferChanges(</span>
<span id="L281"><span class="lineNum">     281</span>              :         rangeID roachpb.RangeID,</span>
<span id="L282"><span class="lineNum">     282</span>              :         existingReplicas []StoreIDAndReplicaState,</span>
<span id="L283"><span class="lineNum">     283</span>              :         rLoad RangeLoad,</span>
<span id="L284"><span class="lineNum">     284</span>              :         addTarget, removeTarget roachpb.ReplicationTarget,</span>
<span id="L285"><span class="lineNum">     285</span> <span class="tlaGNC">           2 : ) [2]ReplicaChange {</span></span>
<span id="L286"><span class="lineNum">     286</span> <span class="tlaGNC">           2 :         addIdx, removeIdx := -1, -1</span></span>
<span id="L287"><span class="lineNum">     287</span> <span class="tlaGNC">           5 :         for i, replica := range existingReplicas {</span></span>
<span id="L288"><span class="lineNum">     288</span> <span class="tlaGNC">           5 :                 if replica.StoreID == addTarget.StoreID {</span></span>
<span id="L289"><span class="lineNum">     289</span> <span class="tlaGNC">           2 :                         addIdx = i</span></span>
<span id="L290"><span class="lineNum">     290</span> <span class="tlaGNC">           2 :                 }</span></span>
<span id="L291"><span class="lineNum">     291</span> <span class="tlaGNC">           5 :                 if replica.StoreID == removeTarget.StoreID {</span></span>
<span id="L292"><span class="lineNum">     292</span> <span class="tlaGNC">           2 :                         removeIdx = i</span></span>
<span id="L293"><span class="lineNum">     293</span> <span class="tlaGNC">           2 :                 }</span></span>
<span id="L294"><span class="lineNum">     294</span>              :         }</span>
<span id="L295"><span class="lineNum">     295</span> <span class="tlaGNC">           2 :         if removeIdx == -1 {</span></span>
<span id="L296"><span class="lineNum">     296</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(</span></span>
<span id="L297"><span class="lineNum">     297</span> <span class="tlaUNC">           0 :                         &quot;existing leaseholder replica doesn't exist on store %v&quot;, removeIdx))</span></span>
<span id="L298"><span class="lineNum">     298</span>              :         }</span>
<span id="L299"><span class="lineNum">     299</span> <span class="tlaGNC">           2 :         if addIdx == -1 {</span></span>
<span id="L300"><span class="lineNum">     300</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(</span></span>
<span id="L301"><span class="lineNum">     301</span> <span class="tlaUNC">           0 :                         &quot;new leaseholder replica doesn't exist on store %v&quot;, addTarget))</span></span>
<span id="L302"><span class="lineNum">     302</span>              :         }</span>
<span id="L303"><span class="lineNum">     303</span>              : </span>
<span id="L304"><span class="lineNum">     304</span> <span class="tlaGNC">           2 :         remove := existingReplicas[removeIdx]</span></span>
<span id="L305"><span class="lineNum">     305</span> <span class="tlaGNC">           2 :         add := existingReplicas[addIdx]</span></span>
<span id="L306"><span class="lineNum">     306</span> <span class="tlaGNC">           2 :         // Sanity check the lease transfer, we cannot transfer a lease to a replica</span></span>
<span id="L307"><span class="lineNum">     307</span> <span class="tlaGNC">           2 :         // that is already a leaseholder, nor can we transfer a lease from a replica</span></span>
<span id="L308"><span class="lineNum">     308</span> <span class="tlaGNC">           2 :         // that is not the leaseholder.</span></span>
<span id="L309"><span class="lineNum">     309</span> <span class="tlaGNC">           2 :         if !remove.IsLeaseholder {</span></span>
<span id="L310"><span class="lineNum">     310</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(</span></span>
<span id="L311"><span class="lineNum">     311</span> <span class="tlaUNC">           0 :                         &quot;r%v lease transfer-from target %v isn't the leaseholder %v replicas=%v&quot;,</span></span>
<span id="L312"><span class="lineNum">     312</span> <span class="tlaUNC">           0 :                         rangeID, removeTarget, remove.ReplicaState, existingReplicas))</span></span>
<span id="L313"><span class="lineNum">     313</span>              :         }</span>
<span id="L314"><span class="lineNum">     314</span> <span class="tlaGNC">           2 :         if add.IsLeaseholder {</span></span>
<span id="L315"><span class="lineNum">     315</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(</span></span>
<span id="L316"><span class="lineNum">     316</span> <span class="tlaUNC">           0 :                         &quot;r%v lease transfer-to target %v is already the leaseholder %v replicas=%v&quot;,</span></span>
<span id="L317"><span class="lineNum">     317</span> <span class="tlaUNC">           0 :                         rangeID, addTarget, add.ReplicaState, existingReplicas))</span></span>
<span id="L318"><span class="lineNum">     318</span>              :         }</span>
<span id="L319"><span class="lineNum">     319</span>              : </span>
<span id="L320"><span class="lineNum">     320</span> <span class="tlaGNC">           2 :         removeLease := ReplicaChange{</span></span>
<span id="L321"><span class="lineNum">     321</span> <span class="tlaGNC">           2 :                 target:  removeTarget,</span></span>
<span id="L322"><span class="lineNum">     322</span> <span class="tlaGNC">           2 :                 rangeID: rangeID,</span></span>
<span id="L323"><span class="lineNum">     323</span> <span class="tlaGNC">           2 :                 prev:    remove.ReplicaState,</span></span>
<span id="L324"><span class="lineNum">     324</span> <span class="tlaGNC">           2 :                 next:    remove.ReplicaIDAndType,</span></span>
<span id="L325"><span class="lineNum">     325</span> <span class="tlaGNC">           2 :         }</span></span>
<span id="L326"><span class="lineNum">     326</span> <span class="tlaGNC">           2 :         addLease := ReplicaChange{</span></span>
<span id="L327"><span class="lineNum">     327</span> <span class="tlaGNC">           2 :                 target:  addTarget,</span></span>
<span id="L328"><span class="lineNum">     328</span> <span class="tlaGNC">           2 :                 rangeID: rangeID,</span></span>
<span id="L329"><span class="lineNum">     329</span> <span class="tlaGNC">           2 :                 prev:    add.ReplicaState,</span></span>
<span id="L330"><span class="lineNum">     330</span> <span class="tlaGNC">           2 :                 next:    add.ReplicaIDAndType,</span></span>
<span id="L331"><span class="lineNum">     331</span> <span class="tlaGNC">           2 :         }</span></span>
<span id="L332"><span class="lineNum">     332</span> <span class="tlaGNC">           2 :         removeLease.next.IsLeaseholder = false</span></span>
<span id="L333"><span class="lineNum">     333</span> <span class="tlaGNC">           2 :         addLease.next.IsLeaseholder = true</span></span>
<span id="L334"><span class="lineNum">     334</span> <span class="tlaGNC">           2 :         removeLease.secondaryLoadDelta[LeaseCount] = -1</span></span>
<span id="L335"><span class="lineNum">     335</span> <span class="tlaGNC">           2 :         addLease.secondaryLoadDelta[LeaseCount] = 1</span></span>
<span id="L336"><span class="lineNum">     336</span> <span class="tlaGNC">           2 : </span></span>
<span id="L337"><span class="lineNum">     337</span> <span class="tlaGNC">           2 :         // Only account for the leaseholder CPU, all other primary load dimensions</span></span>
<span id="L338"><span class="lineNum">     338</span> <span class="tlaGNC">           2 :         // are ignored. Byte size and write bytes are not impacted by having a range</span></span>
<span id="L339"><span class="lineNum">     339</span> <span class="tlaGNC">           2 :         // lease.</span></span>
<span id="L340"><span class="lineNum">     340</span> <span class="tlaGNC">           2 :         nonRaftCPU := rLoad.Load[CPURate] - rLoad.RaftCPU</span></span>
<span id="L341"><span class="lineNum">     341</span> <span class="tlaGNC">           2 :         removeLease.loadDelta[CPURate] = -nonRaftCPU</span></span>
<span id="L342"><span class="lineNum">     342</span> <span class="tlaGNC">           2 :         addLease.loadDelta[CPURate] = loadToAdd(nonRaftCPU)</span></span>
<span id="L343"><span class="lineNum">     343</span> <span class="tlaGNC">           2 :         return [2]ReplicaChange{removeLease, addLease}</span></span>
<span id="L344"><span class="lineNum">     344</span>              : }</span>
<span id="L345"><span class="lineNum">     345</span>              : </span>
<span id="L346"><span class="lineNum">     346</span>              : // MakeAddReplicaChange creates a replica change which adds the replica type</span>
<span id="L347"><span class="lineNum">     347</span>              : // to the store addStoreID.</span>
<span id="L348"><span class="lineNum">     348</span>              : func MakeAddReplicaChange(</span>
<span id="L349"><span class="lineNum">     349</span>              :         rangeID roachpb.RangeID,</span>
<span id="L350"><span class="lineNum">     350</span>              :         rLoad RangeLoad,</span>
<span id="L351"><span class="lineNum">     351</span>              :         replicaIDAndType ReplicaIDAndType,</span>
<span id="L352"><span class="lineNum">     352</span>              :         addTarget roachpb.ReplicationTarget,</span>
<span id="L353"><span class="lineNum">     353</span> <span class="tlaGNC">           6 : ) ReplicaChange {</span></span>
<span id="L354"><span class="lineNum">     354</span> <span class="tlaGNC">           6 :         replicaIDAndType.ReplicaType.ReplicaType = mapReplicaTypeToVoterOrNonVoter(</span></span>
<span id="L355"><span class="lineNum">     355</span> <span class="tlaGNC">           6 :                 replicaIDAndType.ReplicaType.ReplicaType)</span></span>
<span id="L356"><span class="lineNum">     356</span> <span class="tlaGNC">           6 :         replicaIDAndType.ReplicaID = unknownReplicaID</span></span>
<span id="L357"><span class="lineNum">     357</span> <span class="tlaGNC">           6 :         addReplica := ReplicaChange{</span></span>
<span id="L358"><span class="lineNum">     358</span> <span class="tlaGNC">           6 :                 target:  addTarget,</span></span>
<span id="L359"><span class="lineNum">     359</span> <span class="tlaGNC">           6 :                 rangeID: rangeID,</span></span>
<span id="L360"><span class="lineNum">     360</span> <span class="tlaGNC">           6 :                 prev: ReplicaState{</span></span>
<span id="L361"><span class="lineNum">     361</span> <span class="tlaGNC">           6 :                         ReplicaIDAndType: ReplicaIDAndType{</span></span>
<span id="L362"><span class="lineNum">     362</span> <span class="tlaGNC">           6 :                                 ReplicaID: noReplicaID,</span></span>
<span id="L363"><span class="lineNum">     363</span> <span class="tlaGNC">           6 :                         },</span></span>
<span id="L364"><span class="lineNum">     364</span> <span class="tlaGNC">           6 :                 },</span></span>
<span id="L365"><span class="lineNum">     365</span> <span class="tlaGNC">           6 :                 next: replicaIDAndType,</span></span>
<span id="L366"><span class="lineNum">     366</span> <span class="tlaGNC">           6 :         }</span></span>
<span id="L367"><span class="lineNum">     367</span> <span class="tlaGNC">           6 :         addReplica.next.ReplicaID = unknownReplicaID</span></span>
<span id="L368"><span class="lineNum">     368</span> <span class="tlaGNC">           6 :         addReplica.loadDelta.add(loadVectorToAdd(rLoad.Load))</span></span>
<span id="L369"><span class="lineNum">     369</span> <span class="tlaGNC">           6 :         if replicaIDAndType.IsLeaseholder {</span></span>
<span id="L370"><span class="lineNum">     370</span> <span class="tlaGNC">           5 :                 addReplica.secondaryLoadDelta[LeaseCount] = 1</span></span>
<span id="L371"><span class="lineNum">     371</span> <span class="tlaGNC">           5 :         } else {</span></span>
<span id="L372"><span class="lineNum">     372</span> <span class="tlaGNC">           1 :                 // Set the load delta for CPU to be just the raft CPU. The non-raft CPU we</span></span>
<span id="L373"><span class="lineNum">     373</span> <span class="tlaGNC">           1 :                 // assume is associated with the lease.</span></span>
<span id="L374"><span class="lineNum">     374</span> <span class="tlaGNC">           1 :                 addReplica.loadDelta[CPURate] = loadToAdd(rLoad.RaftCPU)</span></span>
<span id="L375"><span class="lineNum">     375</span> <span class="tlaGNC">           1 :         }</span></span>
<span id="L376"><span class="lineNum">     376</span> <span class="tlaGNC">           6 :         return addReplica</span></span>
<span id="L377"><span class="lineNum">     377</span>              : }</span>
<span id="L378"><span class="lineNum">     378</span>              : </span>
<span id="L379"><span class="lineNum">     379</span>              : // MakeRemoveReplicaChange creates a replica change which removes the replica</span>
<span id="L380"><span class="lineNum">     380</span>              : // given.</span>
<span id="L381"><span class="lineNum">     381</span>              : func MakeRemoveReplicaChange(</span>
<span id="L382"><span class="lineNum">     382</span>              :         rangeID roachpb.RangeID,</span>
<span id="L383"><span class="lineNum">     383</span>              :         rLoad RangeLoad,</span>
<span id="L384"><span class="lineNum">     384</span>              :         replicaState ReplicaState,</span>
<span id="L385"><span class="lineNum">     385</span>              :         removeTarget roachpb.ReplicationTarget,</span>
<span id="L386"><span class="lineNum">     386</span> <span class="tlaGNC">           7 : ) ReplicaChange {</span></span>
<span id="L387"><span class="lineNum">     387</span> <span class="tlaGNC">           7 :         removeReplica := ReplicaChange{</span></span>
<span id="L388"><span class="lineNum">     388</span> <span class="tlaGNC">           7 :                 target:  removeTarget,</span></span>
<span id="L389"><span class="lineNum">     389</span> <span class="tlaGNC">           7 :                 rangeID: rangeID,</span></span>
<span id="L390"><span class="lineNum">     390</span> <span class="tlaGNC">           7 :                 prev:    replicaState,</span></span>
<span id="L391"><span class="lineNum">     391</span> <span class="tlaGNC">           7 :                 next: ReplicaIDAndType{</span></span>
<span id="L392"><span class="lineNum">     392</span> <span class="tlaGNC">           7 :                         ReplicaID: noReplicaID,</span></span>
<span id="L393"><span class="lineNum">     393</span> <span class="tlaGNC">           7 :                 },</span></span>
<span id="L394"><span class="lineNum">     394</span> <span class="tlaGNC">           7 :         }</span></span>
<span id="L395"><span class="lineNum">     395</span> <span class="tlaGNC">           7 :         removeReplica.loadDelta.subtract(rLoad.Load)</span></span>
<span id="L396"><span class="lineNum">     396</span> <span class="tlaGNC">           7 :         if replicaState.IsLeaseholder {</span></span>
<span id="L397"><span class="lineNum">     397</span> <span class="tlaGNC">           5 :                 removeReplica.secondaryLoadDelta[LeaseCount] = -1</span></span>
<span id="L398"><span class="lineNum">     398</span> <span class="tlaGNC">           5 :         } else {</span></span>
<span id="L399"><span class="lineNum">     399</span> <span class="tlaGNC">           2 :                 // Set the load delta for CPU to be just the raft CPU. The non-raft CPU is</span></span>
<span id="L400"><span class="lineNum">     400</span> <span class="tlaGNC">           2 :                 // associated with the lease.</span></span>
<span id="L401"><span class="lineNum">     401</span> <span class="tlaGNC">           2 :                 removeReplica.loadDelta[CPURate] = -rLoad.RaftCPU</span></span>
<span id="L402"><span class="lineNum">     402</span> <span class="tlaGNC">           2 :         }</span></span>
<span id="L403"><span class="lineNum">     403</span> <span class="tlaGNC">           7 :         return removeReplica</span></span>
<span id="L404"><span class="lineNum">     404</span>              : }</span>
<span id="L405"><span class="lineNum">     405</span>              : </span>
<span id="L406"><span class="lineNum">     406</span>              : // MakeReplicaTypeChange creates a replica change which changes the type of</span>
<span id="L407"><span class="lineNum">     407</span>              : // the replica.</span>
<span id="L408"><span class="lineNum">     408</span>              : func MakeReplicaTypeChange(</span>
<span id="L409"><span class="lineNum">     409</span>              :         rangeID roachpb.RangeID,</span>
<span id="L410"><span class="lineNum">     410</span>              :         rLoad RangeLoad,</span>
<span id="L411"><span class="lineNum">     411</span>              :         prev ReplicaState,</span>
<span id="L412"><span class="lineNum">     412</span>              :         next ReplicaIDAndType,</span>
<span id="L413"><span class="lineNum">     413</span>              :         target roachpb.ReplicationTarget,</span>
<span id="L414"><span class="lineNum">     414</span> <span class="tlaUNC">           0 : ) ReplicaChange {</span></span>
<span id="L415"><span class="lineNum">     415</span> <span class="tlaUNC">           0 :         next.ReplicaID = unknownReplicaID</span></span>
<span id="L416"><span class="lineNum">     416</span> <span class="tlaUNC">           0 :         next.ReplicaType.ReplicaType = mapReplicaTypeToVoterOrNonVoter(next.ReplicaType.ReplicaType)</span></span>
<span id="L417"><span class="lineNum">     417</span> <span class="tlaUNC">           0 :         change := ReplicaChange{</span></span>
<span id="L418"><span class="lineNum">     418</span> <span class="tlaUNC">           0 :                 target:  target,</span></span>
<span id="L419"><span class="lineNum">     419</span> <span class="tlaUNC">           0 :                 rangeID: rangeID,</span></span>
<span id="L420"><span class="lineNum">     420</span> <span class="tlaUNC">           0 :                 prev:    prev,</span></span>
<span id="L421"><span class="lineNum">     421</span> <span class="tlaUNC">           0 :                 next:    next,</span></span>
<span id="L422"><span class="lineNum">     422</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L423"><span class="lineNum">     423</span> <span class="tlaUNC">           0 :         if next.IsLeaseholder {</span></span>
<span id="L424"><span class="lineNum">     424</span> <span class="tlaUNC">           0 :                 change.secondaryLoadDelta[LeaseCount] = 1</span></span>
<span id="L425"><span class="lineNum">     425</span> <span class="tlaUNC">           0 :                 change.loadDelta[CPURate] = loadToAdd(rLoad.Load[CPURate] - rLoad.RaftCPU)</span></span>
<span id="L426"><span class="lineNum">     426</span> <span class="tlaUNC">           0 :         } else if prev.IsLeaseholder {</span></span>
<span id="L427"><span class="lineNum">     427</span> <span class="tlaUNC">           0 :                 change.secondaryLoadDelta[LeaseCount] = -1</span></span>
<span id="L428"><span class="lineNum">     428</span> <span class="tlaUNC">           0 :                 change.loadDelta[CPURate] = rLoad.RaftCPU - rLoad.Load[CPURate]</span></span>
<span id="L429"><span class="lineNum">     429</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L430"><span class="lineNum">     430</span> <span class="tlaUNC">           0 :         return change</span></span>
<span id="L431"><span class="lineNum">     431</span>              : }</span>
<span id="L432"><span class="lineNum">     432</span>              : </span>
<span id="L433"><span class="lineNum">     433</span>              : // makeRebalanceReplicaChanges creates to replica changes, adding a replica and</span>
<span id="L434"><span class="lineNum">     434</span>              : // removing another. If the replica being rebalanced is the current</span>
<span id="L435"><span class="lineNum">     435</span>              : // leaseholder, the impact of the rebalance also includes the lease load.</span>
<span id="L436"><span class="lineNum">     436</span>              : func makeRebalanceReplicaChanges(</span>
<span id="L437"><span class="lineNum">     437</span>              :         rangeID roachpb.RangeID,</span>
<span id="L438"><span class="lineNum">     438</span>              :         existingReplicas []StoreIDAndReplicaState,</span>
<span id="L439"><span class="lineNum">     439</span>              :         rLoad RangeLoad,</span>
<span id="L440"><span class="lineNum">     440</span>              :         addTarget, removeTarget roachpb.ReplicationTarget,</span>
<span id="L441"><span class="lineNum">     441</span> <span class="tlaGNC">           6 : ) [2]ReplicaChange {</span></span>
<span id="L442"><span class="lineNum">     442</span> <span class="tlaGNC">           6 :         var remove StoreIDAndReplicaState</span></span>
<span id="L443"><span class="lineNum">     443</span> <span class="tlaGNC">           9 :         for _, replica := range existingReplicas {</span></span>
<span id="L444"><span class="lineNum">     444</span> <span class="tlaGNC">           9 :                 if replica.StoreID == removeTarget.StoreID {</span></span>
<span id="L445"><span class="lineNum">     445</span> <span class="tlaGNC">           6 :                         remove = replica</span></span>
<span id="L446"><span class="lineNum">     446</span> <span class="tlaGNC">           6 :                 }</span></span>
<span id="L447"><span class="lineNum">     447</span>              :         }</span>
<span id="L448"><span class="lineNum">     448</span> <span class="tlaGNC">           6 :         if remove == (StoreIDAndReplicaState{}) {</span></span>
<span id="L449"><span class="lineNum">     449</span> <span class="tlaUNC">           0 :                 log.KvDistribution.Fatalf(context.Background(), &quot;remove target %s not in existing replicas&quot;, removeTarget)</span></span>
<span id="L450"><span class="lineNum">     450</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L451"><span class="lineNum">     451</span>              : </span>
<span id="L452"><span class="lineNum">     452</span> <span class="tlaGNC">           6 :         addIDAndType := ReplicaIDAndType{</span></span>
<span id="L453"><span class="lineNum">     453</span> <span class="tlaGNC">           6 :                 ReplicaID:   unknownReplicaID,</span></span>
<span id="L454"><span class="lineNum">     454</span> <span class="tlaGNC">           6 :                 ReplicaType: remove.ReplicaType,</span></span>
<span id="L455"><span class="lineNum">     455</span> <span class="tlaGNC">           6 :         }</span></span>
<span id="L456"><span class="lineNum">     456</span> <span class="tlaGNC">           6 :         addReplicaChange := MakeAddReplicaChange(rangeID, rLoad, addIDAndType, addTarget)</span></span>
<span id="L457"><span class="lineNum">     457</span> <span class="tlaGNC">           6 :         removeReplicaChange := MakeRemoveReplicaChange(rangeID, rLoad, remove.ReplicaState, removeTarget)</span></span>
<span id="L458"><span class="lineNum">     458</span> <span class="tlaGNC">           6 :         return [2]ReplicaChange{addReplicaChange, removeReplicaChange}</span></span>
<span id="L459"><span class="lineNum">     459</span>              : }</span>
<span id="L460"><span class="lineNum">     460</span>              : </span>
<span id="L461"><span class="lineNum">     461</span> <span class="tlaGNC">           6 : func mapReplicaTypeToVoterOrNonVoter(rType roachpb.ReplicaType) roachpb.ReplicaType {</span></span>
<span id="L462"><span class="lineNum">     462</span> <span class="tlaGNC">           6 :         switch rType {</span></span>
<span id="L463"><span class="lineNum">     463</span> <span class="tlaGNC">           6 :         case roachpb.VOTER_FULL, roachpb.VOTER_INCOMING, roachpb.VOTER_DEMOTING_LEARNER, roachpb.VOTER_DEMOTING_NON_VOTER:</span></span>
<span id="L464"><span class="lineNum">     464</span> <span class="tlaGNC">           6 :                 return roachpb.VOTER_FULL</span></span>
<span id="L465"><span class="lineNum">     465</span> <span class="tlaUNC">           0 :         case roachpb.NON_VOTER, roachpb.LEARNER:</span></span>
<span id="L466"><span class="lineNum">     466</span> <span class="tlaUNC">           0 :                 return roachpb.NON_VOTER</span></span>
<span id="L467"><span class="lineNum">     467</span> <span class="tlaUNC">           0 :         default:</span></span>
<span id="L468"><span class="lineNum">     468</span> <span class="tlaUNC">           0 :                 panic(errors.AssertionFailedf(&quot;unknown replica type %v&quot;, rType))</span></span>
<span id="L469"><span class="lineNum">     469</span>              :         }</span>
<span id="L470"><span class="lineNum">     470</span>              : }</span>
<span id="L471"><span class="lineNum">     471</span>              : </span>
<span id="L472"><span class="lineNum">     472</span>              : // TODO(sumeer): place PendingRangeChange in a different file after</span>
<span id="L473"><span class="lineNum">     473</span>              : // https://github.com/cockroachdb/cockroach/pull/158024 merges.</span>
<span id="L474"><span class="lineNum">     474</span>              : //</span>
<span id="L475"><span class="lineNum">     475</span>              : // TODO(sumeer): PendingRangeChange is exported only because external callers</span>
<span id="L476"><span class="lineNum">     476</span>              : // need to be able to represent load changes when calling</span>
<span id="L477"><span class="lineNum">     477</span>              : // RegisterExternalChange. The ExternalRangeChange type does not represent</span>
<span id="L478"><span class="lineNum">     478</span>              : // load. There is possibly a better way to structure this, by including the</span>
<span id="L479"><span class="lineNum">     479</span>              : // LoadVector and SecondaryLoadVector in the ExternalRangeChange type, and</span>
<span id="L480"><span class="lineNum">     480</span>              : // unexporting PendingRangeChange.</span>
<span id="L481"><span class="lineNum">     481</span>              : </span>
<span id="L482"><span class="lineNum">     482</span>              : // PendingRangeChange is a container for a proposed set of change(s) to a</span>
<span id="L483"><span class="lineNum">     483</span>              : // range. It can consist of multiple pending replica changes, such as adding</span>
<span id="L484"><span class="lineNum">     484</span>              : // or removing replicas, or transferring the lease. There is at most one</span>
<span id="L485"><span class="lineNum">     485</span>              : // change per store in the set.</span>
<span id="L486"><span class="lineNum">     486</span>              : //</span>
<span id="L487"><span class="lineNum">     487</span>              : // The clusterState or anything contained in it, does not contain</span>
<span id="L488"><span class="lineNum">     488</span>              : // PendingRangeChange, and instead individual *pendingReplicaChange are stored</span>
<span id="L489"><span class="lineNum">     489</span>              : // in various maps and slices. Note that *pendingReplicaChanges contain</span>
<span id="L490"><span class="lineNum">     490</span>              : // mutable fields.</span>
<span id="L491"><span class="lineNum">     491</span>              : type PendingRangeChange struct {</span>
<span id="L492"><span class="lineNum">     492</span>              :         RangeID               roachpb.RangeID</span>
<span id="L493"><span class="lineNum">     493</span>              :         pendingReplicaChanges []*pendingReplicaChange</span>
<span id="L494"><span class="lineNum">     494</span>              : }</span>
<span id="L495"><span class="lineNum">     495</span>              : </span>
<span id="L496"><span class="lineNum">     496</span>              : // MakePendingRangeChange creates a PendingRangeChange for the given rangeID</span>
<span id="L497"><span class="lineNum">     497</span>              : // and changes. Certain internal aspects of the change, like the change-ids,</span>
<span id="L498"><span class="lineNum">     498</span>              : // start time etc., are not yet initialized, since those use internal state of</span>
<span id="L499"><span class="lineNum">     499</span>              : // MMA. Those will be initialized by MMA when this change is later handed to</span>
<span id="L500"><span class="lineNum">     500</span>              : // MMA for tracking, in clusterState.addPendingRangeChange. For external</span>
<span id="L501"><span class="lineNum">     501</span>              : // callers of MakePendingRangeChange, this happens transitively when</span>
<span id="L502"><span class="lineNum">     502</span>              : // Allocator.RegisterExternalChange is called.</span>
<span id="L503"><span class="lineNum">     503</span> <span class="tlaGNC">           9 : func MakePendingRangeChange(rangeID roachpb.RangeID, changes []ReplicaChange) PendingRangeChange {</span></span>
<span id="L504"><span class="lineNum">     504</span> <span class="tlaGNC">          17 :         for _, c := range changes {</span></span>
<span id="L505"><span class="lineNum">     505</span> <span class="tlaGNC">          17 :                 if c.rangeID != rangeID {</span></span>
<span id="L506"><span class="lineNum">     506</span> <span class="tlaUNC">           0 :                         panic(errors.AssertionFailedf(&quot;all changes must be to the same range %d != %d&quot;,</span></span>
<span id="L507"><span class="lineNum">     507</span> <span class="tlaUNC">           0 :                                 c.rangeID, rangeID))</span></span>
<span id="L508"><span class="lineNum">     508</span>              :                 }</span>
<span id="L509"><span class="lineNum">     509</span>              :         }</span>
<span id="L510"><span class="lineNum">     510</span> <span class="tlaGNC">           9 :         prcs := make([]*pendingReplicaChange, len(changes))</span></span>
<span id="L511"><span class="lineNum">     511</span> <span class="tlaGNC">          17 :         for i, c := range changes {</span></span>
<span id="L512"><span class="lineNum">     512</span> <span class="tlaGNC">          17 :                 prcs[i] = &amp;pendingReplicaChange{</span></span>
<span id="L513"><span class="lineNum">     513</span> <span class="tlaGNC">          17 :                         ReplicaChange: c,</span></span>
<span id="L514"><span class="lineNum">     514</span> <span class="tlaGNC">          17 :                 }</span></span>
<span id="L515"><span class="lineNum">     515</span> <span class="tlaGNC">          17 :         }</span></span>
<span id="L516"><span class="lineNum">     516</span> <span class="tlaGNC">           9 :         return PendingRangeChange{</span></span>
<span id="L517"><span class="lineNum">     517</span> <span class="tlaGNC">           9 :                 RangeID:               rangeID,</span></span>
<span id="L518"><span class="lineNum">     518</span> <span class="tlaGNC">           9 :                 pendingReplicaChanges: prcs,</span></span>
<span id="L519"><span class="lineNum">     519</span> <span class="tlaGNC">           9 :         }</span></span>
<span id="L520"><span class="lineNum">     520</span>              : }</span>
<span id="L521"><span class="lineNum">     521</span>              : </span>
<span id="L522"><span class="lineNum">     522</span> <span class="tlaUNC">           0 : func (prc PendingRangeChange) String() string {</span></span>
<span id="L523"><span class="lineNum">     523</span> <span class="tlaUNC">           0 :         return redact.StringWithoutMarkers(prc)</span></span>
<span id="L524"><span class="lineNum">     524</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L525"><span class="lineNum">     525</span>              : </span>
<span id="L526"><span class="lineNum">     526</span>              : // SafeFormat implements the redact.SafeFormatter interface.</span>
<span id="L527"><span class="lineNum">     527</span>              : //</span>
<span id="L528"><span class="lineNum">     528</span>              : // This is adhoc for debugging. A nicer string format would include the</span>
<span id="L529"><span class="lineNum">     529</span>              : // previous state and next state.</span>
<span id="L530"><span class="lineNum">     530</span> <span class="tlaUNC">           0 : func (prc PendingRangeChange) SafeFormat(w redact.SafePrinter, _ rune) {</span></span>
<span id="L531"><span class="lineNum">     531</span> <span class="tlaUNC">           0 :         w.Printf(&quot;r%v=[&quot;, prc.RangeID)</span></span>
<span id="L532"><span class="lineNum">     532</span> <span class="tlaUNC">           0 :         nextAddOrChangeReplicaStr := func(next ReplicaType) string {</span></span>
<span id="L533"><span class="lineNum">     533</span> <span class="tlaUNC">           0 :                 if next.ReplicaType == roachpb.NON_VOTER {</span></span>
<span id="L534"><span class="lineNum">     534</span> <span class="tlaUNC">           0 :                         return &quot;non-voter&quot;</span></span>
<span id="L535"><span class="lineNum">     535</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L536"><span class="lineNum">     536</span> <span class="tlaUNC">           0 :                 if next.IsLeaseholder {</span></span>
<span id="L537"><span class="lineNum">     537</span> <span class="tlaUNC">           0 :                         return &quot;voter-leaseholder&quot;</span></span>
<span id="L538"><span class="lineNum">     538</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L539"><span class="lineNum">     539</span> <span class="tlaUNC">           0 :                 return &quot;voter&quot;</span></span>
<span id="L540"><span class="lineNum">     540</span>              :         }</span>
<span id="L541"><span class="lineNum">     541</span> <span class="tlaUNC">           0 :         for i, c := range prc.pendingReplicaChanges {</span></span>
<span id="L542"><span class="lineNum">     542</span> <span class="tlaUNC">           0 :                 if i &gt; 0 {</span></span>
<span id="L543"><span class="lineNum">     543</span> <span class="tlaUNC">           0 :                         w.Print(&quot; &quot;)</span></span>
<span id="L544"><span class="lineNum">     544</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L545"><span class="lineNum">     545</span> <span class="tlaUNC">           0 :                 w.Printf(&quot;id:%d&quot;, c.changeID)</span></span>
<span id="L546"><span class="lineNum">     546</span> <span class="tlaUNC">           0 :                 switch c.replicaChangeType() {</span></span>
<span id="L547"><span class="lineNum">     547</span> <span class="tlaUNC">           0 :                 case Unknown:</span></span>
<span id="L548"><span class="lineNum">     548</span> <span class="tlaUNC">           0 :                         w.Printf(&quot;unknown-change:s%v&quot;, c.target.StoreID)</span></span>
<span id="L549"><span class="lineNum">     549</span> <span class="tlaUNC">           0 :                 case AddLease:</span></span>
<span id="L550"><span class="lineNum">     550</span> <span class="tlaUNC">           0 :                         w.Printf(&quot;add-lease:s%v&quot;, c.target.StoreID)</span></span>
<span id="L551"><span class="lineNum">     551</span> <span class="tlaUNC">           0 :                 case RemoveLease:</span></span>
<span id="L552"><span class="lineNum">     552</span> <span class="tlaUNC">           0 :                         w.Printf(&quot;remove-lease:s%v&quot;, c.target.StoreID)</span></span>
<span id="L553"><span class="lineNum">     553</span> <span class="tlaUNC">           0 :                 case AddReplica:</span></span>
<span id="L554"><span class="lineNum">     554</span> <span class="tlaUNC">           0 :                         w.Printf(&quot;add-%s:s%v&quot;, nextAddOrChangeReplicaStr(c.next.ReplicaType), c.target.StoreID)</span></span>
<span id="L555"><span class="lineNum">     555</span> <span class="tlaUNC">           0 :                 case RemoveReplica:</span></span>
<span id="L556"><span class="lineNum">     556</span> <span class="tlaUNC">           0 :                         w.Printf(&quot;remove-replica:s%v&quot;, c.target.StoreID)</span></span>
<span id="L557"><span class="lineNum">     557</span> <span class="tlaUNC">           0 :                 case ChangeReplica:</span></span>
<span id="L558"><span class="lineNum">     558</span> <span class="tlaUNC">           0 :                         w.Printf(&quot;change-to-%s:s%v&quot;, nextAddOrChangeReplicaStr(c.next.ReplicaType),</span></span>
<span id="L559"><span class="lineNum">     559</span> <span class="tlaUNC">           0 :                                 c.target.StoreID)</span></span>
<span id="L560"><span class="lineNum">     560</span>              :                 }</span>
<span id="L561"><span class="lineNum">     561</span>              :         }</span>
<span id="L562"><span class="lineNum">     562</span> <span class="tlaUNC">           0 :         w.Print(&quot;]&quot;)</span></span>
<span id="L563"><span class="lineNum">     563</span>              : }</span>
<span id="L564"><span class="lineNum">     564</span>              : </span>
<span id="L565"><span class="lineNum">     565</span>              : // StringForTesting prints the untransformed internal state for testing.</span>
<span id="L566"><span class="lineNum">     566</span> <span class="tlaUNC">           0 : func (prc PendingRangeChange) StringForTesting() string {</span></span>
<span id="L567"><span class="lineNum">     567</span> <span class="tlaUNC">           0 :         var b strings.Builder</span></span>
<span id="L568"><span class="lineNum">     568</span> <span class="tlaUNC">           0 :         fmt.Fprintf(&amp;b, &quot;range r%v\n&quot;, prc.RangeID)</span></span>
<span id="L569"><span class="lineNum">     569</span> <span class="tlaUNC">           0 :         for _, c := range prc.pendingReplicaChanges {</span></span>
<span id="L570"><span class="lineNum">     570</span> <span class="tlaUNC">           0 :                 fmt.Fprintf(&amp;b, &quot; %s\n&quot;, c.ReplicaChange.String())</span></span>
<span id="L571"><span class="lineNum">     571</span> <span class="tlaUNC">           0 :                 fmt.Fprintf(&amp;b, &quot;  load: %s\n&quot;, c.loadDelta.String())</span></span>
<span id="L572"><span class="lineNum">     572</span> <span class="tlaUNC">           0 :                 fmt.Fprintf(&amp;b, &quot;  secondary-load: %s\n&quot;, c.secondaryLoadDelta.String())</span></span>
<span id="L573"><span class="lineNum">     573</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L574"><span class="lineNum">     574</span> <span class="tlaUNC">           0 :         return b.String()</span></span>
<span id="L575"><span class="lineNum">     575</span>              : }</span>
<span id="L576"><span class="lineNum">     576</span>              : </span>
<span id="L577"><span class="lineNum">     577</span>              : // SortForTesting sorts the internal pendingReplicaChanges slice to be</span>
<span id="L578"><span class="lineNum">     578</span>              : // deterministic, in increasing order of StoreID, for testing purposes.</span>
<span id="L579"><span class="lineNum">     579</span> <span class="tlaUNC">           0 : func (prc PendingRangeChange) SortForTesting() {</span></span>
<span id="L580"><span class="lineNum">     580</span> <span class="tlaUNC">           0 :         slices.SortFunc(prc.pendingReplicaChanges, func(a, b *pendingReplicaChange) int {</span></span>
<span id="L581"><span class="lineNum">     581</span> <span class="tlaUNC">           0 :                 return cmp.Compare(a.target.StoreID, b.target.StoreID)</span></span>
<span id="L582"><span class="lineNum">     582</span> <span class="tlaUNC">           0 :         })</span></span>
<span id="L583"><span class="lineNum">     583</span>              : }</span>
<span id="L584"><span class="lineNum">     584</span>              : </span>
<span id="L585"><span class="lineNum">     585</span>              : // isTransferLease returns true if the pending range change is a transfer</span>
<span id="L586"><span class="lineNum">     586</span>              : // lease operation.</span>
<span id="L587"><span class="lineNum">     587</span> <span class="tlaGNC">           9 : func (prc PendingRangeChange) isTransferLease() bool {</span></span>
<span id="L588"><span class="lineNum">     588</span> <span class="tlaGNC">           9 :         if len(prc.pendingReplicaChanges) != 2 {</span></span>
<span id="L589"><span class="lineNum">     589</span> <span class="tlaGNC">           1 :                 return false</span></span>
<span id="L590"><span class="lineNum">     590</span> <span class="tlaGNC">           1 :         }</span></span>
<span id="L591"><span class="lineNum">     591</span> <span class="tlaGNC">           8 :         var foundAddLease, foundRemoveLease bool</span></span>
<span id="L592"><span class="lineNum">     592</span> <span class="tlaGNC">          10 :         for _, c := range prc.pendingReplicaChanges {</span></span>
<span id="L593"><span class="lineNum">     593</span> <span class="tlaGNC">          10 :                 switch c.replicaChangeType() {</span></span>
<span id="L594"><span class="lineNum">     594</span>              :                 // Any changes to the replica type or replicaID are not lease</span>
<span id="L595"><span class="lineNum">     595</span>              :                 // transfers, since they require a replication change.</span>
<span id="L596"><span class="lineNum">     596</span> <span class="tlaGNC">           6 :                 case AddReplica, RemoveReplica, ChangeReplica:</span></span>
<span id="L597"><span class="lineNum">     597</span> <span class="tlaGNC">           6 :                         return false</span></span>
<span id="L598"><span class="lineNum">     598</span>              :                 }</span>
<span id="L599"><span class="lineNum">     599</span> <span class="tlaGNC">           4 :                 if c.prev.IsLeaseholder &amp;&amp; !c.next.IsLeaseholder {</span></span>
<span id="L600"><span class="lineNum">     600</span> <span class="tlaGNC">           2 :                         foundRemoveLease = true</span></span>
<span id="L601"><span class="lineNum">     601</span> <span class="tlaGNC">           2 :                 } else if !c.prev.IsLeaseholder &amp;&amp; c.next.IsLeaseholder {</span></span>
<span id="L602"><span class="lineNum">     602</span> <span class="tlaGNC">           2 :                         foundAddLease = true</span></span>
<span id="L603"><span class="lineNum">     603</span> <span class="tlaGNC">           2 :                 } else {</span></span>
<span id="L604"><span class="lineNum">     604</span> <span class="tlaUNC">           0 :                         return false</span></span>
<span id="L605"><span class="lineNum">     605</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L606"><span class="lineNum">     606</span>              :         }</span>
<span id="L607"><span class="lineNum">     607</span> <span class="tlaGNC">           2 :         return foundAddLease &amp;&amp; foundRemoveLease</span></span>
<span id="L608"><span class="lineNum">     608</span>              : }</span>
<span id="L609"><span class="lineNum">     609</span>              : </span>
<span id="L610"><span class="lineNum">     610</span>              : // pendingReplicaChange is a proposed change to a single replica. Some</span>
<span id="L611"><span class="lineNum">     611</span>              : // external entity (the leaseholder of the range) may choose to enact this</span>
<span id="L612"><span class="lineNum">     612</span>              : // change. It may not be enacted if it will cause some invariant (like the</span>
<span id="L613"><span class="lineNum">     613</span>              : // number of replicas, or having a leaseholder) to be violated. If not</span>
<span id="L614"><span class="lineNum">     614</span>              : // enacted, the allocator will either be told about the lack of enactment, or</span>
<span id="L615"><span class="lineNum">     615</span>              : // will eventually expire from the allocator's state at gcTime. Such</span>
<span id="L616"><span class="lineNum">     616</span>              : // expiration without enactment should be rare. pendingReplicaChanges can be</span>
<span id="L617"><span class="lineNum">     617</span>              : // paired, when a range is being moved from one store to another -- that</span>
<span id="L618"><span class="lineNum">     618</span>              : // pairing is not captured here, and captured in the changes suggested by the</span>
<span id="L619"><span class="lineNum">     619</span>              : // allocator to the external entity.</span>
<span id="L620"><span class="lineNum">     620</span>              : type pendingReplicaChange struct {</span>
<span id="L621"><span class="lineNum">     621</span>              :         changeID</span>
<span id="L622"><span class="lineNum">     622</span>              :         ReplicaChange</span>
<span id="L623"><span class="lineNum">     623</span>              : </span>
<span id="L624"><span class="lineNum">     624</span>              :         // The wall time at which this pending change was initiated. Used for</span>
<span id="L625"><span class="lineNum">     625</span>              :         // expiry. All replica changes in a PendingRangeChange have the same</span>
<span id="L626"><span class="lineNum">     626</span>              :         // startTime.</span>
<span id="L627"><span class="lineNum">     627</span>              :         startTime time.Time</span>
<span id="L628"><span class="lineNum">     628</span>              :         // gcTime represents a time when the unenacted change should be GC'd, either</span>
<span id="L629"><span class="lineNum">     629</span>              :         // using the normal GC undo path, or if rangeState.pendingChangeNoRollback</span>
<span id="L630"><span class="lineNum">     630</span>              :         // is true, when processing a RangeMsg from the leaseholder.</span>
<span id="L631"><span class="lineNum">     631</span>              :         gcTime time.Time</span>
<span id="L632"><span class="lineNum">     632</span>              : </span>
<span id="L633"><span class="lineNum">     633</span>              :         // TODO(kvoli,sumeerbhola): Consider adopting an explicit expiration time,</span>
<span id="L634"><span class="lineNum">     634</span>              :         // after which the change is considered to have been rejected. This would</span>
<span id="L635"><span class="lineNum">     635</span>              :         // allow a different expiration time for different types of changes, e.g.,</span>
<span id="L636"><span class="lineNum">     636</span>              :         // lease transfers would have a smaller expiration time than replica</span>
<span id="L637"><span class="lineNum">     637</span>              :         // additions.</span>
<span id="L638"><span class="lineNum">     638</span>              : </span>
<span id="L639"><span class="lineNum">     639</span>              :         // When the change is known to be enacted based on the authoritative</span>
<span id="L640"><span class="lineNum">     640</span>              :         // information received from the leaseholder, this value is set, so that even</span>
<span id="L641"><span class="lineNum">     641</span>              :         // if the store with a replica affected by this pending change does not tell</span>
<span id="L642"><span class="lineNum">     642</span>              :         // us about the enactment, we can garbage collect this change.</span>
<span id="L643"><span class="lineNum">     643</span>              :         enactedAtTime time.Time</span>
<span id="L644"><span class="lineNum">     644</span>              : }</span>
<span id="L645"><span class="lineNum">     645</span>              : </span>
<span id="L646"><span class="lineNum">     646</span>              : // storeState maintains the complete state about a store as known to the</span>
<span id="L647"><span class="lineNum">     647</span>              : // allocator.</span>
<span id="L648"><span class="lineNum">     648</span>              : type storeState struct {</span>
<span id="L649"><span class="lineNum">     649</span>              :         status Status</span>
<span id="L650"><span class="lineNum">     650</span>              :         storeLoad</span>
<span id="L651"><span class="lineNum">     651</span>              :         StoreAttributesAndLocality</span>
<span id="L652"><span class="lineNum">     652</span>              :         adjusted struct {</span>
<span id="L653"><span class="lineNum">     653</span>              :                 // NB: these load values can become negative due to applying pending</span>
<span id="L654"><span class="lineNum">     654</span>              :                 // changes. We need to let them be negative to retain the ability to undo</span>
<span id="L655"><span class="lineNum">     655</span>              :                 // pending changes.</span>
<span id="L656"><span class="lineNum">     656</span>              :                 load          LoadVector</span>
<span id="L657"><span class="lineNum">     657</span>              :                 secondaryLoad SecondaryLoadVector</span>
<span id="L658"><span class="lineNum">     658</span>              :                 // Pending changes for computing loadReplicas and load.</span>
<span id="L659"><span class="lineNum">     659</span>              :                 // Added to at the same time as clusterState.pendingChanges.</span>
<span id="L660"><span class="lineNum">     660</span>              :                 //</span>
<span id="L661"><span class="lineNum">     661</span>              :                 // Removed from lifecyle is slightly different from those other pending changes.</span>
<span id="L662"><span class="lineNum">     662</span>              :                 // If clusterState.pendingChanges is removing a pending change because:</span>
<span id="L663"><span class="lineNum">     663</span>              :                 //</span>
<span id="L664"><span class="lineNum">     664</span>              :                 // - rejected by enacting module, it will also remove from</span>
<span id="L665"><span class="lineNum">     665</span>              :                 //   loadPendingChanges. Similarly time-based GC from</span>
<span id="L666"><span class="lineNum">     666</span>              :                 //   clusterState.pendingChanges will also remove from here.</span>
<span id="L667"><span class="lineNum">     667</span>              :                 //</span>
<span id="L668"><span class="lineNum">     668</span>              :                 // - leaseholder provided state shows that the change has been enacted, it</span>
<span id="L669"><span class="lineNum">     669</span>              :                 //   will set enactedAtTime, but not remove from loadPendingChanges since</span>
<span id="L670"><span class="lineNum">     670</span>              :                 //   this pending change is still needed to compensate for the store</span>
<span id="L671"><span class="lineNum">     671</span>              :                 //   reported load. Once computePendingChangesReflectedInLatestLoad</span>
<span id="L672"><span class="lineNum">     672</span>              :                 //   determines that the latest load state must include the pending</span>
<span id="L673"><span class="lineNum">     673</span>              :                 //   change, it will be removed.</span>
<span id="L674"><span class="lineNum">     674</span>              :                 //</span>
<span id="L675"><span class="lineNum">     675</span>              :                 // In summary, guaranteed removal of a load pending change because of</span>
<span id="L676"><span class="lineNum">     676</span>              :                 // failure of enactment or GC happens via clusterState.pendingChanges.</span>
<span id="L677"><span class="lineNum">     677</span>              :                 // Only the case where enactment happened is where a load pending change</span>
<span id="L678"><span class="lineNum">     678</span>              :                 // can live on -- but since that will set enactedAtTime, we are guaranteed</span>
<span id="L679"><span class="lineNum">     679</span>              :                 // to eventually remove it.</span>
<span id="L680"><span class="lineNum">     680</span>              :                 loadPendingChanges map[changeID]*pendingReplicaChange</span>
<span id="L681"><span class="lineNum">     681</span>              :                 // replicas is computed from the authoritative information provided by</span>
<span id="L682"><span class="lineNum">     682</span>              :                 // various leaseholders in storeLeaseholderMsgs and adjusted for pending</span>
<span id="L683"><span class="lineNum">     683</span>              :                 // changes in clusterState.pendingChanges/rangeState.pendingChanges.</span>
<span id="L684"><span class="lineNum">     684</span>              :                 //</span>
<span id="L685"><span class="lineNum">     685</span>              :                 // This is consistent with the union of state in clusterState.ranges,</span>
<span id="L686"><span class="lineNum">     686</span>              :                 // filtered for replicas that are on this store.</span>
<span id="L687"><span class="lineNum">     687</span>              :                 //</span>
<span id="L688"><span class="lineNum">     688</span>              :                 // NB: this can include roachpb.ReplicaTypes other than VOTER_FULL and</span>
<span id="L689"><span class="lineNum">     689</span>              :                 // NON_VOTER, e.g. LEARNER, VOTER_DEMOTING_LEARNER etc.</span>
<span id="L690"><span class="lineNum">     690</span>              :                 replicas map[roachpb.RangeID]ReplicaState</span>
<span id="L691"><span class="lineNum">     691</span>              :                 // topKRanges along some load dimension. If the store is overloaded along</span>
<span id="L692"><span class="lineNum">     692</span>              :                 // one resource dimension, that is the dimension chosen when picking the</span>
<span id="L693"><span class="lineNum">     693</span>              :                 // top-k.</span>
<span id="L694"><span class="lineNum">     694</span>              :                 //</span>
<span id="L695"><span class="lineNum">     695</span>              :                 // It includes ranges whose replicas are being removed via pending</span>
<span id="L696"><span class="lineNum">     696</span>              :                 // changes, or lease transfers. That is, it does not account for</span>
<span id="L697"><span class="lineNum">     697</span>              :                 // pending or enacted changes made since the last time top-k was</span>
<span id="L698"><span class="lineNum">     698</span>              :                 // computed. It does account for pending changes that were pending</span>
<span id="L699"><span class="lineNum">     699</span>              :                 // when the top-k was computed.</span>
<span id="L700"><span class="lineNum">     700</span>              :                 //</span>
<span id="L701"><span class="lineNum">     701</span>              :                 // The key in this map is a local store-id.</span>
<span id="L702"><span class="lineNum">     702</span>              :                 //</span>
<span id="L703"><span class="lineNum">     703</span>              :                 // NB: this only includes replicas that satisfy the isVoter() or</span>
<span id="L704"><span class="lineNum">     704</span>              :                 // isNonVoter() methods, i.e., {VOTER_FULL, VOTER_INCOMING, NON_VOTER,</span>
<span id="L705"><span class="lineNum">     705</span>              :                 // VOTER_DEMOTING_NON_VOTER}. This is justified in that these are the</span>
<span id="L706"><span class="lineNum">     706</span>              :                 // only replica types where the allocator wants to explicitly consider</span>
<span id="L707"><span class="lineNum">     707</span>              :                 // shedding, since the other states are transient states, that are</span>
<span id="L708"><span class="lineNum">     708</span>              :                 // either going away, or will soon transition to a full-fledged state.</span>
<span id="L709"><span class="lineNum">     709</span>              :                 //</span>
<span id="L710"><span class="lineNum">     710</span>              :                 // We may decide to keep this top-k up-to-date incrementally instead of</span>
<span id="L711"><span class="lineNum">     711</span>              :                 // recomputing it from scratch on each StoreLeaseholderMsg.</span>
<span id="L712"><span class="lineNum">     712</span>              :                 //</span>
<span id="L713"><span class="lineNum">     713</span>              :                 // Example:</span>
<span id="L714"><span class="lineNum">     714</span>              :                 // Assume the local node has two stores, s1 and s2.</span>
<span id="L715"><span class="lineNum">     715</span>              :                 // - s1 has a range r100 with replicas {s1,s3,s4} and it is leaseholder.</span>
<span id="L716"><span class="lineNum">     716</span>              :                 // - s2 has a range r200 with replicas {s2,s4,s5}, and it is the leaseholder.</span>
<span id="L717"><span class="lineNum">     717</span>              :                 // - s1 and s2 have a range r300 with replicas {s1,s2,s5}, but neither is the leaseholder.</span>
<span id="L718"><span class="lineNum">     718</span>              :                 // - s1 and s2 have a range r400 with replicas {s1,s2,s5}, and s2 holds the lease.</span>
<span id="L719"><span class="lineNum">     719</span>              :                 //</span>
<span id="L720"><span class="lineNum">     720</span>              :                 // Then the mmma will maintain storeStates for s1-s5 (ss1-ss5), but in each</span>
<span id="L721"><span class="lineNum">     721</span>              :                 // of them, the topKRanges will only consider the ranges for which a local</span>
<span id="L722"><span class="lineNum">     722</span>              :                 // store holds the lease. In the example above, we get:</span>
<span id="L723"><span class="lineNum">     723</span>              :                 //</span>
<span id="L724"><span class="lineNum">     724</span>              :                 // ss1.topKRanges = {</span>
<span id="L725"><span class="lineNum">     725</span>              :                 //   s1: topK(r100)</span>
<span id="L726"><span class="lineNum">     726</span>              :                 //   s2: topK(r400)</span>
<span id="L727"><span class="lineNum">     727</span>              :                 // }</span>
<span id="L728"><span class="lineNum">     728</span>              :                 // ss2.topKRanges = {</span>
<span id="L729"><span class="lineNum">     729</span>              :                 //   s2: topK(r200,r400)</span>
<span id="L730"><span class="lineNum">     730</span>              :                 // }</span>
<span id="L731"><span class="lineNum">     731</span>              :                 // ss3.topKRanges = {</span>
<span id="L732"><span class="lineNum">     732</span>              :                 //   s1: topK(r100)</span>
<span id="L733"><span class="lineNum">     733</span>              :                 // }</span>
<span id="L734"><span class="lineNum">     734</span>              :                 // ss4.topKRanges = {</span>
<span id="L735"><span class="lineNum">     735</span>              :                 //   s1: topK(r100)</span>
<span id="L736"><span class="lineNum">     736</span>              :                 //   s2: topK(r200)</span>
<span id="L737"><span class="lineNum">     737</span>              :                 // }</span>
<span id="L738"><span class="lineNum">     738</span>              :                 // ss5.topKRanges = {</span>
<span id="L739"><span class="lineNum">     739</span>              :                 //   s2: topK(r200,r400)</span>
<span id="L740"><span class="lineNum">     740</span>              :                 // }</span>
<span id="L741"><span class="lineNum">     741</span>              :                 //</span>
<span id="L742"><span class="lineNum">     742</span>              :                 // Note that the sort order of each topKRanges is determined by the type of</span>
<span id="L743"><span class="lineNum">     743</span>              :                 // load that is most important for the store to shed, and that ranges with</span>
<span id="L744"><span class="lineNum">     744</span>              :                 // only minimal contribution (relative to the mean) to the load are not even</span>
<span id="L745"><span class="lineNum">     745</span>              :                 // considered for inclusion in topKRanges.</span>
<span id="L746"><span class="lineNum">     746</span>              :                 topKRanges map[roachpb.StoreID]*topKReplicas</span>
<span id="L747"><span class="lineNum">     747</span>              :         }</span>
<span id="L748"><span class="lineNum">     748</span>              :         // This is a locally incremented seqnum which is incremented whenever the</span>
<span id="L749"><span class="lineNum">     749</span>              :         // adjusted or reported load information for this store or the containing</span>
<span id="L750"><span class="lineNum">     750</span>              :         // node is updated. It is utilized for cache invalidation of the</span>
<span id="L751"><span class="lineNum">     751</span>              :         // storeLoadSummary stored in meansForStoreSet.</span>
<span id="L752"><span class="lineNum">     752</span>              :         loadSeqNum uint64</span>
<span id="L753"><span class="lineNum">     753</span>              : </span>
<span id="L754"><span class="lineNum">     754</span>              :         // maxFractionPendingIncrease is computed for load dimensions where</span>
<span id="L755"><span class="lineNum">     755</span>              :         // adjusted.load[i] &gt; reportedLoad[i], and maxFractionPendingDecrease is</span>
<span id="L756"><span class="lineNum">     756</span>              :         // computed for load dimensions where adjusted.load[i] &lt; reportedLoad[i].</span>
<span id="L757"><span class="lineNum">     757</span>              :         // These are:</span>
<span id="L758"><span class="lineNum">     758</span>              :         // max(|1-(adjusted.load[i]/reportedLoad[i])|)</span>
<span id="L759"><span class="lineNum">     759</span>              :         //</span>
<span id="L760"><span class="lineNum">     760</span>              :         // If maxFractionPendingIncrease is greater than some threshold, we don't add</span>
<span id="L761"><span class="lineNum">     761</span>              :         // more load to the store. If maxFractionPendingIncrease is greater than zero,</span>
<span id="L762"><span class="lineNum">     762</span>              :         // we don't shed from that store, since we may be over-estimating the load on</span>
<span id="L763"><span class="lineNum">     763</span>              :         // that store.</span>
<span id="L764"><span class="lineNum">     764</span>              :         //</span>
<span id="L765"><span class="lineNum">     765</span>              :         // If maxFractionPendingDecrease is greater than some threshold, we don't</span>
<span id="L766"><span class="lineNum">     766</span>              :         // remove more load unless we are shedding load due to failure detection.</span>
<span id="L767"><span class="lineNum">     767</span>              :         //</span>
<span id="L768"><span class="lineNum">     768</span>              :         // This is to allow the effect of the changes to stabilize since our</span>
<span id="L769"><span class="lineNum">     769</span>              :         // adjustments to load vectors are estimates, and there can be overhead on</span>
<span id="L770"><span class="lineNum">     770</span>              :         // these nodes due to making the change.</span>
<span id="L771"><span class="lineNum">     771</span>              :         maxFractionPendingIncrease float64</span>
<span id="L772"><span class="lineNum">     772</span>              :         maxFractionPendingDecrease float64</span>
<span id="L773"><span class="lineNum">     773</span>              : </span>
<span id="L774"><span class="lineNum">     774</span>              :         // TODO: consider adding a maxFractionPending at the node level since with</span>
<span id="L775"><span class="lineNum">     775</span>              :         // many stores on a node, some stores may have used up all the budget for</span>
<span id="L776"><span class="lineNum">     776</span>              :         // changes at the node.</span>
<span id="L777"><span class="lineNum">     777</span>              : </span>
<span id="L778"><span class="lineNum">     778</span>              :         localityTiers</span>
<span id="L779"><span class="lineNum">     779</span>              : </span>
<span id="L780"><span class="lineNum">     780</span>              :         // Time when this store started to be observed as overloaded. Set by</span>
<span id="L781"><span class="lineNum">     781</span>              :         // clusterState.rebalanceStores.</span>
<span id="L782"><span class="lineNum">     782</span>              :         overloadStartTime time.Time</span>
<span id="L783"><span class="lineNum">     783</span>              :         // When overloaded this is equal to time.Time{}.</span>
<span id="L784"><span class="lineNum">     784</span>              :         overloadEndTime time.Time</span>
<span id="L785"><span class="lineNum">     785</span>              : }</span>
<span id="L786"><span class="lineNum">     786</span>              : </span>
<span id="L787"><span class="lineNum">     787</span>              : // The time duration between a change happening at a store, and when the</span>
<span id="L788"><span class="lineNum">     788</span>              : // effect of that change is seen in the load information computed by that</span>
<span id="L789"><span class="lineNum">     789</span>              : // store.</span>
<span id="L790"><span class="lineNum">     790</span>              : //</span>
<span id="L791"><span class="lineNum">     791</span>              : // NOTE: The gossip interval is 10s  (see gossip.go StoresInterval). On a</span>
<span id="L792"><span class="lineNum">     792</span>              : // signficant load change (% delta), the store will gossip more frequently (see</span>
<span id="L793"><span class="lineNum">     793</span>              : // kvserver/store_gossip.go).</span>
<span id="L794"><span class="lineNum">     794</span>              : //</span>
<span id="L795"><span class="lineNum">     795</span>              : // This value has nothing to do with the gossip interval, since this is lag</span>
<span id="L796"><span class="lineNum">     796</span>              : // added to the origin timestamp of the gossip message. It probably has to do</span>
<span id="L797"><span class="lineNum">     797</span>              : // with the fact that we use NodeCapacity when constructing StoreLoadMsg, and</span>
<span id="L798"><span class="lineNum">     798</span>              : // that includes NodeCPURateUsage which is the actual observed node cpu rate,</span>
<span id="L799"><span class="lineNum">     799</span>              : // and we want to give some time for that to react to the change. We use</span>
<span id="L800"><span class="lineNum">     800</span>              : // RuntimeLoadMonitor for that node cpu rate -- need to look at that code to</span>
<span id="L801"><span class="lineNum">     801</span>              : // see whether this 10s makes sense.</span>
<span id="L802"><span class="lineNum">     802</span>              : const lagForChangeReflectedInLoad = 10 * time.Second</span>
<span id="L803"><span class="lineNum">     803</span>              : </span>
<span id="L804"><span class="lineNum">     804</span>              : func (ss *storeState) computePendingChangesReflectedInLatestLoad(</span>
<span id="L805"><span class="lineNum">     805</span>              :         latestLoadTime time.Time,</span>
<span id="L806"><span class="lineNum">     806</span> <span class="tlaGNC">          21 : ) []*pendingReplicaChange {</span></span>
<span id="L807"><span class="lineNum">     807</span> <span class="tlaGNC">          21 :         var changes []*pendingReplicaChange</span></span>
<span id="L808"><span class="lineNum">     808</span> <span class="tlaGNC">          21 :         for _, change := range ss.adjusted.loadPendingChanges {</span></span>
<span id="L809"><span class="lineNum">     809</span> <span class="tlaGNC">           9 :                 if change.enactedAtTime.IsZero() {</span></span>
<span id="L810"><span class="lineNum">     810</span> <span class="tlaGNC">           1 :                         // Not yet enacted, based on the information provided by the</span></span>
<span id="L811"><span class="lineNum">     811</span> <span class="tlaGNC">           1 :                         // leaseholder, which is always considered most up-to-date (because of</span></span>
<span id="L812"><span class="lineNum">     812</span> <span class="tlaGNC">           1 :                         // AdjustPendingChangesDisposition)</span></span>
<span id="L813"><span class="lineNum">     813</span> <span class="tlaGNC">           1 :                         continue</span></span>
<span id="L814"><span class="lineNum">     814</span>              :                 }</span>
<span id="L815"><span class="lineNum">     815</span>              :                 // Is enacted.</span>
<span id="L816"><span class="lineNum">     816</span> <span class="tlaGNC">           8 :                 if latestLoadTime.Sub(change.enactedAtTime) &gt; lagForChangeReflectedInLoad {</span></span>
<span id="L817"><span class="lineNum">     817</span> <span class="tlaGNC">           5 :                         changes = append(changes, change)</span></span>
<span id="L818"><span class="lineNum">     818</span> <span class="tlaGNC">           5 :                 }</span></span>
<span id="L819"><span class="lineNum">     819</span>              :         }</span>
<span id="L820"><span class="lineNum">     820</span> <span class="tlaGNC">          21 :         return changes</span></span>
<span id="L821"><span class="lineNum">     821</span>              : }</span>
<span id="L822"><span class="lineNum">     822</span>              : </span>
<span id="L823"><span class="lineNum">     823</span> <span class="tlaGNC">          27 : func (ss *storeState) computeMaxFractionPending() {</span></span>
<span id="L824"><span class="lineNum">     824</span> <span class="tlaGNC">          27 :         ss.maxFractionPendingIncrease, ss.maxFractionPendingDecrease = computeMaxFractionPendingIncDec(ss.reportedLoad, ss.adjusted.load)</span></span>
<span id="L825"><span class="lineNum">     825</span> <span class="tlaGNC">          27 : }</span></span>
<span id="L826"><span class="lineNum">     826</span>              : </span>
<span id="L827"><span class="lineNum">     827</span> <span class="tlaGNC">          39 : func computeMaxFractionPendingIncDec(rep, adj LoadVector) (maxFracInc, maxFracDec float64) {</span></span>
<span id="L828"><span class="lineNum">     828</span> <span class="tlaGNC">         117 :         for i := range rep {</span></span>
<span id="L829"><span class="lineNum">     829</span> <span class="tlaGNC">         117 :                 inc, dec := func(rep, adj LoadValue) (inc, dec float64) {</span></span>
<span id="L830"><span class="lineNum">     830</span> <span class="tlaGNC">         117 :                         // The fraction pending expresses the absolute difference of the adjusted</span></span>
<span id="L831"><span class="lineNum">     831</span> <span class="tlaGNC">         117 :                         // and reported load as a multiple of the reported load. Note that this</span></span>
<span id="L832"><span class="lineNum">     832</span> <span class="tlaGNC">         117 :                         // is the case even if the adjusted load is negative: if, say, the adjusted</span></span>
<span id="L833"><span class="lineNum">     833</span> <span class="tlaGNC">         117 :                         // load is -50 and the reported load is 100, it is still correct to say that</span></span>
<span id="L834"><span class="lineNum">     834</span> <span class="tlaGNC">         117 :                         // a &quot;magnitude 1.5x&quot; change is pending (from 100 to -50).</span></span>
<span id="L835"><span class="lineNum">     835</span> <span class="tlaGNC">         117 :                         diff := adj - rep</span></span>
<span id="L836"><span class="lineNum">     836</span> <span class="tlaGNC">         117 : </span></span>
<span id="L837"><span class="lineNum">     837</span> <span class="tlaGNC">         117 :                         switch {</span></span>
<span id="L838"><span class="lineNum">     838</span> <span class="tlaGNC">          38 :                         case diff == 0:</span></span>
<span id="L839"><span class="lineNum">     839</span> <span class="tlaGNC">          38 :                                 // Reported and adjusted are equal, so nothing is pending.</span></span>
<span id="L840"><span class="lineNum">     840</span> <span class="tlaGNC">          38 :                                 // This also handles the case in which both are zero.</span></span>
<span id="L841"><span class="lineNum">     841</span> <span class="tlaGNC">          38 :                                 // We don't need to update maxFracInc or maxFracDec because</span></span>
<span id="L842"><span class="lineNum">     842</span> <span class="tlaGNC">          38 :                                 // they started at zero and only go up from there.</span></span>
<span id="L843"><span class="lineNum">     843</span> <span class="tlaGNC">          38 :                                 return 0, 0</span></span>
<span id="L844"><span class="lineNum">     844</span> <span class="tlaGNC">          28 :                         case rep == 0:</span></span>
<span id="L845"><span class="lineNum">     845</span> <span class="tlaGNC">          28 :                                 // The adjusted load is nonzero, but the reported one is zero. We can't</span></span>
<span id="L846"><span class="lineNum">     846</span> <span class="tlaGNC">          28 :                                 // express the load change as a multiple of zero. Arbitrarily assign large</span></span>
<span id="L847"><span class="lineNum">     847</span> <span class="tlaGNC">          28 :                                 // value to both increase and decrease, indicating that no more changes</span></span>
<span id="L848"><span class="lineNum">     848</span> <span class="tlaGNC">          28 :                                 // should be made until either the pending change clears (and we get a</span></span>
<span id="L849"><span class="lineNum">     849</span> <span class="tlaGNC">          28 :                                 // zero diff above) or we register positive reported load.</span></span>
<span id="L850"><span class="lineNum">     850</span> <span class="tlaGNC">          28 :                                 return 1000, 1000</span></span>
<span id="L851"><span class="lineNum">     851</span> <span class="tlaGNC">          21 :                         case diff &gt; 0:</span></span>
<span id="L852"><span class="lineNum">     852</span> <span class="tlaGNC">          21 :                                 // Vanilla case of adjusted &gt; reported, i.e. we have load incoming.</span></span>
<span id="L853"><span class="lineNum">     853</span> <span class="tlaGNC">          21 :                                 // We don't need to update maxFracDec.</span></span>
<span id="L854"><span class="lineNum">     854</span> <span class="tlaGNC">          21 :                                 return math.Abs(float64(diff) / float64(rep)), 0</span></span>
<span id="L855"><span class="lineNum">     855</span> <span class="tlaGNC">          30 :                         case diff &lt; 0:</span></span>
<span id="L856"><span class="lineNum">     856</span> <span class="tlaGNC">          30 :                                 // Vanilla case of adjusted &lt; reported, i.e. we have load incoming.</span></span>
<span id="L857"><span class="lineNum">     857</span> <span class="tlaGNC">          30 :                                 // We don't need to update maxFracInc.</span></span>
<span id="L858"><span class="lineNum">     858</span> <span class="tlaGNC">          30 :                                 return 0, math.Abs(float64(diff) / float64(rep))</span></span>
<span id="L859"><span class="lineNum">     859</span> <span class="tlaUNC">           0 :                         default:</span></span>
<span id="L860"><span class="lineNum">     860</span> <span class="tlaUNC">           0 :                                 panic(&quot;impossible&quot;)</span></span>
<span id="L861"><span class="lineNum">     861</span>              :                         }</span>
<span id="L862"><span class="lineNum">     862</span>              :                 }(rep[i], adj[i])</span>
<span id="L863"><span class="lineNum">     863</span> <span class="tlaGNC">         117 :                 maxFracInc = max(maxFracInc, inc)</span></span>
<span id="L864"><span class="lineNum">     864</span> <span class="tlaGNC">         117 :                 maxFracDec = max(maxFracDec, dec)</span></span>
<span id="L865"><span class="lineNum">     865</span>              :         }</span>
<span id="L866"><span class="lineNum">     866</span> <span class="tlaGNC">          39 :         return maxFracInc, maxFracDec</span></span>
<span id="L867"><span class="lineNum">     867</span>              : }</span>
<span id="L868"><span class="lineNum">     868</span>              : </span>
<span id="L869"><span class="lineNum">     869</span> <span class="tlaGNC">          20 : func newStoreState() *storeState {</span></span>
<span id="L870"><span class="lineNum">     870</span> <span class="tlaGNC">          20 :         ss := &amp;storeState{}</span></span>
<span id="L871"><span class="lineNum">     871</span> <span class="tlaGNC">          20 :         ss.adjusted.loadPendingChanges = map[changeID]*pendingReplicaChange{}</span></span>
<span id="L872"><span class="lineNum">     872</span> <span class="tlaGNC">          20 :         ss.adjusted.replicas = map[roachpb.RangeID]ReplicaState{}</span></span>
<span id="L873"><span class="lineNum">     873</span> <span class="tlaGNC">          20 :         ss.adjusted.topKRanges = map[roachpb.StoreID]*topKReplicas{}</span></span>
<span id="L874"><span class="lineNum">     874</span> <span class="tlaGNC">          20 :         return ss</span></span>
<span id="L875"><span class="lineNum">     875</span> <span class="tlaGNC">          20 : }</span></span>
<span id="L876"><span class="lineNum">     876</span>              : </span>
<span id="L877"><span class="lineNum">     877</span>              : type nodeState struct {</span>
<span id="L878"><span class="lineNum">     878</span>              :         stores []roachpb.StoreID</span>
<span id="L879"><span class="lineNum">     879</span>              :         NodeLoad</span>
<span id="L880"><span class="lineNum">     880</span>              :         // NB: adjustedCPU can be negative.</span>
<span id="L881"><span class="lineNum">     881</span>              :         adjustedCPU LoadValue</span>
<span id="L882"><span class="lineNum">     882</span>              : }</span>
<span id="L883"><span class="lineNum">     883</span>              : </span>
<span id="L884"><span class="lineNum">     884</span> <span class="tlaGNC">          18 : func newNodeState(nodeID roachpb.NodeID) *nodeState {</span></span>
<span id="L885"><span class="lineNum">     885</span> <span class="tlaGNC">          18 :         return &amp;nodeState{</span></span>
<span id="L886"><span class="lineNum">     886</span> <span class="tlaGNC">          18 :                 stores: []roachpb.StoreID{},</span></span>
<span id="L887"><span class="lineNum">     887</span> <span class="tlaGNC">          18 :                 NodeLoad: NodeLoad{</span></span>
<span id="L888"><span class="lineNum">     888</span> <span class="tlaGNC">          18 :                         NodeID: nodeID,</span></span>
<span id="L889"><span class="lineNum">     889</span> <span class="tlaGNC">          18 :                 },</span></span>
<span id="L890"><span class="lineNum">     890</span> <span class="tlaGNC">          18 :         }</span></span>
<span id="L891"><span class="lineNum">     891</span> <span class="tlaGNC">          18 : }</span></span>
<span id="L892"><span class="lineNum">     892</span>              : </span>
<span id="L893"><span class="lineNum">     893</span>              : type StoreIDAndReplicaState struct {</span>
<span id="L894"><span class="lineNum">     894</span>              :         roachpb.StoreID</span>
<span id="L895"><span class="lineNum">     895</span>              :         // Only valid ReplicaTypes are used here.</span>
<span id="L896"><span class="lineNum">     896</span>              :         ReplicaState</span>
<span id="L897"><span class="lineNum">     897</span>              : }</span>
<span id="L898"><span class="lineNum">     898</span>              : </span>
<span id="L899"><span class="lineNum">     899</span> <span class="tlaUNC">           0 : func (s StoreIDAndReplicaState) String() string {</span></span>
<span id="L900"><span class="lineNum">     900</span> <span class="tlaUNC">           0 :         return redact.StringWithoutMarkers(s)</span></span>
<span id="L901"><span class="lineNum">     901</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L902"><span class="lineNum">     902</span>              : </span>
<span id="L903"><span class="lineNum">     903</span>              : // SafeFormat implements the redact.SafeFormatter interface.</span>
<span id="L904"><span class="lineNum">     904</span> <span class="tlaUNC">           0 : func (s StoreIDAndReplicaState) SafeFormat(w redact.SafePrinter, _ rune) {</span></span>
<span id="L905"><span class="lineNum">     905</span> <span class="tlaUNC">           0 :         w.Printf(&quot;s%v:%v lease disposition:%v&quot;, s.StoreID, s.ReplicaState.ReplicaIDAndType, s.ReplicaState.LeaseDisposition)</span></span>
<span id="L906"><span class="lineNum">     906</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L907"><span class="lineNum">     907</span>              : </span>
<span id="L908"><span class="lineNum">     908</span>              : // rangeState is periodically updated based on reporting by the leaseholder.</span>
<span id="L909"><span class="lineNum">     909</span>              : type rangeState struct {</span>
<span id="L910"><span class="lineNum">     910</span>              :         // localRangeOwner is used for rangeState GC. The StoreID mentioned here is</span>
<span id="L911"><span class="lineNum">     911</span>              :         // the local store that last included that range in its StoreLeaseholderMsg,</span>
<span id="L912"><span class="lineNum">     912</span>              :         // and therefore is considered the &quot;owner&quot; of the rangeState.</span>
<span id="L913"><span class="lineNum">     913</span>              :         //</span>
<span id="L914"><span class="lineNum">     914</span>              :         // NB: we can't use the current leaseholder to decide when to GC, since when</span>
<span id="L915"><span class="lineNum">     915</span>              :         // the lease is being transferred from local store s1 to remote store s3,</span>
<span id="L916"><span class="lineNum">     916</span>              :         // the rangeState will already state s3 as the leaseholder (either because</span>
<span id="L917"><span class="lineNum">     917</span>              :         // the lease transfer was considered successful, or when it is pending).</span>
<span id="L918"><span class="lineNum">     918</span>              :         //</span>
<span id="L919"><span class="lineNum">     919</span>              :         // When transferring a replica (and lease) from local store s1 to local</span>
<span id="L920"><span class="lineNum">     920</span>              :         // store s2, the localRangeOwner will initially be s1. If a</span>
<span id="L921"><span class="lineNum">     921</span>              :         // StoreLeaseholderMsg from s2 arrives with the range before the</span>
<span id="L922"><span class="lineNum">     922</span>              :         // StoreLeaseholderMsg from s1 without the range, the localRangeOwner will</span>
<span id="L923"><span class="lineNum">     923</span>              :         // be updated to s2. If the reverse ordering happens, the rangeState will be</span>
<span id="L924"><span class="lineNum">     924</span>              :         // garbage collected, and later the StoreLeaseholderMsg from s2 will</span>
<span id="L925"><span class="lineNum">     925</span>              :         // recreate it.</span>
<span id="L926"><span class="lineNum">     926</span>              :         localRangeOwner roachpb.StoreID</span>
<span id="L927"><span class="lineNum">     927</span>              :         // replicas is the adjusted replicas after applying pendingChanges. It is</span>
<span id="L928"><span class="lineNum">     928</span>              :         // always consistent with the storeState.adjusted.replicas in the</span>
<span id="L929"><span class="lineNum">     929</span>              :         // corresponding stores.</span>
<span id="L930"><span class="lineNum">     930</span>              :         //</span>
<span id="L931"><span class="lineNum">     931</span>              :         // INVARIANT: There must be exactly one replica marked as the leaseholder in</span>
<span id="L932"><span class="lineNum">     932</span>              :         // this slice. Additionally, the leaseholder replica in the slice may not be</span>
<span id="L933"><span class="lineNum">     933</span>              :         // a local store when there are pending changes that transfer the lease</span>
<span id="L934"><span class="lineNum">     934</span>              :         // away, since replicas contains the final state after applying pending</span>
<span id="L935"><span class="lineNum">     935</span>              :         // changes (we continue to track the rangeState in clusterState.ranges until</span>
<span id="L936"><span class="lineNum">     936</span>              :         // it is wiped out by a StoreLeaseholderMsg from the current localRangeOwner</span>
<span id="L937"><span class="lineNum">     937</span>              :         // that no longer mentions the range (we've discussed this above).</span>
<span id="L938"><span class="lineNum">     938</span>              :         //</span>
<span id="L939"><span class="lineNum">     939</span>              :         // A Note about Pending Changes:</span>
<span id="L940"><span class="lineNum">     940</span>              :         //</span>
<span id="L941"><span class="lineNum">     941</span>              :         // 1. Overview</span>
<span id="L942"><span class="lineNum">     942</span>              :         //</span>
<span id="L943"><span class="lineNum">     943</span>              :         // One should think of pendingChanges as a transient override of the</span>
<span id="L944"><span class="lineNum">     944</span>              :         // authoritative state provided by the leaseholder in a RangeMsg.Replicas</span>
<span id="L945"><span class="lineNum">     945</span>              :         // (i.e., eventually, RangeMsg.Replicas wins). The allocator wants to track</span>
<span id="L946"><span class="lineNum">     946</span>              :         // the effect of the ongoing changes, to prevent itself from making more</span>
<span id="L947"><span class="lineNum">     947</span>              :         // changes that overshoot a goal, which is why these changes are</span>
<span id="L948"><span class="lineNum">     948</span>              :         // incorporated into replicas (and storeState.adjusted.load etc.). It also</span>
<span id="L949"><span class="lineNum">     949</span>              :         // wants to know exactly what is pending, so when it sees RangeMsg.Replicas</span>
<span id="L950"><span class="lineNum">     950</span>              :         // that are still at the initial state, or an intermediate state, it can</span>
<span id="L951"><span class="lineNum">     951</span>              :         // continue anticipating that these pending changes will happen. Tracking</span>
<span id="L952"><span class="lineNum">     952</span>              :         // what is pending also allows for undo in the case of explicit failure,</span>
<span id="L953"><span class="lineNum">     953</span>              :         // notified by AdjustPendingChangesDisposition.</span>
<span id="L954"><span class="lineNum">     954</span>              :         //</span>
<span id="L955"><span class="lineNum">     955</span>              :         // 2. Lifecycle</span>
<span id="L956"><span class="lineNum">     956</span>              :         // pendingChanges track proposed modifications to a range's replicas or</span>
<span id="L957"><span class="lineNum">     957</span>              :         // leaseholder that are not yet reflected in the leaseholder's authoritative</span>
<span id="L958"><span class="lineNum">     958</span>              :         // state. They are created by three sources: range rebalances, lease transfers</span>
<span id="L959"><span class="lineNum">     959</span>              :         // originating from MMA, or external changes via RegisterExternalChanges</span>
<span id="L960"><span class="lineNum">     960</span>              :         // (replicate or lease queue). There exists a pending change in a range state</span>
<span id="L961"><span class="lineNum">     961</span>              :         // iff there is also a corresponding one in clusterState's pendingChanges.</span>
<span id="L962"><span class="lineNum">     962</span>              :         //</span>
<span id="L963"><span class="lineNum">     963</span>              :         // A pending change is removed from tracking in one of three ways:</span>
<span id="L964"><span class="lineNum">     964</span>              :         // 1. Marked as enacted successfully: remove the pending changes. The adjusted</span>
<span id="L965"><span class="lineNum">     965</span>              :         // load remains until processStoreLoadMsg determines the change is reflected</span>
<span id="L966"><span class="lineNum">     966</span>              :         // in the latest store load message, based on whether</span>
<span id="L967"><span class="lineNum">     967</span>              :         // lagForChangeReflectedInLoad has elapsed since enactment.</span>
<span id="L968"><span class="lineNum">     968</span>              :         //</span>
<span id="L969"><span class="lineNum">     969</span>              :         // This happens when:</span>
<span id="L970"><span class="lineNum">     970</span>              :         // - The pending change is successfully applied via</span>
<span id="L971"><span class="lineNum">     971</span>              :         // AdjustPendingChangesDisposition(success).</span>
<span id="L972"><span class="lineNum">     972</span>              :         // - The pending change is considered subsumed based on the leaseholder msg.</span>
<span id="L973"><span class="lineNum">     973</span>              :         // - The leaseholder of the range has changed. This is a special case where</span>
<span id="L974"><span class="lineNum">     974</span>              :         // the leaseholder of the range has moved to a different store, and the</span>
<span id="L975"><span class="lineNum">     975</span>              :         // rangeMsg no longer contains the range. We assume that the pending change</span>
<span id="L976"><span class="lineNum">     976</span>              :         // has been enacted in this case.</span>
<span id="L977"><span class="lineNum">     977</span>              :         //</span>
<span id="L978"><span class="lineNum">     978</span>              :         // 2. Undone as failed: corresponding replica and load change is rolled back.</span>
<span id="L979"><span class="lineNum">     979</span>              :         // Note that for replica changes that originate from one action, all changes</span>
<span id="L980"><span class="lineNum">     980</span>              :         // would be undone together.</span>
<span id="L981"><span class="lineNum">     981</span>              :         // NB: pending changes of a range state originate from one decision.</span>
<span id="L982"><span class="lineNum">     982</span>              :         // Therefore, when one pending change is enacted successfully, we mark this</span>
<span id="L983"><span class="lineNum">     983</span>              :         // range state's pending changes as no rollback (read more about this in 3).</span>
<span id="L984"><span class="lineNum">     984</span>              :         // If we are here trying to undo a pending change but the range state has</span>
<span id="L985"><span class="lineNum">     985</span>              :         // already been marked as no rollback, we do not undo the remaining pending</span>
<span id="L986"><span class="lineNum">     986</span>              :         // changes. Instead, we wait for a StoreLeaseholderMsg to discard the pending</span>
<span id="L987"><span class="lineNum">     987</span>              :         // changes and revert the load adjustments after the</span>
<span id="L988"><span class="lineNum">     988</span>              :         // partiallyEnactedGCDuration has elapsed since the first enacted change. The</span>
<span id="L989"><span class="lineNum">     989</span>              :         // modeling here is imperfect (read more about this in 3).</span>
<span id="L990"><span class="lineNum">     990</span>              :         //</span>
<span id="L991"><span class="lineNum">     991</span>              :         // This happens when:</span>
<span id="L992"><span class="lineNum">     992</span>              :         // - The pending change failed to apply via</span>
<span id="L993"><span class="lineNum">     993</span>              :         // AdjustPendingChangesDisposition(failed)).</span>
<span id="L994"><span class="lineNum">     994</span>              :         // - The pending change is garbage collected after this pending change has</span>
<span id="L995"><span class="lineNum">     995</span>              :         // been created for pending{Replica,Lease}ChangeGCDuration.</span>
<span id="L996"><span class="lineNum">     996</span>              :         //</span>
<span id="L997"><span class="lineNum">     997</span>              :         // 3. Dropped due to incompatibility: mma creates these pending changes while</span>
<span id="L998"><span class="lineNum">     998</span>              :         // working with an earlier authoritative leaseholder message. These changes</span>
<span id="L999"><span class="lineNum">     999</span>              :         // remain valid until a new authoritative message arrives that may reflect a</span>
<span id="L1000"><span class="lineNum">    1000</span>              :         // conflicting state. See preCheckOnApplyReplicaChanges for details on how</span>
<span id="L1001"><span class="lineNum">    1001</span>              :         // compatibility between the pending change and the new range state is</span>
<span id="L1002"><span class="lineNum">    1002</span>              :         // determined. When incompatibility is detected, the pending replica change is</span>
<span id="L1003"><span class="lineNum">    1003</span>              :         // discarded and the corresponding load adjustments are rolled back.</span>
<span id="L1004"><span class="lineNum">    1004</span>              :         //</span>
<span id="L1005"><span class="lineNum">    1005</span>              :         // This happens when:</span>
<span id="L1006"><span class="lineNum">    1006</span>              :         // - processStoreLeaseholderMsgInternal tries to apply the pending changes to</span>
<span id="L1007"><span class="lineNum">    1007</span>              :         // the received range state from the new leaseholder msg, but the pending</span>
<span id="L1008"><span class="lineNum">    1008</span>              :         // changes are incompatible with the new range state.</span>
<span id="L1009"><span class="lineNum">    1009</span>              :         //</span>
<span id="L1010"><span class="lineNum">    1010</span>              :         // 3. Modeling</span>
<span id="L1011"><span class="lineNum">    1011</span>              :         //</span>
<span id="L1012"><span class="lineNum">    1012</span>              :         // The slice of pendingChanges represent one decision. However, this</span>
<span id="L1013"><span class="lineNum">    1013</span>              :         // decision is not always executed atomically by the external system.</span>
<span id="L1014"><span class="lineNum">    1014</span>              :         //</span>
<span id="L1015"><span class="lineNum">    1015</span>              :         // The decision is modeled using at most one pendingReplicaChange per</span>
<span id="L1016"><span class="lineNum">    1016</span>              :         // replica (and store) in the pre-change rangeState.replicas. This means</span>
<span id="L1017"><span class="lineNum">    1017</span>              :         // that when we see a new RangeMsg.Replicas, and have an existing list of</span>
<span id="L1018"><span class="lineNum">    1018</span>              :         // pending changes, we can individually compare each pending change to the</span>
<span id="L1019"><span class="lineNum">    1019</span>              :         // state in RangeMsg.Replicas and decide whether it is (a) already</span>
<span id="L1020"><span class="lineNum">    1020</span>              :         // incorporated or (b) can still apply in the future or (c) is inconsistent.</span>
<span id="L1021"><span class="lineNum">    1021</span>              :         // Even complex decisions don't need to refer to a replica multiple times,</span>
<span id="L1022"><span class="lineNum">    1022</span>              :         // so this is not a problematic restriction.</span>
<span id="L1023"><span class="lineNum">    1023</span>              :         //</span>
<span id="L1024"><span class="lineNum">    1024</span>              :         // This separability per replica allows for observing intermediate states</span>
<span id="L1025"><span class="lineNum">    1025</span>              :         // representing partial application (case (a) in the previous paragraph),</span>
<span id="L1026"><span class="lineNum">    1026</span>              :         // and leaving other changes as pending. A simple example of this is a range</span>
<span id="L1027"><span class="lineNum">    1027</span>              :         // move where replicas are at stores {s1, s2, s3} and a replica is moved</span>
<span id="L1028"><span class="lineNum">    1028</span>              :         // from s3 to s4. There will be two pending changes, for addition of s4, and</span>
<span id="L1029"><span class="lineNum">    1029</span>              :         // removal of s3, and replicas field will represent the final state {s1, s2,</span>
<span id="L1030"><span class="lineNum">    1030</span>              :         // s4}. If the leaseholder (say s1) provides a RangeMsg that lists replicas</span>
<span id="L1031"><span class="lineNum">    1031</span>              :         // {s1, s2, s3, s4}, the allocator realizes that the addition of s4 is done,</span>
<span id="L1032"><span class="lineNum">    1032</span>              :         // marks it as enacted and removes it from the pendingChanges slice. Note</span>
<span id="L1033"><span class="lineNum">    1033</span>              :         // that this capability to mark some pending changes as enacted is in some</span>
<span id="L1034"><span class="lineNum">    1034</span>              :         // ways overly lenient, but we don't try to narrow this leniency: e.g. if</span>
<span id="L1035"><span class="lineNum">    1035</span>              :         // one sees {s1, s2}, one will mark the removal pending change as enacted,</span>
<span id="L1036"><span class="lineNum">    1036</span>              :         // and keep the addition pending change. But the external system does not</span>
<span id="L1037"><span class="lineNum">    1037</span>              :         // make a replica change in this manner, and there was probably some kind of</span>
<span id="L1038"><span class="lineNum">    1038</span>              :         // other event that happened (e.g. some other component made a change</span>
<span id="L1039"><span class="lineNum">    1039</span>              :         // without the allocator's knowledge), and it is likely that s4 will never</span>
<span id="L1040"><span class="lineNum">    1040</span>              :         // be added (we will GC it after partiallyEnactedGCDuration).</span>
<span id="L1041"><span class="lineNum">    1041</span>              :         //</span>
<span id="L1042"><span class="lineNum">    1042</span>              :         // The modeling of intermediate states is not perfect. Say that in the above</span>
<span id="L1043"><span class="lineNum">    1043</span>              :         // example s3 was the local leaseholder. And say that the decision is</span>
<span id="L1044"><span class="lineNum">    1044</span>              :         // removing both the leaseholder and replica from s3, and adding a replica</span>
<span id="L1045"><span class="lineNum">    1045</span>              :         // and leaseholder to s4. This will be modeled with two pending changes, one</span>
<span id="L1046"><span class="lineNum">    1046</span>              :         // that removes the replica and leaseholder from s3, and another that adds</span>
<span id="L1047"><span class="lineNum">    1047</span>              :         // the replica and leaseholder to s4. An intermediate state that can be</span>
<span id="L1048"><span class="lineNum">    1048</span>              :         // observed is {s1, s2, s3, s4} with the lease still at s3. But the pending</span>
<span id="L1049"><span class="lineNum">    1049</span>              :         // change for adding s4 includes both that it has a replica, and it has the</span>
<span id="L1050"><span class="lineNum">    1050</span>              :         // lease, so we will not mark it done, and keep pretending that the whole</span>
<span id="L1051"><span class="lineNum">    1051</span>              :         // change is pending. Since lease transfers are fast, we accept this</span>
<span id="L1052"><span class="lineNum">    1052</span>              :         // imperfect modeling fidelity. One consequence of this imperfect modeling</span>
<span id="L1053"><span class="lineNum">    1053</span>              :         // is that if in this example there are no further changes observed until</span>
<span id="L1054"><span class="lineNum">    1054</span>              :         // GC, the allocator will undo both changes and go back to the state {s1,</span>
<span id="L1055"><span class="lineNum">    1055</span>              :         // s2, s3} with s3 as the leaseholder. That is, it has forgotten that s4 was</span>
<span id="L1056"><span class="lineNum">    1056</span>              :         // added. This is unavoidable and will be fixed by the first</span>
<span id="L1057"><span class="lineNum">    1057</span>              :         // StoreLeaseholderMsg post-GC.</span>
<span id="L1058"><span class="lineNum">    1058</span>              :         //</span>
<span id="L1059"><span class="lineNum">    1059</span>              :         // 4. Non Atomicity Hazard</span>
<span id="L1060"><span class="lineNum">    1060</span>              :         //</span>
<span id="L1061"><span class="lineNum">    1061</span>              :         // Since a decision is represented with multiple pending changes, and we</span>
<span id="L1062"><span class="lineNum">    1062</span>              :         // allow for individual changes to be considered enacted or failed, we have</span>
<span id="L1063"><span class="lineNum">    1063</span>              :         // to contend with the hazard of having two leaseholders or no leaseholders.</span>
<span id="L1064"><span class="lineNum">    1064</span>              :         // In the earlier example, say s3 and s4 were both local stores (a</span>
<span id="L1065"><span class="lineNum">    1065</span>              :         // multi-store node), it may be possible to observe an intermediate state</span>
<span id="L1066"><span class="lineNum">    1066</span>              :         // {s1, s2, s3, s4} where s4 is the leaseholder. If we subsequently get a</span>
<span id="L1067"><span class="lineNum">    1067</span>              :         // spurious AdjustPendingChangesDisposition(success=false) call, or</span>
<span id="L1068"><span class="lineNum">    1068</span>              :         // time-based GC causes the s3 removal to be undone, there will be two</span>
<span id="L1069"><span class="lineNum">    1069</span>              :         // replicas marked as the leaseholder. The other extreme is believing that</span>
<span id="L1070"><span class="lineNum">    1070</span>              :         // the s3 transfer is done and the s4 incoming replica (and lease) failed</span>
<span id="L1071"><span class="lineNum">    1071</span>              :         // (this may not actually be possible because of the surrounding code).</span>
<span id="L1072"><span class="lineNum">    1072</span>              :         //</span>
<span id="L1073"><span class="lineNum">    1073</span>              :         // We deal with this hazard by observing that we've constructed multiple</span>
<span id="L1074"><span class="lineNum">    1074</span>              :         // pending changes in order to observe intermediate changes in the common</span>
<span id="L1075"><span class="lineNum">    1075</span>              :         // case of success. Once one change in the set of changes is considered</span>
<span id="L1076"><span class="lineNum">    1076</span>              :         // enacted, we mark the whole remaining group as no-rollback. In the above</span>
<span id="L1077"><span class="lineNum">    1077</span>              :         // case, if we see s4 has become the leaseholder, the s1 removal can't undo</span>
<span id="L1078"><span class="lineNum">    1078</span>              :         // itself -- it can be dropped if it is considered subsumed when processing</span>
<span id="L1079"><span class="lineNum">    1079</span>              :         // a RangeMsg, or it can be GC'd.</span>
<span id="L1080"><span class="lineNum">    1080</span>              :         //</span>
<span id="L1081"><span class="lineNum">    1081</span>              :         // Additionally, when processing a RangeMsg, if any of the pending changes</span>
<span id="L1082"><span class="lineNum">    1082</span>              :         // is considered inconsistent, all the pending changes are discarded. This</span>
<span id="L1083"><span class="lineNum">    1083</span>              :         // avoids a situation where the RangeMsg presents a state that causes the</span>
<span id="L1084"><span class="lineNum">    1084</span>              :         // addition of s4 to be thrown away while keeping the removal of s1. This is</span>
<span id="L1085"><span class="lineNum">    1085</span>              :         // mostly being defensive to avoid any chance of internal inconsistency.</span>
<span id="L1086"><span class="lineNum">    1086</span>              :         replicas []StoreIDAndReplicaState</span>
<span id="L1087"><span class="lineNum">    1087</span>              :         conf     *normalizedSpanConfig</span>
<span id="L1088"><span class="lineNum">    1088</span>              : </span>
<span id="L1089"><span class="lineNum">    1089</span>              :         load RangeLoad</span>
<span id="L1090"><span class="lineNum">    1090</span>              : </span>
<span id="L1091"><span class="lineNum">    1091</span>              :         // The pending changes to this range, that are already reflected in</span>
<span id="L1092"><span class="lineNum">    1092</span>              :         // replicas. There is at most one change per store in this slice (same</span>
<span id="L1093"><span class="lineNum">    1093</span>              :         // invariant as PendingRangeChange).</span>
<span id="L1094"><span class="lineNum">    1094</span>              :         //</span>
<span id="L1095"><span class="lineNum">    1095</span>              :         // Life-cycle matches clusterState.pendingChanges. The consolidated</span>
<span id="L1096"><span class="lineNum">    1096</span>              :         // rangeState.pendingChanges across all ranges in clusterState.ranges will</span>
<span id="L1097"><span class="lineNum">    1097</span>              :         // be identical to clusterState.pendingChanges.</span>
<span id="L1098"><span class="lineNum">    1098</span>              :         pendingChanges []*pendingReplicaChange</span>
<span id="L1099"><span class="lineNum">    1099</span>              :         // When set, the pendingChanges can not be rolled back anymore. They have</span>
<span id="L1100"><span class="lineNum">    1100</span>              :         // to be enacted, or discarded wholesale in favor of the latest RangeMsg</span>
<span id="L1101"><span class="lineNum">    1101</span>              :         // from the leaseholder. It is reset to false when pendingChanges</span>
<span id="L1102"><span class="lineNum">    1102</span>              :         // transitions from empty to non-empty.</span>
<span id="L1103"><span class="lineNum">    1103</span>              :         pendingChangeNoRollback bool</span>
<span id="L1104"><span class="lineNum">    1104</span>              : </span>
<span id="L1105"><span class="lineNum">    1105</span>              :         // If non-nil, it is up-to-date. Typically, non-nil for a range that has no</span>
<span id="L1106"><span class="lineNum">    1106</span>              :         // pendingChanges and is not satisfying some constraint, since we don't want</span>
<span id="L1107"><span class="lineNum">    1107</span>              :         // to repeat the analysis work every time we consider it.</span>
<span id="L1108"><span class="lineNum">    1108</span>              :         //</span>
<span id="L1109"><span class="lineNum">    1109</span>              :         // REMINDER: rangeAnalyzedConstraints ignores LEARNER and</span>
<span id="L1110"><span class="lineNum">    1110</span>              :         // VOTER_DEMOTING_LEARNER replicas. So if a voter/non-voter is being added</span>
<span id="L1111"><span class="lineNum">    1111</span>              :         // and is currently a LEARNER, calling one of the methods on</span>
<span id="L1112"><span class="lineNum">    1112</span>              :         // rangeAnalyzedConstraints that tells us about an unsatisfied constraint</span>
<span id="L1113"><span class="lineNum">    1113</span>              :         // can give us something that is already pending. Our expectation is that</span>
<span id="L1114"><span class="lineNum">    1114</span>              :         // the pending changes will be reflected in pendingChanges. Then it becomes</span>
<span id="L1115"><span class="lineNum">    1115</span>              :         // the responsibility of a higher layer (allocator) to notice that the</span>
<span id="L1116"><span class="lineNum">    1116</span>              :         // rangeState has pendingChanges, and not make any more changes.</span>
<span id="L1117"><span class="lineNum">    1117</span>              :         constraints *rangeAnalyzedConstraints</span>
<span id="L1118"><span class="lineNum">    1118</span>              : </span>
<span id="L1119"><span class="lineNum">    1119</span>              :         // lastFailedChange is the latest time at which a change to the range needed</span>
<span id="L1120"><span class="lineNum">    1120</span>              :         // to be undone. It is used to backoff from making another change.</span>
<span id="L1121"><span class="lineNum">    1121</span>              :         //</span>
<span id="L1122"><span class="lineNum">    1122</span>              :         // One case where this is useful is when the rangeState does not know about</span>
<span id="L1123"><span class="lineNum">    1123</span>              :         // an ongoing change started by some other component. In that case, mmaprototype can</span>
<span id="L1124"><span class="lineNum">    1124</span>              :         // produce another change, which the callee is unable to enact because there</span>
<span id="L1125"><span class="lineNum">    1125</span>              :         // is an ongoing change. We will record that failure time here, and wait for</span>
<span id="L1126"><span class="lineNum">    1126</span>              :         // some time interval before trying again. During that time, it is likely</span>
<span id="L1127"><span class="lineNum">    1127</span>              :         // that the change we did not know about has been enacted.</span>
<span id="L1128"><span class="lineNum">    1128</span>              :         //</span>
<span id="L1129"><span class="lineNum">    1129</span>              :         // One may wonder how such unknown changes can happen, given that other</span>
<span id="L1130"><span class="lineNum">    1130</span>              :         // components call mmaprototype.Allocator.RegisterExternalChange. One example is</span>
<span id="L1131"><span class="lineNum">    1131</span>              :         // when MMA does not currently know about a range. Say the lease gets</span>
<span id="L1132"><span class="lineNum">    1132</span>              :         // transferred to the local store, but MMA has not yet been called with a</span>
<span id="L1133"><span class="lineNum">    1133</span>              :         // StoreLeaseholderMsg, but replicateQueue already knows about this lease,</span>
<span id="L1134"><span class="lineNum">    1134</span>              :         // and decides to initiate a transfer of replicas between two remote stores</span>
<span id="L1135"><span class="lineNum">    1135</span>              :         // (to equalize replica counts). When mmaprototype.Allocator.RegisterExternalChange</span>
<span id="L1136"><span class="lineNum">    1136</span>              :         // is called, there is no record of this range in MMA (since it wasn't the</span>
<span id="L1137"><span class="lineNum">    1137</span>              :         // leaseholder), and the change is ignored. When the next</span>
<span id="L1138"><span class="lineNum">    1138</span>              :         // StoreLeaseholderMsg is provided to MMA it now knows about the range, and</span>
<span id="L1139"><span class="lineNum">    1139</span>              :         // when asked to do rebalancing, it may choose to initiate a change to the</span>
<span id="L1140"><span class="lineNum">    1140</span>              :         // range, while the other unknown change is ongoing. This scenario occurred</span>
<span id="L1141"><span class="lineNum">    1141</span>              :         // in an asim test, which timed out (the timeout happened because asim does</span>
<span id="L1142"><span class="lineNum">    1142</span>              :         // not advance time if a change is immediately invalid, and which can result</span>
<span id="L1143"><span class="lineNum">    1143</span>              :         // in the mmaprototype store rebalancer being stuck in a tight loop with the</span>
<span id="L1144"><span class="lineNum">    1144</span>              :         // simulation time not advancing).</span>
<span id="L1145"><span class="lineNum">    1145</span>              :         lastFailedChange time.Time</span>
<span id="L1146"><span class="lineNum">    1146</span>              :         // TODO(sumeer): populate and use.</span>
<span id="L1147"><span class="lineNum">    1147</span>              :         diversityIncreaseLastFailedAttempt time.Time</span>
<span id="L1148"><span class="lineNum">    1148</span>              : }</span>
<span id="L1149"><span class="lineNum">    1149</span>              : </span>
<span id="L1150"><span class="lineNum">    1150</span> <span class="tlaGNC">          11 : func newRangeState(localRangeOwner roachpb.StoreID) *rangeState {</span></span>
<span id="L1151"><span class="lineNum">    1151</span> <span class="tlaGNC">          11 :         return &amp;rangeState{</span></span>
<span id="L1152"><span class="lineNum">    1152</span> <span class="tlaGNC">          11 :                 replicas:        []StoreIDAndReplicaState{},</span></span>
<span id="L1153"><span class="lineNum">    1153</span> <span class="tlaGNC">          11 :                 pendingChanges:  []*pendingReplicaChange{},</span></span>
<span id="L1154"><span class="lineNum">    1154</span> <span class="tlaGNC">          11 :                 localRangeOwner: localRangeOwner,</span></span>
<span id="L1155"><span class="lineNum">    1155</span> <span class="tlaGNC">          11 :         }</span></span>
<span id="L1156"><span class="lineNum">    1156</span> <span class="tlaGNC">          11 : }</span></span>
<span id="L1157"><span class="lineNum">    1157</span>              : </span>
<span id="L1158"><span class="lineNum">    1158</span> <span class="tlaGNC">          20 : func (rs *rangeState) setReplica(repl StoreIDAndReplicaState) {</span></span>
<span id="L1159"><span class="lineNum">    1159</span> <span class="tlaGNC">          29 :         for i := range rs.replicas {</span></span>
<span id="L1160"><span class="lineNum">    1160</span> <span class="tlaGNC">          29 :                 if rs.replicas[i].StoreID == repl.StoreID {</span></span>
<span id="L1161"><span class="lineNum">    1161</span> <span class="tlaGNC">          12 :                         rs.replicas[i].ReplicaState = repl.ReplicaState</span></span>
<span id="L1162"><span class="lineNum">    1162</span> <span class="tlaGNC">          12 :                         return</span></span>
<span id="L1163"><span class="lineNum">    1163</span> <span class="tlaGNC">          12 :                 }</span></span>
<span id="L1164"><span class="lineNum">    1164</span>              :         }</span>
<span id="L1165"><span class="lineNum">    1165</span> <span class="tlaGNC">           8 :         rs.replicas = append(rs.replicas, repl)</span></span>
<span id="L1166"><span class="lineNum">    1166</span>              : }</span>
<span id="L1167"><span class="lineNum">    1167</span>              : </span>
<span id="L1168"><span class="lineNum">    1168</span> <span class="tlaGNC">          19 : func (rs *rangeState) removeReplica(storeID roachpb.StoreID) error {</span></span>
<span id="L1169"><span class="lineNum">    1169</span> <span class="tlaGNC">          19 :         var i, n int</span></span>
<span id="L1170"><span class="lineNum">    1170</span> <span class="tlaGNC">          19 :         n = len(rs.replicas)</span></span>
<span id="L1171"><span class="lineNum">    1171</span> <span class="tlaGNC">          23 :         for ; i &lt; n; i++ {</span></span>
<span id="L1172"><span class="lineNum">    1172</span> <span class="tlaGNC">          23 :                 if rs.replicas[i].StoreID == storeID {</span></span>
<span id="L1173"><span class="lineNum">    1173</span> <span class="tlaGNC">          19 :                         rs.replicas[i], rs.replicas[n-1] = rs.replicas[n-1], rs.replicas[i]</span></span>
<span id="L1174"><span class="lineNum">    1174</span> <span class="tlaGNC">          19 :                         rs.replicas = rs.replicas[:n-1]</span></span>
<span id="L1175"><span class="lineNum">    1175</span> <span class="tlaGNC">          19 :                         return nil</span></span>
<span id="L1176"><span class="lineNum">    1176</span> <span class="tlaGNC">          19 :                 }</span></span>
<span id="L1177"><span class="lineNum">    1177</span>              :         }</span>
<span id="L1178"><span class="lineNum">    1178</span> <span class="tlaUNC">           0 :         return errors.Errorf(&quot;store %v has no replica&quot;, storeID)</span></span>
<span id="L1179"><span class="lineNum">    1179</span>              : }</span>
<span id="L1180"><span class="lineNum">    1180</span>              : </span>
<span id="L1181"><span class="lineNum">    1181</span> <span class="tlaGNC">           7 : func replicaSetIsValid(replicas []StoreIDAndReplicaState) error {</span></span>
<span id="L1182"><span class="lineNum">    1182</span> <span class="tlaGNC">           7 :         hasSeenLeaseholder := false</span></span>
<span id="L1183"><span class="lineNum">    1183</span> <span class="tlaGNC">          12 :         for _, repl := range replicas {</span></span>
<span id="L1184"><span class="lineNum">    1184</span> <span class="tlaGNC">          12 :                 if repl.ReplicaState.IsLeaseholder {</span></span>
<span id="L1185"><span class="lineNum">    1185</span> <span class="tlaGNC">           7 :                         if hasSeenLeaseholder {</span></span>
<span id="L1186"><span class="lineNum">    1186</span> <span class="tlaUNC">           0 :                                 // More than one leaseholder.</span></span>
<span id="L1187"><span class="lineNum">    1187</span> <span class="tlaUNC">           0 :                                 return errors.Errorf(&quot;more than one leaseholder&quot;)</span></span>
<span id="L1188"><span class="lineNum">    1188</span> <span class="tlaUNC">           0 :                         }</span></span>
<span id="L1189"><span class="lineNum">    1189</span> <span class="tlaGNC">           7 :                         hasSeenLeaseholder = true</span></span>
<span id="L1190"><span class="lineNum">    1190</span>              :                 }</span>
<span id="L1191"><span class="lineNum">    1191</span>              :         }</span>
<span id="L1192"><span class="lineNum">    1192</span> <span class="tlaGNC">           7 :         if hasSeenLeaseholder {</span></span>
<span id="L1193"><span class="lineNum">    1193</span> <span class="tlaGNC">           7 :                 return nil</span></span>
<span id="L1194"><span class="lineNum">    1194</span> <span class="tlaGNC">           7 :         }</span></span>
<span id="L1195"><span class="lineNum">    1195</span> <span class="tlaUNC">           0 :         return errors.Errorf(&quot;no leaseholder&quot;)</span></span>
<span id="L1196"><span class="lineNum">    1196</span>              : }</span>
<span id="L1197"><span class="lineNum">    1197</span>              : </span>
<span id="L1198"><span class="lineNum">    1198</span> <span class="tlaGNC">          15 : func (rs *rangeState) removePendingChangeTracking(changeID changeID) {</span></span>
<span id="L1199"><span class="lineNum">    1199</span> <span class="tlaGNC">          15 :         n := len(rs.pendingChanges)</span></span>
<span id="L1200"><span class="lineNum">    1200</span> <span class="tlaGNC">          15 :         found := false</span></span>
<span id="L1201"><span class="lineNum">    1201</span> <span class="tlaGNC">          15 :         for i := 0; i &lt; n; i++ {</span></span>
<span id="L1202"><span class="lineNum">    1202</span> <span class="tlaGNC">          15 :                 if rs.pendingChanges[i].changeID == changeID {</span></span>
<span id="L1203"><span class="lineNum">    1203</span> <span class="tlaGNC">          15 :                         rs.pendingChanges[i], rs.pendingChanges[n-1] = rs.pendingChanges[n-1], rs.pendingChanges[i]</span></span>
<span id="L1204"><span class="lineNum">    1204</span> <span class="tlaGNC">          15 :                         rs.pendingChanges = rs.pendingChanges[:n-1]</span></span>
<span id="L1205"><span class="lineNum">    1205</span> <span class="tlaGNC">          15 :                         found = true</span></span>
<span id="L1206"><span class="lineNum">    1206</span> <span class="tlaGNC">          15 :                         break</span></span>
<span id="L1207"><span class="lineNum">    1207</span>              :                 }</span>
<span id="L1208"><span class="lineNum">    1208</span>              :         }</span>
<span id="L1209"><span class="lineNum">    1209</span> <span class="tlaGNC">          15 :         if !found {</span></span>
<span id="L1210"><span class="lineNum">    1210</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(&quot;pending change %v not found in rangeState %v&quot;, changeID, rs.pendingChanges))</span></span>
<span id="L1211"><span class="lineNum">    1211</span>              :         }</span>
<span id="L1212"><span class="lineNum">    1212</span>              : }</span>
<span id="L1213"><span class="lineNum">    1213</span>              : </span>
<span id="L1214"><span class="lineNum">    1214</span>              : // clearAnalyzedConstraints clears the analyzed constraints for the range state.</span>
<span id="L1215"><span class="lineNum">    1215</span>              : // This should be used when rs is deleted or rs.constraints needs to be reset.</span>
<span id="L1216"><span class="lineNum">    1216</span> <span class="tlaGNC">          30 : func (rs *rangeState) clearAnalyzedConstraints() {</span></span>
<span id="L1217"><span class="lineNum">    1217</span> <span class="tlaGNC">          30 :         if rs.constraints == nil {</span></span>
<span id="L1218"><span class="lineNum">    1218</span> <span class="tlaGNC">          30 :                 return</span></span>
<span id="L1219"><span class="lineNum">    1219</span> <span class="tlaGNC">          30 :         }</span></span>
<span id="L1220"><span class="lineNum">    1220</span> <span class="tlaUNC">           0 :         releaseRangeAnalyzedConstraints(rs.constraints)</span></span>
<span id="L1221"><span class="lineNum">    1221</span> <span class="tlaUNC">           0 :         rs.constraints = nil</span></span>
<span id="L1222"><span class="lineNum">    1222</span>              : }</span>
<span id="L1223"><span class="lineNum">    1223</span>              : </span>
<span id="L1224"><span class="lineNum">    1224</span>              : // clusterState is the state of the cluster known to the allocator, including</span>
<span id="L1225"><span class="lineNum">    1225</span>              : // adjustments based on pending changes. It does not include additional</span>
<span id="L1226"><span class="lineNum">    1226</span>              : // indexing needed for constraint matching, or for tracking ranges that may</span>
<span id="L1227"><span class="lineNum">    1227</span>              : // need attention etc. (those happen at a higher layer).</span>
<span id="L1228"><span class="lineNum">    1228</span>              : //</span>
<span id="L1229"><span class="lineNum">    1229</span>              : // We maintain one clusterState per node, even in multi-store settings. This</span>
<span id="L1230"><span class="lineNum">    1230</span>              : // allows us to allow for coordination between the different local store</span>
<span id="L1231"><span class="lineNum">    1231</span>              : // rebalancers, and queues making changes. There are production clusters where</span>
<span id="L1232"><span class="lineNum">    1232</span>              : // the number of stores is an order of magnitude larger than the number of</span>
<span id="L1233"><span class="lineNum">    1233</span>              : // nodes, and even though we have rebalancing components per store, we want to</span>
<span id="L1234"><span class="lineNum">    1234</span>              : // reduce the sub-optimal decisions they make -- having a single clusterState</span>
<span id="L1235"><span class="lineNum">    1235</span>              : // is important for that.</span>
<span id="L1236"><span class="lineNum">    1236</span>              : //</span>
<span id="L1237"><span class="lineNum">    1237</span>              : // REQUIREMENT(change-computation): Any request to compute a change</span>
<span id="L1238"><span class="lineNum">    1238</span>              : // (rebalancing stores, or a change specifically for a range), must be atomic</span>
<span id="L1239"><span class="lineNum">    1239</span>              : // with the leaseholder providing the current authoritative state for all its</span>
<span id="L1240"><span class="lineNum">    1240</span>              : // ranges (for rebalancing) or for the specific range (for a range-specific</span>
<span id="L1241"><span class="lineNum">    1241</span>              : // change).</span>
<span id="L1242"><span class="lineNum">    1242</span>              : type clusterState struct {</span>
<span id="L1243"><span class="lineNum">    1243</span>              :         ts     timeutil.TimeSource</span>
<span id="L1244"><span class="lineNum">    1244</span>              :         nodes  map[roachpb.NodeID]*nodeState</span>
<span id="L1245"><span class="lineNum">    1245</span>              :         stores map[roachpb.StoreID]*storeState</span>
<span id="L1246"><span class="lineNum">    1246</span>              :         // A range is present in the ranges map if any of the local stores is the</span>
<span id="L1247"><span class="lineNum">    1247</span>              :         // leaseholder for that range according to the StoreLeaseholderMsgs from the</span>
<span id="L1248"><span class="lineNum">    1248</span>              :         // local stores, or if the local leaseholder is transferring the lease to</span>
<span id="L1249"><span class="lineNum">    1249</span>              :         // a non-local store. In the latter case, there is a pending change reflecting</span>
<span id="L1250"><span class="lineNum">    1250</span>              :         // the lease transfer, and the adjusted range state (which already reflects</span>
<span id="L1251"><span class="lineNum">    1251</span>              :         // that transfer) will show the lease on a non-local store. If/once this</span>
<span id="L1252"><span class="lineNum">    1252</span>              :         // change gets enacted via a StoreLeaseholderMsg, range state is</span>
<span id="L1253"><span class="lineNum">    1253</span>              :         // dropped.</span>
<span id="L1254"><span class="lineNum">    1254</span>              :         //</span>
<span id="L1255"><span class="lineNum">    1255</span>              :         // Of course, if the lease shedding was done as part of moving the replica</span>
<span id="L1256"><span class="lineNum">    1256</span>              :         // from one local store to another local store, then the rangeState will</span>
<span id="L1257"><span class="lineNum">    1257</span>              :         // just change hands, and continue to be in the map if the</span>
<span id="L1258"><span class="lineNum">    1258</span>              :         // StoreLeaseholderMsg of the new (local) leaseholder store is received with</span>
<span id="L1259"><span class="lineNum">    1259</span>              :         // the enacted change before the StoreLeaseholderMsg of the old (local)</span>
<span id="L1260"><span class="lineNum">    1260</span>              :         // leaseholder store is received with the enacted change (if vice versa, the</span>
<span id="L1261"><span class="lineNum">    1261</span>              :         // range will be removed, and later a new rangeState will be created).</span>
<span id="L1262"><span class="lineNum">    1262</span>              :         //</span>
<span id="L1263"><span class="lineNum">    1263</span>              :         // Maintaining a single rangeState for a RangeID, instead of one per local</span>
<span id="L1264"><span class="lineNum">    1264</span>              :         // store which is the leaseholder, allows us to ensure there is one view of</span>
<span id="L1265"><span class="lineNum">    1265</span>              :         // the range across clusterState. One complication around this is that we</span>
<span id="L1266"><span class="lineNum">    1266</span>              :         // also need to gc from ranges, and having a view per local store that is</span>
<span id="L1267"><span class="lineNum">    1267</span>              :         // the leaseholder would allow for more efficient gc when receiving a</span>
<span id="L1268"><span class="lineNum">    1268</span>              :         // StoreLeaseholderMsg. For now, we avoid denormalizing and taking the</span>
<span id="L1269"><span class="lineNum">    1269</span>              :         // efficiency hit.</span>
<span id="L1270"><span class="lineNum">    1270</span>              :         ranges map[roachpb.RangeID]*rangeState</span>
<span id="L1271"><span class="lineNum">    1271</span>              : </span>
<span id="L1272"><span class="lineNum">    1272</span>              :         scratchRangeMap map[roachpb.RangeID]struct{}</span>
<span id="L1273"><span class="lineNum">    1273</span>              : </span>
<span id="L1274"><span class="lineNum">    1274</span>              :         // Added to when a change is proposed. Will also add to corresponding</span>
<span id="L1275"><span class="lineNum">    1275</span>              :         // rangeState.pendingChanges and to the affected storeStates.</span>
<span id="L1276"><span class="lineNum">    1276</span>              :         //</span>
<span id="L1277"><span class="lineNum">    1277</span>              :         // Removed from based on RangeMsg (provided by the leaseholder),</span>
<span id="L1278"><span class="lineNum">    1278</span>              :         // AdjustPendingChangesDisposition (provided by the enacting module at the</span>
<span id="L1279"><span class="lineNum">    1279</span>              :         // leaseholder), or time-based GC.</span>
<span id="L1280"><span class="lineNum">    1280</span>              :         pendingChanges map[changeID]*pendingReplicaChange</span>
<span id="L1281"><span class="lineNum">    1281</span>              :         changeSeqGen   changeID</span>
<span id="L1282"><span class="lineNum">    1282</span>              : </span>
<span id="L1283"><span class="lineNum">    1283</span>              :         *constraintMatcher</span>
<span id="L1284"><span class="lineNum">    1284</span>              :         *localityTierInterner</span>
<span id="L1285"><span class="lineNum">    1285</span>              :         meansMemo *meansMemo</span>
<span id="L1286"><span class="lineNum">    1286</span>              : }</span>
<span id="L1287"><span class="lineNum">    1287</span>              : </span>
<span id="L1288"><span class="lineNum">    1288</span> <span class="tlaGNC">           9 : func newClusterState(ts timeutil.TimeSource, interner *stringInterner) *clusterState {</span></span>
<span id="L1289"><span class="lineNum">    1289</span> <span class="tlaGNC">           9 :         cs := &amp;clusterState{</span></span>
<span id="L1290"><span class="lineNum">    1290</span> <span class="tlaGNC">           9 :                 ts:                   ts,</span></span>
<span id="L1291"><span class="lineNum">    1291</span> <span class="tlaGNC">           9 :                 nodes:                map[roachpb.NodeID]*nodeState{},</span></span>
<span id="L1292"><span class="lineNum">    1292</span> <span class="tlaGNC">           9 :                 stores:               map[roachpb.StoreID]*storeState{},</span></span>
<span id="L1293"><span class="lineNum">    1293</span> <span class="tlaGNC">           9 :                 ranges:               map[roachpb.RangeID]*rangeState{},</span></span>
<span id="L1294"><span class="lineNum">    1294</span> <span class="tlaGNC">           9 :                 scratchRangeMap:      map[roachpb.RangeID]struct{}{},</span></span>
<span id="L1295"><span class="lineNum">    1295</span> <span class="tlaGNC">           9 :                 pendingChanges:       map[changeID]*pendingReplicaChange{},</span></span>
<span id="L1296"><span class="lineNum">    1296</span> <span class="tlaGNC">           9 :                 constraintMatcher:    newConstraintMatcher(interner),</span></span>
<span id="L1297"><span class="lineNum">    1297</span> <span class="tlaGNC">           9 :                 localityTierInterner: newLocalityTierInterner(interner),</span></span>
<span id="L1298"><span class="lineNum">    1298</span> <span class="tlaGNC">           9 :         }</span></span>
<span id="L1299"><span class="lineNum">    1299</span> <span class="tlaGNC">           9 :         cs.meansMemo = newMeansMemo(cs, cs.constraintMatcher)</span></span>
<span id="L1300"><span class="lineNum">    1300</span> <span class="tlaGNC">           9 :         return cs</span></span>
<span id="L1301"><span class="lineNum">    1301</span> <span class="tlaGNC">           9 : }</span></span>
<span id="L1302"><span class="lineNum">    1302</span>              : </span>
<span id="L1303"><span class="lineNum">    1303</span> <span class="tlaGNC">          21 : func (cs *clusterState) processStoreLoadMsg(ctx context.Context, storeMsg *StoreLoadMsg) {</span></span>
<span id="L1304"><span class="lineNum">    1304</span> <span class="tlaGNC">          21 :         now := cs.ts.Now()</span></span>
<span id="L1305"><span class="lineNum">    1305</span> <span class="tlaGNC">          21 :         cs.gcPendingChanges(now)</span></span>
<span id="L1306"><span class="lineNum">    1306</span> <span class="tlaGNC">          21 : </span></span>
<span id="L1307"><span class="lineNum">    1307</span> <span class="tlaGNC">          21 :         ns := cs.nodes[storeMsg.NodeID]</span></span>
<span id="L1308"><span class="lineNum">    1308</span> <span class="tlaGNC">          21 :         ss := cs.stores[storeMsg.StoreID]</span></span>
<span id="L1309"><span class="lineNum">    1309</span> <span class="tlaGNC">          21 :         // Handle the node load, updating the reported load and set the adjusted load</span></span>
<span id="L1310"><span class="lineNum">    1310</span> <span class="tlaGNC">          21 :         // to be equal to the reported load initially. Any remaining pending changes</span></span>
<span id="L1311"><span class="lineNum">    1311</span> <span class="tlaGNC">          21 :         // will be re-applied to the reported load.</span></span>
<span id="L1312"><span class="lineNum">    1312</span> <span class="tlaGNC">          21 :         if ns == nil {</span></span>
<span id="L1313"><span class="lineNum">    1313</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(&quot;node %d not found storeMsg=%v&quot;, storeMsg.NodeID, *storeMsg))</span></span>
<span id="L1314"><span class="lineNum">    1314</span>              :         }</span>
<span id="L1315"><span class="lineNum">    1315</span> <span class="tlaGNC">          21 :         if ss == nil {</span></span>
<span id="L1316"><span class="lineNum">    1316</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(&quot;store %d not found&quot;, storeMsg.StoreID))</span></span>
<span id="L1317"><span class="lineNum">    1317</span>              :         }</span>
<span id="L1318"><span class="lineNum">    1318</span> <span class="tlaGNC">          21 :         ns.ReportedCPU += storeMsg.Load[CPURate] - ss.reportedLoad[CPURate]</span></span>
<span id="L1319"><span class="lineNum">    1319</span> <span class="tlaGNC">          21 :         ns.CapacityCPU += storeMsg.Capacity[CPURate] - ss.capacity[CPURate]</span></span>
<span id="L1320"><span class="lineNum">    1320</span> <span class="tlaGNC">          21 :         // Undo the adjustment for the store. We will apply the adjustment again</span></span>
<span id="L1321"><span class="lineNum">    1321</span> <span class="tlaGNC">          21 :         // below.</span></span>
<span id="L1322"><span class="lineNum">    1322</span> <span class="tlaGNC">          21 :         ns.adjustedCPU += storeMsg.Load[CPURate] - ss.adjusted.load[CPURate]</span></span>
<span id="L1323"><span class="lineNum">    1323</span> <span class="tlaGNC">          21 : </span></span>
<span id="L1324"><span class="lineNum">    1324</span> <span class="tlaGNC">          21 :         // The store's load sequence number is incremented on each load change. The</span></span>
<span id="L1325"><span class="lineNum">    1325</span> <span class="tlaGNC">          21 :         // store's load is updated below.</span></span>
<span id="L1326"><span class="lineNum">    1326</span> <span class="tlaGNC">          21 :         ss.loadSeqNum++</span></span>
<span id="L1327"><span class="lineNum">    1327</span> <span class="tlaGNC">          21 :         ss.storeLoad.reportedLoad = storeMsg.Load</span></span>
<span id="L1328"><span class="lineNum">    1328</span> <span class="tlaGNC">          21 :         ss.storeLoad.capacity = storeMsg.Capacity</span></span>
<span id="L1329"><span class="lineNum">    1329</span> <span class="tlaGNC">          21 :         ss.storeLoad.reportedSecondaryLoad = storeMsg.SecondaryLoad</span></span>
<span id="L1330"><span class="lineNum">    1330</span> <span class="tlaGNC">          21 : </span></span>
<span id="L1331"><span class="lineNum">    1331</span> <span class="tlaGNC">          21 :         // Reset the adjusted load to be the reported load. We will re-apply any</span></span>
<span id="L1332"><span class="lineNum">    1332</span> <span class="tlaGNC">          21 :         // remaining pending change deltas to the updated adjusted load.</span></span>
<span id="L1333"><span class="lineNum">    1333</span> <span class="tlaGNC">          21 :         ss.adjusted.load = storeMsg.Load</span></span>
<span id="L1334"><span class="lineNum">    1334</span> <span class="tlaGNC">          21 :         ss.adjusted.secondaryLoad = storeMsg.SecondaryLoad</span></span>
<span id="L1335"><span class="lineNum">    1335</span> <span class="tlaGNC">          21 :         ss.maxFractionPendingIncrease, ss.maxFractionPendingDecrease = 0, 0</span></span>
<span id="L1336"><span class="lineNum">    1336</span> <span class="tlaGNC">          21 : </span></span>
<span id="L1337"><span class="lineNum">    1337</span> <span class="tlaGNC">          21 :         // Find any load pending changes for ranges which involve this store, that</span></span>
<span id="L1338"><span class="lineNum">    1338</span> <span class="tlaGNC">          21 :         // can now be removed from the loadPendingChanges. We don't need to undo the</span></span>
<span id="L1339"><span class="lineNum">    1339</span> <span class="tlaGNC">          21 :         // corresponding delta adjustment as the reported load already contains the</span></span>
<span id="L1340"><span class="lineNum">    1340</span> <span class="tlaGNC">          21 :         // effect.</span></span>
<span id="L1341"><span class="lineNum">    1341</span> <span class="tlaGNC">          21 :         for _, change := range ss.computePendingChangesReflectedInLatestLoad(storeMsg.LoadTime) {</span></span>
<span id="L1342"><span class="lineNum">    1342</span> <span class="tlaGNC">           5 :                 log.KvDistribution.VInfof(ctx, 2, &quot;s%d not-pending %v&quot;, storeMsg.StoreID, change)</span></span>
<span id="L1343"><span class="lineNum">    1343</span> <span class="tlaGNC">           5 :                 delete(ss.adjusted.loadPendingChanges, change.changeID)</span></span>
<span id="L1344"><span class="lineNum">    1344</span> <span class="tlaGNC">           5 :         }</span></span>
<span id="L1345"><span class="lineNum">    1345</span>              : </span>
<span id="L1346"><span class="lineNum">    1346</span> <span class="tlaGNC">          21 :         for _, change := range ss.adjusted.loadPendingChanges {</span></span>
<span id="L1347"><span class="lineNum">    1347</span> <span class="tlaGNC">           4 :                 // The pending change hasn't been reported as done, re-apply the load</span></span>
<span id="L1348"><span class="lineNum">    1348</span> <span class="tlaGNC">           4 :                 // delta to the adjusted load and include it in the new adjusted load</span></span>
<span id="L1349"><span class="lineNum">    1349</span> <span class="tlaGNC">           4 :                 // replicas.</span></span>
<span id="L1350"><span class="lineNum">    1350</span> <span class="tlaGNC">           4 :                 cs.applyChangeLoadDelta(change.ReplicaChange)</span></span>
<span id="L1351"><span class="lineNum">    1351</span> <span class="tlaGNC">           4 :         }</span></span>
<span id="L1352"><span class="lineNum">    1352</span> <span class="tlaGNC">          21 :         log.KvDistribution.VInfof(ctx, 2, &quot;processStoreLoadMsg for store s%v: %v&quot;,</span></span>
<span id="L1353"><span class="lineNum">    1353</span> <span class="tlaGNC">          21 :                 storeMsg.StoreID, ss.adjusted.load)</span></span>
<span id="L1354"><span class="lineNum">    1354</span>              : }</span>
<span id="L1355"><span class="lineNum">    1355</span>              : </span>
<span id="L1356"><span class="lineNum">    1356</span>              : func (cs *clusterState) processStoreLeaseholderMsg(</span>
<span id="L1357"><span class="lineNum">    1357</span>              :         ctx context.Context, msg *StoreLeaseholderMsg, metrics *MMAMetrics,</span>
<span id="L1358"><span class="lineNum">    1358</span> <span class="tlaUNC">           0 : ) {</span></span>
<span id="L1359"><span class="lineNum">    1359</span> <span class="tlaUNC">           0 :         cs.processStoreLeaseholderMsgInternal(ctx, msg, numTopKReplicas, metrics)</span></span>
<span id="L1360"><span class="lineNum">    1360</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L1361"><span class="lineNum">    1361</span>              : </span>
<span id="L1362"><span class="lineNum">    1362</span>              : func (cs *clusterState) processStoreLeaseholderMsgInternal(</span>
<span id="L1363"><span class="lineNum">    1363</span>              :         ctx context.Context, msg *StoreLeaseholderMsg, numTopKReplicas int, metrics *MMAMetrics,</span>
<span id="L1364"><span class="lineNum">    1364</span> <span class="tlaGNC">          22 : ) {</span></span>
<span id="L1365"><span class="lineNum">    1365</span> <span class="tlaGNC">          22 :         now := cs.ts.Now()</span></span>
<span id="L1366"><span class="lineNum">    1366</span> <span class="tlaGNC">          22 :         cs.gcPendingChanges(now)</span></span>
<span id="L1367"><span class="lineNum">    1367</span> <span class="tlaGNC">          22 : </span></span>
<span id="L1368"><span class="lineNum">    1368</span> <span class="tlaGNC">          22 :         clear(cs.scratchRangeMap)</span></span>
<span id="L1369"><span class="lineNum">    1369</span> <span class="tlaGNC">          28 :         for _, rangeMsg := range msg.Ranges {</span></span>
<span id="L1370"><span class="lineNum">    1370</span> <span class="tlaGNC">          28 :                 cs.scratchRangeMap[rangeMsg.RangeID] = struct{}{}</span></span>
<span id="L1371"><span class="lineNum">    1371</span> <span class="tlaGNC">          28 :                 rs, ok := cs.ranges[rangeMsg.RangeID]</span></span>
<span id="L1372"><span class="lineNum">    1372</span> <span class="tlaGNC">          28 :                 if !ok {</span></span>
<span id="L1373"><span class="lineNum">    1373</span> <span class="tlaGNC">          11 :                         // This is the first time we've seen this range.</span></span>
<span id="L1374"><span class="lineNum">    1374</span> <span class="tlaGNC">          11 :                         if !rangeMsg.MaybeSpanConfIsPopulated {</span></span>
<span id="L1375"><span class="lineNum">    1375</span> <span class="tlaUNC">           0 :                                 panic(errors.AssertionFailedf(&quot;rangeMsg for new range r%v is not populated&quot;, rangeMsg.RangeID))</span></span>
<span id="L1376"><span class="lineNum">    1376</span>              :                         }</span>
<span id="L1377"><span class="lineNum">    1377</span> <span class="tlaGNC">          11 :                         rs = newRangeState(msg.StoreID)</span></span>
<span id="L1378"><span class="lineNum">    1378</span> <span class="tlaGNC">          11 :                         cs.ranges[rangeMsg.RangeID] = rs</span></span>
<span id="L1379"><span class="lineNum">    1379</span> <span class="tlaGNC">          17 :                 } else if rs.localRangeOwner != msg.StoreID {</span></span>
<span id="L1380"><span class="lineNum">    1380</span> <span class="tlaGNC">           2 :                         rs.localRangeOwner = msg.StoreID</span></span>
<span id="L1381"><span class="lineNum">    1381</span> <span class="tlaGNC">           2 :                 }</span></span>
<span id="L1382"><span class="lineNum">    1382</span> <span class="tlaGNC">          28 :                 if !rangeMsg.MaybeSpanConfIsPopulated &amp;&amp; len(rs.pendingChanges) == 0 {</span></span>
<span id="L1383"><span class="lineNum">    1383</span> <span class="tlaGNC">           8 :                         // Common case: no pending changes, and span config not provided.</span></span>
<span id="L1384"><span class="lineNum">    1384</span> <span class="tlaGNC">           8 :                         //</span></span>
<span id="L1385"><span class="lineNum">    1385</span> <span class="tlaGNC">           8 :                         // Confirm that the membership state is consistent. If not, fall through</span></span>
<span id="L1386"><span class="lineNum">    1386</span> <span class="tlaGNC">           8 :                         // and make it consistent. We have seen an example where</span></span>
<span id="L1387"><span class="lineNum">    1387</span> <span class="tlaGNC">           8 :                         // AdjustPendingChangesDisposition lied about being successful, and have</span></span>
<span id="L1388"><span class="lineNum">    1388</span> <span class="tlaGNC">           8 :                         // not been able to find the root cause. So we'd rather force eventual</span></span>
<span id="L1389"><span class="lineNum">    1389</span> <span class="tlaGNC">           8 :                         // consistency here.</span></span>
<span id="L1390"><span class="lineNum">    1390</span> <span class="tlaGNC">           8 :                         mayHaveDiverged := false</span></span>
<span id="L1391"><span class="lineNum">    1391</span> <span class="tlaGNC">           8 :                         if len(rs.replicas) == len(rangeMsg.Replicas) {</span></span>
<span id="L1392"><span class="lineNum">    1392</span> <span class="tlaGNC">          13 :                                 for i := range rs.replicas {</span></span>
<span id="L1393"><span class="lineNum">    1393</span> <span class="tlaGNC">          13 :                                         // Since we stuff rangeMsg.Replicas directly into the</span></span>
<span id="L1394"><span class="lineNum">    1394</span> <span class="tlaGNC">          13 :                                         // rangeState.replicas slice, in the common case we expect both of</span></span>
<span id="L1395"><span class="lineNum">    1395</span> <span class="tlaGNC">          13 :                                         // them to have the same replica at the same position. If they</span></span>
<span id="L1396"><span class="lineNum">    1396</span> <span class="tlaGNC">          13 :                                         // don't, they have either diverged, or there have been adjustments</span></span>
<span id="L1397"><span class="lineNum">    1397</span> <span class="tlaGNC">          13 :                                         // made n rangeState.replicas that have changed the ordering. The</span></span>
<span id="L1398"><span class="lineNum">    1398</span> <span class="tlaGNC">          13 :                                         // latter may be a false positive, but we don't mind the small</span></span>
<span id="L1399"><span class="lineNum">    1399</span> <span class="tlaGNC">          13 :                                         // amount of additional work below.</span></span>
<span id="L1400"><span class="lineNum">    1400</span> <span class="tlaGNC">          13 :                                         if rs.replicas[i] != rangeMsg.Replicas[i] {</span></span>
<span id="L1401"><span class="lineNum">    1401</span> <span class="tlaGNC">           1 :                                                 mayHaveDiverged = true</span></span>
<span id="L1402"><span class="lineNum">    1402</span> <span class="tlaGNC">           1 :                                                 break</span></span>
<span id="L1403"><span class="lineNum">    1403</span>              :                                         }</span>
<span id="L1404"><span class="lineNum">    1404</span>              :                                 }</span>
<span id="L1405"><span class="lineNum">    1405</span> <span class="tlaGNC">           1 :                         } else {</span></span>
<span id="L1406"><span class="lineNum">    1406</span> <span class="tlaGNC">           1 :                                 mayHaveDiverged = true</span></span>
<span id="L1407"><span class="lineNum">    1407</span> <span class="tlaGNC">           1 :                         }</span></span>
<span id="L1408"><span class="lineNum">    1408</span> <span class="tlaGNC">           8 :                         if !mayHaveDiverged {</span></span>
<span id="L1409"><span class="lineNum">    1409</span> <span class="tlaGNC">           6 :                                 continue</span></span>
<span id="L1410"><span class="lineNum">    1410</span>              :                         }</span>
<span id="L1411"><span class="lineNum">    1411</span>              :                         // Else fall through and do the expensive work.</span>
<span id="L1412"><span class="lineNum">    1412</span>              :                 }</span>
<span id="L1413"><span class="lineNum">    1413</span>              :                 // Set the range state and store state to match the range message state</span>
<span id="L1414"><span class="lineNum">    1414</span>              :                 // initially. The pending changes which are not enacted in the range</span>
<span id="L1415"><span class="lineNum">    1415</span>              :                 // message are handled and added back below.</span>
<span id="L1416"><span class="lineNum">    1416</span> <span class="tlaGNC">          22 :                 if rangeMsg.MaybeSpanConfIsPopulated {</span></span>
<span id="L1417"><span class="lineNum">    1417</span> <span class="tlaGNC">          20 :                         rs.load = rangeMsg.RangeLoad</span></span>
<span id="L1418"><span class="lineNum">    1418</span> <span class="tlaGNC">          20 :                 }</span></span>
<span id="L1419"><span class="lineNum">    1419</span> <span class="tlaGNC">          22 :                 for _, replica := range rs.replicas {</span></span>
<span id="L1420"><span class="lineNum">    1420</span> <span class="tlaGNC">          19 :                         ss := cs.stores[replica.StoreID]</span></span>
<span id="L1421"><span class="lineNum">    1421</span> <span class="tlaGNC">          19 :                         if ss == nil {</span></span>
<span id="L1422"><span class="lineNum">    1422</span> <span class="tlaUNC">           0 :                                 panic(fmt.Sprintf(&quot;store %d not found stores=%v&quot;, replica.StoreID, cs.stores))</span></span>
<span id="L1423"><span class="lineNum">    1423</span>              :                         }</span>
<span id="L1424"><span class="lineNum">    1424</span> <span class="tlaGNC">          19 :                         delete(cs.stores[replica.StoreID].adjusted.replicas, rangeMsg.RangeID)</span></span>
<span id="L1425"><span class="lineNum">    1425</span>              :                 }</span>
<span id="L1426"><span class="lineNum">    1426</span> <span class="tlaGNC">          22 :                 rs.replicas = append(rs.replicas[:0], rangeMsg.Replicas...)</span></span>
<span id="L1427"><span class="lineNum">    1427</span> <span class="tlaGNC">          45 :                 for _, replica := range rangeMsg.Replicas {</span></span>
<span id="L1428"><span class="lineNum">    1428</span> <span class="tlaGNC">          45 :                         cs.stores[replica.StoreID].adjusted.replicas[rangeMsg.RangeID] = replica.ReplicaState</span></span>
<span id="L1429"><span class="lineNum">    1429</span> <span class="tlaGNC">          45 :                 }</span></span>
<span id="L1430"><span class="lineNum">    1430</span>              : </span>
<span id="L1431"><span class="lineNum">    1431</span>              :                 // Find any pending changes which are now enacted, according to the</span>
<span id="L1432"><span class="lineNum">    1432</span>              :                 // leaseholder. Note that this is the only code path where a subset of</span>
<span id="L1433"><span class="lineNum">    1433</span>              :                 // pending changes for a replica can be considered enacted.</span>
<span id="L1434"><span class="lineNum">    1434</span> <span class="tlaGNC">          22 :                 var remainingChanges, enactedChanges []*pendingReplicaChange</span></span>
<span id="L1435"><span class="lineNum">    1435</span> <span class="tlaGNC">          22 :                 for _, change := range rs.pendingChanges {</span></span>
<span id="L1436"><span class="lineNum">    1436</span> <span class="tlaGNC">          14 :                         ss := cs.stores[change.target.StoreID]</span></span>
<span id="L1437"><span class="lineNum">    1437</span> <span class="tlaGNC">          14 :                         adjustedReplica, ok := ss.adjusted.replicas[rangeMsg.RangeID]</span></span>
<span id="L1438"><span class="lineNum">    1438</span> <span class="tlaGNC">          14 :                         if !ok {</span></span>
<span id="L1439"><span class="lineNum">    1439</span> <span class="tlaGNC">           2 :                                 adjustedReplica.ReplicaID = noReplicaID</span></span>
<span id="L1440"><span class="lineNum">    1440</span> <span class="tlaGNC">           2 :                         }</span></span>
<span id="L1441"><span class="lineNum">    1441</span> <span class="tlaGNC">          14 :                         if adjustedReplica.subsumesChange(change.next) {</span></span>
<span id="L1442"><span class="lineNum">    1442</span> <span class="tlaGNC">           5 :                                 // The change has been enacted according to the leaseholder.</span></span>
<span id="L1443"><span class="lineNum">    1443</span> <span class="tlaGNC">           5 :                                 enactedChanges = append(enactedChanges, change)</span></span>
<span id="L1444"><span class="lineNum">    1444</span> <span class="tlaGNC">           9 :                         } else {</span></span>
<span id="L1445"><span class="lineNum">    1445</span> <span class="tlaGNC">           9 :                                 remainingChanges = append(remainingChanges, change)</span></span>
<span id="L1446"><span class="lineNum">    1446</span> <span class="tlaGNC">           9 :                         }</span></span>
<span id="L1447"><span class="lineNum">    1447</span>              :                 }</span>
<span id="L1448"><span class="lineNum">    1448</span> <span class="tlaGNC">          22 :                 gcRemainingChanges := false</span></span>
<span id="L1449"><span class="lineNum">    1449</span> <span class="tlaGNC">          22 :                 if rs.pendingChangeNoRollback {</span></span>
<span id="L1450"><span class="lineNum">    1450</span> <span class="tlaGNC">           3 :                         // A previous StoreLeaseholderMsg has enacted some changes, so the</span></span>
<span id="L1451"><span class="lineNum">    1451</span> <span class="tlaGNC">           3 :                         // remainingChanges may be GC'able. All of them share the same GC time.</span></span>
<span id="L1452"><span class="lineNum">    1452</span> <span class="tlaGNC">           3 :                         // Note that normal GC will not GC these, since normal GC needs to undo,</span></span>
<span id="L1453"><span class="lineNum">    1453</span> <span class="tlaGNC">           3 :                         // and we are not allowed to undo these.</span></span>
<span id="L1454"><span class="lineNum">    1454</span> <span class="tlaGNC">           3 :                         if len(remainingChanges) &gt; 0 {</span></span>
<span id="L1455"><span class="lineNum">    1455</span> <span class="tlaGNC">           2 :                                 gcTime := remainingChanges[0].gcTime</span></span>
<span id="L1456"><span class="lineNum">    1456</span> <span class="tlaGNC">           2 :                                 if gcTime.Before(now) {</span></span>
<span id="L1457"><span class="lineNum">    1457</span> <span class="tlaGNC">           2 :                                         gcRemainingChanges = true</span></span>
<span id="L1458"><span class="lineNum">    1458</span> <span class="tlaGNC">           2 :                                 }</span></span>
<span id="L1459"><span class="lineNum">    1459</span>              :                         }</span>
<span id="L1460"><span class="lineNum">    1460</span> <span class="tlaGNC">          19 :                 } else if len(enactedChanges) &gt; 0 &amp;&amp; len(remainingChanges) &gt; 0 {</span></span>
<span id="L1461"><span class="lineNum">    1461</span> <span class="tlaGNC">           3 :                         // First time this set of changes is seeing something enacted, and there</span></span>
<span id="L1462"><span class="lineNum">    1462</span> <span class="tlaGNC">           3 :                         // are remaining changes.</span></span>
<span id="L1463"><span class="lineNum">    1463</span> <span class="tlaGNC">           3 :                         //</span></span>
<span id="L1464"><span class="lineNum">    1464</span> <span class="tlaGNC">           3 :                         // No longer permitted to rollback.</span></span>
<span id="L1465"><span class="lineNum">    1465</span> <span class="tlaGNC">           3 :                         rs.pendingChangeNoRollback = true</span></span>
<span id="L1466"><span class="lineNum">    1466</span> <span class="tlaGNC">           3 :                         // All remaining changes have the same gcTime.</span></span>
<span id="L1467"><span class="lineNum">    1467</span> <span class="tlaGNC">           3 :                         curGCTime := remainingChanges[0].gcTime</span></span>
<span id="L1468"><span class="lineNum">    1468</span> <span class="tlaGNC">           3 :                         revisedGCTime := now.Add(partiallyEnactedGCDuration)</span></span>
<span id="L1469"><span class="lineNum">    1469</span> <span class="tlaGNC">           3 :                         if revisedGCTime.Before(curGCTime) {</span></span>
<span id="L1470"><span class="lineNum">    1470</span> <span class="tlaGNC">           3 :                                 // Shorten when the GC happens.</span></span>
<span id="L1471"><span class="lineNum">    1471</span> <span class="tlaGNC">           3 :                                 for _, change := range remainingChanges {</span></span>
<span id="L1472"><span class="lineNum">    1472</span> <span class="tlaGNC">           3 :                                         change.gcTime = revisedGCTime</span></span>
<span id="L1473"><span class="lineNum">    1473</span> <span class="tlaGNC">           3 :                                 }</span></span>
<span id="L1474"><span class="lineNum">    1474</span>              :                         }</span>
<span id="L1475"><span class="lineNum">    1475</span>              :                 }</span>
<span id="L1476"><span class="lineNum">    1476</span>              :                 // rs.pendingChanges is the union of remainingChanges and enactedChanges.</span>
<span id="L1477"><span class="lineNum">    1477</span>              :                 // These changes are also in cs.pendingChanges.</span>
<span id="L1478"><span class="lineNum">    1478</span> <span class="tlaGNC">          22 :                 if len(enactedChanges) &gt; 0 {</span></span>
<span id="L1479"><span class="lineNum">    1479</span> <span class="tlaGNC">           5 :                         log.KvDistribution.Infof(ctx, &quot;enactedChanges %v&quot;, enactedChanges)</span></span>
<span id="L1480"><span class="lineNum">    1480</span> <span class="tlaGNC">           5 :                 }</span></span>
<span id="L1481"><span class="lineNum">    1481</span> <span class="tlaGNC">          22 :                 for _, change := range enactedChanges {</span></span>
<span id="L1482"><span class="lineNum">    1482</span> <span class="tlaGNC">           5 :                         // Mark the change as enacted. Enacting a change does not remove the</span></span>
<span id="L1483"><span class="lineNum">    1483</span> <span class="tlaGNC">           5 :                         // corresponding load adjustments. The store load message will do that,</span></span>
<span id="L1484"><span class="lineNum">    1484</span> <span class="tlaGNC">           5 :                         // indicating that the change has been reflected in the store load.</span></span>
<span id="L1485"><span class="lineNum">    1485</span> <span class="tlaGNC">           5 :                         //</span></span>
<span id="L1486"><span class="lineNum">    1486</span> <span class="tlaGNC">           5 :                         // There was a previous bug where these changes were not being</span></span>
<span id="L1487"><span class="lineNum">    1487</span> <span class="tlaGNC">           5 :                         // removed now, and were being removed later when the load adjustment</span></span>
<span id="L1488"><span class="lineNum">    1488</span> <span class="tlaGNC">           5 :                         // incorporated them. Fixing this has introduced improved</span></span>
<span id="L1489"><span class="lineNum">    1489</span> <span class="tlaGNC">           5 :                         // example_skewed_cpu_even_ranges_mma in that it converges faster, but</span></span>
<span id="L1490"><span class="lineNum">    1490</span> <span class="tlaGNC">           5 :                         // introduced more thrashing in</span></span>
<span id="L1491"><span class="lineNum">    1491</span> <span class="tlaGNC">           5 :                         // example_skewed_cpu_even_ranges_mma_and_queues. I suspect the latter</span></span>
<span id="L1492"><span class="lineNum">    1492</span> <span class="tlaGNC">           5 :                         // is because MMA is acting faster to undo the effects of the changes</span></span>
<span id="L1493"><span class="lineNum">    1493</span> <span class="tlaGNC">           5 :                         // made by the replicate and lease queues.</span></span>
<span id="L1494"><span class="lineNum">    1494</span> <span class="tlaGNC">           5 :                         cs.pendingChangeEnacted(change.changeID, now)</span></span>
<span id="L1495"><span class="lineNum">    1495</span> <span class="tlaGNC">           5 :                 }</span></span>
<span id="L1496"><span class="lineNum">    1496</span>              :                 // INVARIANT: remainingChanges and rs.pendingChanges contain the same set</span>
<span id="L1497"><span class="lineNum">    1497</span>              :                 // of changes, though possibly in different order.</span>
<span id="L1498"><span class="lineNum">    1498</span>              : </span>
<span id="L1499"><span class="lineNum">    1499</span>              :                 // rs.pendingChanges only contains remainingChanges, and these are also in</span>
<span id="L1500"><span class="lineNum">    1500</span>              :                 // cs.pendingChanges and storeState's loadPendingChanges. Their load</span>
<span id="L1501"><span class="lineNum">    1501</span>              :                 // effect is also incorporated into the storeStates, but not in the range</span>
<span id="L1502"><span class="lineNum">    1502</span>              :                 // membership (since we undid that above).</span>
<span id="L1503"><span class="lineNum">    1503</span> <span class="tlaGNC">          22 :                 if len(remainingChanges) &gt; 0 {</span></span>
<span id="L1504"><span class="lineNum">    1504</span> <span class="tlaGNC">           7 :                         log.KvDistribution.Infof(ctx, &quot;remainingChanges %v&quot;, remainingChanges)</span></span>
<span id="L1505"><span class="lineNum">    1505</span> <span class="tlaGNC">           7 :                         // Temporarily set the rs.pendingChanges to nil, since</span></span>
<span id="L1506"><span class="lineNum">    1506</span> <span class="tlaGNC">           7 :                         // preCheckOnApplyReplicaChanges returns false if there are any pending</span></span>
<span id="L1507"><span class="lineNum">    1507</span> <span class="tlaGNC">           7 :                         // changes, and these are the changes that are pending. This is hacky</span></span>
<span id="L1508"><span class="lineNum">    1508</span> <span class="tlaGNC">           7 :                         // and should be cleaned up.</span></span>
<span id="L1509"><span class="lineNum">    1509</span> <span class="tlaGNC">           7 :                         var valid bool</span></span>
<span id="L1510"><span class="lineNum">    1510</span> <span class="tlaGNC">           7 :                         var reason redact.RedactableString</span></span>
<span id="L1511"><span class="lineNum">    1511</span> <span class="tlaGNC">           7 :                         if gcRemainingChanges {</span></span>
<span id="L1512"><span class="lineNum">    1512</span> <span class="tlaGNC">           2 :                                 reason = &quot;GCing remaining changes after partial enactment&quot;</span></span>
<span id="L1513"><span class="lineNum">    1513</span> <span class="tlaGNC">           5 :                         } else {</span></span>
<span id="L1514"><span class="lineNum">    1514</span> <span class="tlaGNC">           5 :                                 // NB: rs.pendingChanges contains the same changes as</span></span>
<span id="L1515"><span class="lineNum">    1515</span> <span class="tlaGNC">           5 :                                 // remainingChanges, but they are not the same slice.</span></span>
<span id="L1516"><span class="lineNum">    1516</span> <span class="tlaGNC">           5 :                                 rc := rs.pendingChanges</span></span>
<span id="L1517"><span class="lineNum">    1517</span> <span class="tlaGNC">           5 :                                 rs.pendingChanges = nil</span></span>
<span id="L1518"><span class="lineNum">    1518</span> <span class="tlaGNC">           5 :                                 err := cs.preCheckOnApplyReplicaChanges(PendingRangeChange{</span></span>
<span id="L1519"><span class="lineNum">    1519</span> <span class="tlaGNC">           5 :                                         RangeID:               rangeMsg.RangeID,</span></span>
<span id="L1520"><span class="lineNum">    1520</span> <span class="tlaGNC">           5 :                                         pendingReplicaChanges: remainingChanges,</span></span>
<span id="L1521"><span class="lineNum">    1521</span> <span class="tlaGNC">           5 :                                 })</span></span>
<span id="L1522"><span class="lineNum">    1522</span> <span class="tlaGNC">           5 :                                 valid = err == nil</span></span>
<span id="L1523"><span class="lineNum">    1523</span> <span class="tlaGNC">           5 :                                 if err != nil {</span></span>
<span id="L1524"><span class="lineNum">    1524</span> <span class="tlaUNC">           0 :                                         reason = redact.Sprint(err)</span></span>
<span id="L1525"><span class="lineNum">    1525</span> <span class="tlaUNC">           0 :                                 }</span></span>
<span id="L1526"><span class="lineNum">    1526</span>              :                                 // Restore it.</span>
<span id="L1527"><span class="lineNum">    1527</span> <span class="tlaGNC">           5 :                                 rs.pendingChanges = rc</span></span>
<span id="L1528"><span class="lineNum">    1528</span>              :                         }</span>
<span id="L1529"><span class="lineNum">    1529</span> <span class="tlaGNC">           7 :                         if valid {</span></span>
<span id="L1530"><span class="lineNum">    1530</span> <span class="tlaGNC">           5 :                                 // Re-apply the remaining changes. Note that the load change was not</span></span>
<span id="L1531"><span class="lineNum">    1531</span> <span class="tlaGNC">           5 :                                 // undone above, so we pass !applyLoadChange, to avoid applying it</span></span>
<span id="L1532"><span class="lineNum">    1532</span> <span class="tlaGNC">           5 :                                 // again. Also note that applyReplicaChange does not add to the various</span></span>
<span id="L1533"><span class="lineNum">    1533</span> <span class="tlaGNC">           5 :                                 // pendingChanges data-structures, which is what we want here since</span></span>
<span id="L1534"><span class="lineNum">    1534</span> <span class="tlaGNC">           5 :                                 // these changes are already in those data-structures.</span></span>
<span id="L1535"><span class="lineNum">    1535</span> <span class="tlaGNC">           7 :                                 for _, change := range remainingChanges {</span></span>
<span id="L1536"><span class="lineNum">    1536</span> <span class="tlaGNC">           7 :                                         cs.applyReplicaChange(change.ReplicaChange, false)</span></span>
<span id="L1537"><span class="lineNum">    1537</span> <span class="tlaGNC">           7 :                                 }</span></span>
<span id="L1538"><span class="lineNum">    1538</span> <span class="tlaGNC">           2 :                         } else {</span></span>
<span id="L1539"><span class="lineNum">    1539</span> <span class="tlaGNC">           2 :                                 // The current state provided by the leaseholder does not permit these</span></span>
<span id="L1540"><span class="lineNum">    1540</span> <span class="tlaGNC">           2 :                                 // changes, so we need to drop them. This should be rare, but can happen</span></span>
<span id="L1541"><span class="lineNum">    1541</span> <span class="tlaGNC">           2 :                                 // if the leaseholder executed a change that MMA was completely unaware</span></span>
<span id="L1542"><span class="lineNum">    1542</span> <span class="tlaGNC">           2 :                                 // of.</span></span>
<span id="L1543"><span class="lineNum">    1543</span> <span class="tlaGNC">           2 :                                 log.KvDistribution.Infof(ctx, &quot;remainingChanges %v are no longer valid due to %v&quot;,</span></span>
<span id="L1544"><span class="lineNum">    1544</span> <span class="tlaGNC">           2 :                                         remainingChanges, reason)</span></span>
<span id="L1545"><span class="lineNum">    1545</span> <span class="tlaGNC">           2 :                                 if metrics != nil {</span></span>
<span id="L1546"><span class="lineNum">    1546</span> <span class="tlaUNC">           0 :                                         metrics.DroppedDueToStateInconsistency.Inc(1)</span></span>
<span id="L1547"><span class="lineNum">    1547</span> <span class="tlaUNC">           0 :                                 }</span></span>
<span id="L1548"><span class="lineNum">    1548</span>              :                                 // We did not undo the load change above, or remove it from the various</span>
<span id="L1549"><span class="lineNum">    1549</span>              :                                 // pendingChanges data-structures. We do those things now.</span>
<span id="L1550"><span class="lineNum">    1550</span> <span class="tlaGNC">           2 :                                 for _, change := range remainingChanges {</span></span>
<span id="L1551"><span class="lineNum">    1551</span> <span class="tlaGNC">           2 :                                         rs.removePendingChangeTracking(change.changeID)</span></span>
<span id="L1552"><span class="lineNum">    1552</span> <span class="tlaGNC">           2 :                                         delete(cs.stores[change.target.StoreID].adjusted.loadPendingChanges, change.changeID)</span></span>
<span id="L1553"><span class="lineNum">    1553</span> <span class="tlaGNC">           2 :                                         delete(cs.pendingChanges, change.changeID)</span></span>
<span id="L1554"><span class="lineNum">    1554</span> <span class="tlaGNC">           2 :                                         cs.undoChangeLoadDelta(change.ReplicaChange)</span></span>
<span id="L1555"><span class="lineNum">    1555</span> <span class="tlaGNC">           2 :                                 }</span></span>
<span id="L1556"><span class="lineNum">    1556</span> <span class="tlaGNC">           2 :                                 if n := len(rs.pendingChanges); n &gt; 0 {</span></span>
<span id="L1557"><span class="lineNum">    1557</span> <span class="tlaUNC">           0 :                                         panic(errors.AssertionFailedf(&quot;expected no pending changes but found %d&quot;, n))</span></span>
<span id="L1558"><span class="lineNum">    1558</span>              :                                 }</span>
<span id="L1559"><span class="lineNum">    1559</span>              :                         }</span>
<span id="L1560"><span class="lineNum">    1560</span>              :                 }</span>
<span id="L1561"><span class="lineNum">    1561</span> <span class="tlaGNC">          22 :                 if rangeMsg.MaybeSpanConfIsPopulated {</span></span>
<span id="L1562"><span class="lineNum">    1562</span> <span class="tlaGNC">          20 :                         normSpanConfig, err := makeNormalizedSpanConfig(&amp;rangeMsg.MaybeSpanConf, cs.constraintMatcher.interner)</span></span>
<span id="L1563"><span class="lineNum">    1563</span> <span class="tlaGNC">          20 :                         if err != nil {</span></span>
<span id="L1564"><span class="lineNum">    1564</span> <span class="tlaUNC">           0 :                                 // TODO(kvoli): Should we log as a warning here, or return further back out?</span></span>
<span id="L1565"><span class="lineNum">    1565</span> <span class="tlaUNC">           0 :                                 panic(err)</span></span>
<span id="L1566"><span class="lineNum">    1566</span>              :                         }</span>
<span id="L1567"><span class="lineNum">    1567</span> <span class="tlaGNC">          20 :                         rs.conf = normSpanConfig</span></span>
<span id="L1568"><span class="lineNum">    1568</span>              :                 }</span>
<span id="L1569"><span class="lineNum">    1569</span>              :                 // NB: Always recompute the analyzed range constraints for any range,</span>
<span id="L1570"><span class="lineNum">    1570</span>              :                 // assuming the leaseholder wouldn't have sent the message if there was no</span>
<span id="L1571"><span class="lineNum">    1571</span>              :                 // change, or we noticed a divergence in membership above and fell through</span>
<span id="L1572"><span class="lineNum">    1572</span>              :                 // here.</span>
<span id="L1573"><span class="lineNum">    1573</span> <span class="tlaGNC">          22 :                 rs.clearAnalyzedConstraints()</span></span>
<span id="L1574"><span class="lineNum">    1574</span>              :         }</span>
<span id="L1575"><span class="lineNum">    1575</span>              :         // Remove ranges for which this is the localRangeOwner, but for which it is</span>
<span id="L1576"><span class="lineNum">    1576</span>              :         // no longer the leaseholder.</span>
<span id="L1577"><span class="lineNum">    1577</span> <span class="tlaGNC">          32 :         for r, rs := range cs.ranges {</span></span>
<span id="L1578"><span class="lineNum">    1578</span> <span class="tlaGNC">          32 :                 _, ok := cs.scratchRangeMap[r]</span></span>
<span id="L1579"><span class="lineNum">    1579</span> <span class="tlaGNC">          32 :                 if ok {</span></span>
<span id="L1580"><span class="lineNum">    1580</span> <span class="tlaGNC">          28 :                         continue</span></span>
<span id="L1581"><span class="lineNum">    1581</span>              :                 }</span>
<span id="L1582"><span class="lineNum">    1582</span>              :                 // Not the leaseholder for this range. Consider removing it.</span>
<span id="L1583"><span class="lineNum">    1583</span>              :                 //</span>
<span id="L1584"><span class="lineNum">    1584</span>              :                 // In a multi-store setting this is inefficient, since we are iterating</span>
<span id="L1585"><span class="lineNum">    1585</span>              :                 // over all ranges for which any local store is the owner. We could be</span>
<span id="L1586"><span class="lineNum">    1586</span>              :                 // more efficient by maintaining an additional</span>
<span id="L1587"><span class="lineNum">    1587</span>              :                 // map[roachpb.StoreID]map[roachpb.RangeID]*rangeState, where the first</span>
<span id="L1588"><span class="lineNum">    1588</span>              :                 // map is keyed by a local StoreID. But we will only do this if we find</span>
<span id="L1589"><span class="lineNum">    1589</span>              :                 // the efficiency gains are worth it.</span>
<span id="L1590"><span class="lineNum">    1590</span> <span class="tlaGNC">           4 :                 if rs.localRangeOwner != msg.StoreID {</span></span>
<span id="L1591"><span class="lineNum">    1591</span> <span class="tlaUNC">           0 :                         continue</span></span>
<span id="L1592"><span class="lineNum">    1592</span>              :                 }</span>
<span id="L1593"><span class="lineNum">    1593</span>              :                 // Since this range is going away, mark all the pending changes as</span>
<span id="L1594"><span class="lineNum">    1594</span>              :                 // enacted. This will allow the load adjustments to also be garbage</span>
<span id="L1595"><span class="lineNum">    1595</span>              :                 // collected in the future.</span>
<span id="L1596"><span class="lineNum">    1596</span>              :                 //</span>
<span id="L1597"><span class="lineNum">    1597</span>              :                 // Gather the changeIDs, since calls to pendingChangeEnacted modify the</span>
<span id="L1598"><span class="lineNum">    1598</span>              :                 // rs.pendingChanges slice.</span>
<span id="L1599"><span class="lineNum">    1599</span> <span class="tlaGNC">           4 :                 changeIDs := make([]changeID, len(rs.pendingChanges))</span></span>
<span id="L1600"><span class="lineNum">    1600</span> <span class="tlaGNC">           4 :                 for i, change := range rs.pendingChanges {</span></span>
<span id="L1601"><span class="lineNum">    1601</span> <span class="tlaGNC">           4 :                         changeIDs[i] = change.changeID</span></span>
<span id="L1602"><span class="lineNum">    1602</span> <span class="tlaGNC">           4 :                 }</span></span>
<span id="L1603"><span class="lineNum">    1603</span> <span class="tlaGNC">           4 :                 for _, changeID := range changeIDs {</span></span>
<span id="L1604"><span class="lineNum">    1604</span> <span class="tlaGNC">           4 :                         cs.pendingChangeEnacted(changeID, now)</span></span>
<span id="L1605"><span class="lineNum">    1605</span> <span class="tlaGNC">           4 :                 }</span></span>
<span id="L1606"><span class="lineNum">    1606</span>              :                 // Remove from the storeStates.</span>
<span id="L1607"><span class="lineNum">    1607</span> <span class="tlaGNC">           6 :                 for _, replica := range rs.replicas {</span></span>
<span id="L1608"><span class="lineNum">    1608</span> <span class="tlaGNC">           6 :                         ss := cs.stores[replica.StoreID]</span></span>
<span id="L1609"><span class="lineNum">    1609</span> <span class="tlaGNC">           6 :                         if ss == nil {</span></span>
<span id="L1610"><span class="lineNum">    1610</span> <span class="tlaUNC">           0 :                                 panic(fmt.Sprintf(&quot;store %d not found stores=%v&quot;, replica.StoreID, cs.stores))</span></span>
<span id="L1611"><span class="lineNum">    1611</span>              :                         }</span>
<span id="L1612"><span class="lineNum">    1612</span> <span class="tlaGNC">           6 :                         delete(cs.stores[replica.StoreID].adjusted.replicas, r)</span></span>
<span id="L1613"><span class="lineNum">    1613</span>              :                 }</span>
<span id="L1614"><span class="lineNum">    1614</span> <span class="tlaGNC">           4 :                 rs.clearAnalyzedConstraints()</span></span>
<span id="L1615"><span class="lineNum">    1615</span> <span class="tlaGNC">           4 :                 delete(cs.ranges, r)</span></span>
<span id="L1616"><span class="lineNum">    1616</span>              :         }</span>
<span id="L1617"><span class="lineNum">    1617</span> <span class="tlaGNC">          22 :         localss := cs.stores[msg.StoreID]</span></span>
<span id="L1618"><span class="lineNum">    1618</span> <span class="tlaGNC">          22 :         cs.meansMemo.clear()</span></span>
<span id="L1619"><span class="lineNum">    1619</span> <span class="tlaGNC">          22 :         clusterMeans := cs.meansMemo.getMeans(nil)</span></span>
<span id="L1620"><span class="lineNum">    1620</span> <span class="tlaGNC">          55 :         for _, ss := range cs.stores {</span></span>
<span id="L1621"><span class="lineNum">    1621</span> <span class="tlaGNC">          55 :                 topk := ss.adjusted.topKRanges[msg.StoreID]</span></span>
<span id="L1622"><span class="lineNum">    1622</span> <span class="tlaGNC">          55 :                 if topk == nil {</span></span>
<span id="L1623"><span class="lineNum">    1623</span> <span class="tlaGNC">          25 :                         topk = &amp;topKReplicas{k: numTopKReplicas}</span></span>
<span id="L1624"><span class="lineNum">    1624</span> <span class="tlaGNC">          25 :                         ss.adjusted.topKRanges[msg.StoreID] = topk</span></span>
<span id="L1625"><span class="lineNum">    1625</span> <span class="tlaGNC">          25 :                 }</span></span>
<span id="L1626"><span class="lineNum">    1626</span> <span class="tlaGNC">          55 :                 topk.startInit()</span></span>
<span id="L1627"><span class="lineNum">    1627</span> <span class="tlaGNC">          55 :                 sls := cs.computeLoadSummary(ctx, ss.StoreID, &amp;clusterMeans.storeLoad, &amp;clusterMeans.nodeLoad)</span></span>
<span id="L1628"><span class="lineNum">    1628</span> <span class="tlaGNC">          55 :                 if ss.StoreID == localss.StoreID {</span></span>
<span id="L1629"><span class="lineNum">    1629</span> <span class="tlaGNC">          22 :                         topk.dim = CPURate</span></span>
<span id="L1630"><span class="lineNum">    1630</span> <span class="tlaGNC">          33 :                 } else {</span></span>
<span id="L1631"><span class="lineNum">    1631</span> <span class="tlaGNC">          33 :                         topk.dim = WriteBandwidth</span></span>
<span id="L1632"><span class="lineNum">    1632</span> <span class="tlaGNC">          33 :                 }</span></span>
<span id="L1633"><span class="lineNum">    1633</span> <span class="tlaGNC">          55 :                 if sls.highDiskSpaceUtilization {</span></span>
<span id="L1634"><span class="lineNum">    1634</span> <span class="tlaGNC">          14 :                         topk.dim = ByteSize</span></span>
<span id="L1635"><span class="lineNum">    1635</span> <span class="tlaGNC">          41 :                 } else if sls.sls &gt; loadNoChange {</span></span>
<span id="L1636"><span class="lineNum">    1636</span> <span class="tlaGNC">          10 :                         // If multiple dimensions are contributing the same loadSummary, we will pick</span></span>
<span id="L1637"><span class="lineNum">    1637</span> <span class="tlaGNC">          10 :                         // CPURate before WriteBandwidth before ByteSize.</span></span>
<span id="L1638"><span class="lineNum">    1638</span> <span class="tlaGNC">          10 :                         for i := range sls.dimSummary {</span></span>
<span id="L1639"><span class="lineNum">    1639</span> <span class="tlaGNC">          10 :                                 if sls.dimSummary[i] == sls.sls {</span></span>
<span id="L1640"><span class="lineNum">    1640</span> <span class="tlaGNC">          10 :                                         topk.dim = LoadDimension(i)</span></span>
<span id="L1641"><span class="lineNum">    1641</span> <span class="tlaGNC">          10 :                                         break</span></span>
<span id="L1642"><span class="lineNum">    1642</span>              :                                 }</span>
<span id="L1643"><span class="lineNum">    1643</span>              :                         }</span>
<span id="L1644"><span class="lineNum">    1644</span>              :                 }</span>
<span id="L1645"><span class="lineNum">    1645</span>              :                 // Setting a threshold such that only ranges &gt; some threshold of the</span>
<span id="L1646"><span class="lineNum">    1646</span>              :                 // store's load in the top-k dimension are included in the top-k. These</span>
<span id="L1647"><span class="lineNum">    1647</span>              :                 // values are copied from store_rebalancer.go:</span>
<span id="L1648"><span class="lineNum">    1648</span>              :                 // kvserver.{minLeaseLoadFraction, minReplicaLoadFraction}, which are 0.5%</span>
<span id="L1649"><span class="lineNum">    1649</span>              :                 // and 2% respectively.</span>
<span id="L1650"><span class="lineNum">    1650</span>              :                 //</span>
<span id="L1651"><span class="lineNum">    1651</span>              :                 // Arguably, this is not a reasonable way to exclude ranges, and one could</span>
<span id="L1652"><span class="lineNum">    1652</span>              :                 // argue that one should not exclude any ranges. The difficulty is that in</span>
<span id="L1653"><span class="lineNum">    1653</span>              :                 // a N node cluster, there are N allocators, each with a partial view of</span>
<span id="L1654"><span class="lineNum">    1654</span>              :                 // the cluster (based on what each node's stores are leaseholders for). If</span>
<span id="L1655"><span class="lineNum">    1655</span>              :                 // we don't exclude any ranges, and an allocator at n1 sees that a remote</span>
<span id="L1656"><span class="lineNum">    1656</span>              :                 // store s3 has high WriteBandwidth, it can try to move a replica of range</span>
<span id="L1657"><span class="lineNum">    1657</span>              :                 // r1 from s3 to some other store. But it is possible that range r1, even</span>
<span id="L1658"><span class="lineNum">    1658</span>              :                 // though it has the highest WriteBandwidth of the ranges n1 knows about,</span>
<span id="L1659"><span class="lineNum">    1659</span>              :                 // is not significant compared to other ranges on s3, and having some</span>
<span id="L1660"><span class="lineNum">    1660</span>              :                 // other allocator move those other ranges is preferable. Further</span>
<span id="L1661"><span class="lineNum">    1661</span>              :                 // complicating this is that constraints may prevent those other bigger</span>
<span id="L1662"><span class="lineNum">    1662</span>              :                 // (from a WriteBandwidth perspective) ranges to be moved, so eventually</span>
<span id="L1663"><span class="lineNum">    1663</span>              :                 // we may have to fall back to shedding the smaller ranges.</span>
<span id="L1664"><span class="lineNum">    1664</span>              :                 //</span>
<span id="L1665"><span class="lineNum">    1665</span>              :                 // One way to solve this problem is to include the range count in</span>
<span id="L1666"><span class="lineNum">    1666</span>              :                 // StoreLoadMsg, so that each allocator can compute the mean range load</span>
<span id="L1667"><span class="lineNum">    1667</span>              :                 // along the overloaded dimension for a store. Then set a threshold that</span>
<span id="L1668"><span class="lineNum">    1668</span>              :                 // is a multiple of the mean, and gradually ratchet it down (akin to how</span>
<span id="L1669"><span class="lineNum">    1669</span>              :                 // we use time and the various *GraceDurations to adjust ignoreLevel).</span>
<span id="L1670"><span class="lineNum">    1670</span>              :                 //</span>
<span id="L1671"><span class="lineNum">    1671</span>              :                 // Do we really need to solve this problem? Have we had any incidents with</span>
<span id="L1672"><span class="lineNum">    1672</span>              :                 // the current store rebalancer that can be attributed to these</span>
<span id="L1673"><span class="lineNum">    1673</span>              :                 // thresholds?</span>
<span id="L1674"><span class="lineNum">    1674</span>              :                 //</span>
<span id="L1675"><span class="lineNum">    1675</span>              :                 // Old comment: We should actually be using the min of this threshold and</span>
<span id="L1676"><span class="lineNum">    1676</span>              :                 // the n-th ranked load (across all ranges) per dimension reported by the</span>
<span id="L1677"><span class="lineNum">    1677</span>              :                 // store, where say n is 50 (since it is possible that the store has a</span>
<span id="L1678"><span class="lineNum">    1678</span>              :                 // massive range that consumes 50% of the load, and another 100 ranges</span>
<span id="L1679"><span class="lineNum">    1679</span>              :                 // that consume 0.5% each, and the only way to restore health is to shed</span>
<span id="L1680"><span class="lineNum">    1680</span>              :                 // those 100 ranges).</span>
<span id="L1681"><span class="lineNum">    1681</span> <span class="tlaGNC">          55 :                 const (</span></span>
<span id="L1682"><span class="lineNum">    1682</span> <span class="tlaGNC">          55 :                         // minLeaseLoadFraction is the minimum fraction of the local store's load a</span></span>
<span id="L1683"><span class="lineNum">    1683</span> <span class="tlaGNC">          55 :                         // lease must contribute, in order to consider it worthwhile rebalancing when</span></span>
<span id="L1684"><span class="lineNum">    1684</span> <span class="tlaGNC">          55 :                         // overfull.</span></span>
<span id="L1685"><span class="lineNum">    1685</span> <span class="tlaGNC">          55 :                         //</span></span>
<span id="L1686"><span class="lineNum">    1686</span> <span class="tlaGNC">          55 :                         // TODO(tbg): I set this to zero following the discussion in [1] about</span></span>
<span id="L1687"><span class="lineNum">    1687</span> <span class="tlaGNC">          55 :                         // experiment [2].</span></span>
<span id="L1688"><span class="lineNum">    1688</span> <span class="tlaGNC">          55 :                         //</span></span>
<span id="L1689"><span class="lineNum">    1689</span> <span class="tlaGNC">          55 :                         // [1]: https://cockroachlabs.slack.com/archives/C048HDZJSAY/p1751032541196659?thread_ts=1751026215.841039&amp;cid=C048HDZJSAY</span></span>
<span id="L1690"><span class="lineNum">    1690</span> <span class="tlaGNC">          55 :                         // [2]: https://docs.google.com/document/d/1F35E9pOhtMlGAhKeidTyxRPaOpD3oP3DmT3cVvqVbhE/edit?tab=t.0</span></span>
<span id="L1691"><span class="lineNum">    1691</span> <span class="tlaGNC">          55 :                         //</span></span>
<span id="L1692"><span class="lineNum">    1692</span> <span class="tlaGNC">          55 :                         // TODO(sumeer): I set these back to the original values, after adding</span></span>
<span id="L1693"><span class="lineNum">    1693</span> <span class="tlaGNC">          55 :                         // the meanLoad logic below. We need to rerun the roachtest to see if</span></span>
<span id="L1694"><span class="lineNum">    1694</span> <span class="tlaGNC">          55 :                         // this suffices.</span></span>
<span id="L1695"><span class="lineNum">    1695</span> <span class="tlaGNC">          55 :                         minLeaseLoadFraction = 0.005</span></span>
<span id="L1696"><span class="lineNum">    1696</span> <span class="tlaGNC">          55 :                         // minReplicaLoadFraction is the minimum fraction of the local store's</span></span>
<span id="L1697"><span class="lineNum">    1697</span> <span class="tlaGNC">          55 :                         // load a replica (lease included) must contribute, in order to consider</span></span>
<span id="L1698"><span class="lineNum">    1698</span> <span class="tlaGNC">          55 :                         // it worthwhile rebalancing when overfull.</span></span>
<span id="L1699"><span class="lineNum">    1699</span> <span class="tlaGNC">          55 :                         minReplicaLoadFraction = 0.02</span></span>
<span id="L1700"><span class="lineNum">    1700</span> <span class="tlaGNC">          55 :                 )</span></span>
<span id="L1701"><span class="lineNum">    1701</span> <span class="tlaGNC">          55 :                 fraction := minReplicaLoadFraction</span></span>
<span id="L1702"><span class="lineNum">    1702</span> <span class="tlaGNC">          55 :                 if ss.StoreID == msg.StoreID &amp;&amp; topk.dim == CPURate {</span></span>
<span id="L1703"><span class="lineNum">    1703</span> <span class="tlaGNC">          17 :                         // We are assuming we will be able to shed leases, but if we can't we</span></span>
<span id="L1704"><span class="lineNum">    1704</span> <span class="tlaGNC">          17 :                         // will start shedding replicas, so this is just a heuristic.</span></span>
<span id="L1705"><span class="lineNum">    1705</span> <span class="tlaGNC">          17 :                         fraction = minLeaseLoadFraction</span></span>
<span id="L1706"><span class="lineNum">    1706</span> <span class="tlaGNC">          17 :                 }</span></span>
<span id="L1707"><span class="lineNum">    1707</span>              :                 // The max(0, ...) is defensive, in case the adjusted load is negative.</span>
<span id="L1708"><span class="lineNum">    1708</span>              :                 // Given that this is a most overloaded dim, the likelihood of the</span>
<span id="L1709"><span class="lineNum">    1709</span>              :                 // adjusted load being negative is very low.</span>
<span id="L1710"><span class="lineNum">    1710</span> <span class="tlaGNC">          55 :                 adjustedStoreLoadValue := max(0, ss.adjusted.load[topk.dim])</span></span>
<span id="L1711"><span class="lineNum">    1711</span> <span class="tlaGNC">          55 :                 threshold := LoadValue(float64(adjustedStoreLoadValue) * fraction)</span></span>
<span id="L1712"><span class="lineNum">    1712</span> <span class="tlaGNC">          55 :                 if ss.reportedSecondaryLoad[ReplicaCount] &gt; 0 {</span></span>
<span id="L1713"><span class="lineNum">    1713</span> <span class="tlaUNC">           0 :                         // Allow all ranges above 90% of the mean. This is quite arbitrary.</span></span>
<span id="L1714"><span class="lineNum">    1714</span> <span class="tlaUNC">           0 :                         meanLoad := (adjustedStoreLoadValue * 9) / (ss.reportedSecondaryLoad[ReplicaCount] * 10)</span></span>
<span id="L1715"><span class="lineNum">    1715</span> <span class="tlaUNC">           0 :                         threshold = min(meanLoad, threshold)</span></span>
<span id="L1716"><span class="lineNum">    1716</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L1717"><span class="lineNum">    1717</span> <span class="tlaGNC">          55 :                 topk.threshold = threshold</span></span>
<span id="L1718"><span class="lineNum">    1718</span>              :         }</span>
<span id="L1719"><span class="lineNum">    1719</span>              :         // NB: localss.adjusted.replicas is already adjusted for ongoing changes,</span>
<span id="L1720"><span class="lineNum">    1720</span>              :         // which may be undone. For example, if s1 is the local store, and it is</span>
<span id="L1721"><span class="lineNum">    1721</span>              :         // transferring its replica for range r1 to remote store s2, then</span>
<span id="L1722"><span class="lineNum">    1722</span>              :         // localss.adjusted.replicas will not have r1. This is fine in that s1</span>
<span id="L1723"><span class="lineNum">    1723</span>              :         // should not be making more decisions about r1. If the change is undone</span>
<span id="L1724"><span class="lineNum">    1724</span>              :         // later, we will again compute the top-k, which will consider r1, before</span>
<span id="L1725"><span class="lineNum">    1725</span>              :         // computing new changes (due to REQUIREMENT(change-computation)).</span>
<span id="L1726"><span class="lineNum">    1726</span> <span class="tlaGNC">          26 :         for rangeID, state := range localss.adjusted.replicas {</span></span>
<span id="L1727"><span class="lineNum">    1727</span> <span class="tlaGNC">          26 :                 if !state.IsLeaseholder {</span></span>
<span id="L1728"><span class="lineNum">    1728</span> <span class="tlaUNC">           0 :                         // We may have transferred the lease away previously but still have a</span></span>
<span id="L1729"><span class="lineNum">    1729</span> <span class="tlaUNC">           0 :                         // replica. We don't want to add this replica to the topKReplicas as it</span></span>
<span id="L1730"><span class="lineNum">    1730</span> <span class="tlaUNC">           0 :                         // controls which ranges are eligible to be shed. When no longer the</span></span>
<span id="L1731"><span class="lineNum">    1731</span> <span class="tlaUNC">           0 :                         // leaseholder, we cannot shed a replica or lease.</span></span>
<span id="L1732"><span class="lineNum">    1732</span> <span class="tlaUNC">           0 :                         //</span></span>
<span id="L1733"><span class="lineNum">    1733</span> <span class="tlaUNC">           0 :                         // NB: this should only happen when the lease transfer has begun, but</span></span>
<span id="L1734"><span class="lineNum">    1734</span> <span class="tlaUNC">           0 :                         // not yet completed. Once completed, this store will not have this</span></span>
<span id="L1735"><span class="lineNum">    1735</span> <span class="tlaUNC">           0 :                         // range in its set of replicas since there can be only one replica of a</span></span>
<span id="L1736"><span class="lineNum">    1736</span> <span class="tlaUNC">           0 :                         // range on a node, and clusterState only maintains ranges for which</span></span>
<span id="L1737"><span class="lineNum">    1737</span> <span class="tlaUNC">           0 :                         // some local store is a leaseholder.</span></span>
<span id="L1738"><span class="lineNum">    1738</span> <span class="tlaUNC">           0 :                         continue</span></span>
<span id="L1739"><span class="lineNum">    1739</span>              :                 }</span>
<span id="L1740"><span class="lineNum">    1740</span> <span class="tlaGNC">          26 :                 rs := cs.ranges[rangeID]</span></span>
<span id="L1741"><span class="lineNum">    1741</span> <span class="tlaGNC">          26 :                 // NB: rs.replicas is already adjusted for ongoing changes. For</span></span>
<span id="L1742"><span class="lineNum">    1742</span> <span class="tlaGNC">          26 :                 // example, if s10 is a remote replica for range r1, which is being</span></span>
<span id="L1743"><span class="lineNum">    1743</span> <span class="tlaGNC">          26 :                 // transferred to another store s11, s10 will not see r1 below. We</span></span>
<span id="L1744"><span class="lineNum">    1744</span> <span class="tlaGNC">          26 :                 // make this choice to avoid cluttering the top-k for s10 with</span></span>
<span id="L1745"><span class="lineNum">    1745</span> <span class="tlaGNC">          26 :                 // replicas that are going away. If it is undone, r1 will not be in</span></span>
<span id="L1746"><span class="lineNum">    1746</span> <span class="tlaGNC">          26 :                 // the top-k for s10, but due to REQUIREMENT(change-computation), a</span></span>
<span id="L1747"><span class="lineNum">    1747</span> <span class="tlaGNC">          26 :                 // new authoritative state will be provided and the top-k recomputed,</span></span>
<span id="L1748"><span class="lineNum">    1748</span> <span class="tlaGNC">          26 :                 // before computing any new changes.</span></span>
<span id="L1749"><span class="lineNum">    1749</span> <span class="tlaGNC">          50 :                 for _, replica := range rs.replicas {</span></span>
<span id="L1750"><span class="lineNum">    1750</span> <span class="tlaGNC">          50 :                         typ := replica.ReplicaState.ReplicaType.ReplicaType</span></span>
<span id="L1751"><span class="lineNum">    1751</span> <span class="tlaGNC">          50 :                         if isVoter(typ) || isNonVoter(typ) {</span></span>
<span id="L1752"><span class="lineNum">    1752</span> <span class="tlaGNC">          50 :                                 ss := cs.stores[replica.StoreID]</span></span>
<span id="L1753"><span class="lineNum">    1753</span> <span class="tlaGNC">          50 :                                 topk := ss.adjusted.topKRanges[msg.StoreID]</span></span>
<span id="L1754"><span class="lineNum">    1754</span> <span class="tlaGNC">          50 :                                 switch topk.dim {</span></span>
<span id="L1755"><span class="lineNum">    1755</span> <span class="tlaGNC">          26 :                                 case CPURate:</span></span>
<span id="L1756"><span class="lineNum">    1756</span> <span class="tlaGNC">          26 :                                         l := rs.load.Load[CPURate]</span></span>
<span id="L1757"><span class="lineNum">    1757</span> <span class="tlaGNC">          26 :                                         if !replica.ReplicaState.IsLeaseholder {</span></span>
<span id="L1758"><span class="lineNum">    1758</span> <span class="tlaGNC">           5 :                                                 l = rs.load.RaftCPU</span></span>
<span id="L1759"><span class="lineNum">    1759</span> <span class="tlaGNC">           5 :                                         }</span></span>
<span id="L1760"><span class="lineNum">    1760</span> <span class="tlaGNC">          26 :                                         topk.addReplica(ctx, rangeID, l, replica.StoreID, msg.StoreID)</span></span>
<span id="L1761"><span class="lineNum">    1761</span> <span class="tlaGNC">          10 :                                 case WriteBandwidth:</span></span>
<span id="L1762"><span class="lineNum">    1762</span> <span class="tlaGNC">          10 :                                         topk.addReplica(ctx, rangeID, rs.load.Load[WriteBandwidth], replica.StoreID, msg.StoreID)</span></span>
<span id="L1763"><span class="lineNum">    1763</span> <span class="tlaGNC">          14 :                                 case ByteSize:</span></span>
<span id="L1764"><span class="lineNum">    1764</span> <span class="tlaGNC">          14 :                                         topk.addReplica(ctx, rangeID, rs.load.Load[ByteSize], replica.StoreID, msg.StoreID)</span></span>
<span id="L1765"><span class="lineNum">    1765</span>              :                                 }</span>
<span id="L1766"><span class="lineNum">    1766</span>              :                         }</span>
<span id="L1767"><span class="lineNum">    1767</span>              :                 }</span>
<span id="L1768"><span class="lineNum">    1768</span>              :         }</span>
<span id="L1769"><span class="lineNum">    1769</span> <span class="tlaGNC">          55 :         for _, ss := range cs.stores {</span></span>
<span id="L1770"><span class="lineNum">    1770</span> <span class="tlaGNC">          55 :                 topk := ss.adjusted.topKRanges[msg.StoreID]</span></span>
<span id="L1771"><span class="lineNum">    1771</span> <span class="tlaGNC">          55 :                 topk.doneInit()</span></span>
<span id="L1772"><span class="lineNum">    1772</span> <span class="tlaGNC">          55 :         }</span></span>
<span id="L1773"><span class="lineNum">    1773</span>              : </span>
<span id="L1774"><span class="lineNum">    1774</span>              : }</span>
<span id="L1775"><span class="lineNum">    1775</span>              : </span>
<span id="L1776"><span class="lineNum">    1776</span>              : // If the pending replica change does not happen within this GC duration, we</span>
<span id="L1777"><span class="lineNum">    1777</span>              : // forget it in the data-structure.</span>
<span id="L1778"><span class="lineNum">    1778</span>              : const pendingReplicaChangeGCDuration = 5 * time.Minute</span>
<span id="L1779"><span class="lineNum">    1779</span>              : </span>
<span id="L1780"><span class="lineNum">    1780</span>              : // If the pending lease transfer does not happen within this GC duration, we</span>
<span id="L1781"><span class="lineNum">    1781</span>              : // forget it in the data-structure.</span>
<span id="L1782"><span class="lineNum">    1782</span>              : const pendingLeaseTransferGCDuration = 1 * time.Minute</span>
<span id="L1783"><span class="lineNum">    1783</span>              : </span>
<span id="L1784"><span class="lineNum">    1784</span>              : // partiallyEnactedGCDuration is the duration after which a pending change is</span>
<span id="L1785"><span class="lineNum">    1785</span>              : // GC'd if some other change that was part of the same decision has been</span>
<span id="L1786"><span class="lineNum">    1786</span>              : // enacted, and this duration has elapsed since that enactment. This is</span>
<span id="L1787"><span class="lineNum">    1787</span>              : // shorter than the normal pendingReplicaChangeGCDuration, since we want to</span>
<span id="L1788"><span class="lineNum">    1788</span>              : // clean up such partially enacted changes faster. Long-running decisions are</span>
<span id="L1789"><span class="lineNum">    1789</span>              : // those that involve a new range snapshot being sent, and that is the first</span>
<span id="L1790"><span class="lineNum">    1790</span>              : // change that is seen as enacted. Subsequent ones should be fast.</span>
<span id="L1791"><span class="lineNum">    1791</span>              : const partiallyEnactedGCDuration = 30 * time.Second</span>
<span id="L1792"><span class="lineNum">    1792</span>              : </span>
<span id="L1793"><span class="lineNum">    1793</span>              : // Called periodically by allocator.</span>
<span id="L1794"><span class="lineNum">    1794</span> <span class="tlaGNC">          45 : func (cs *clusterState) gcPendingChanges(now time.Time) {</span></span>
<span id="L1795"><span class="lineNum">    1795</span> <span class="tlaGNC">          45 :         var rangesWithChanges map[roachpb.RangeID]struct{}</span></span>
<span id="L1796"><span class="lineNum">    1796</span> <span class="tlaGNC">          45 :         for _, pendingChange := range cs.pendingChanges {</span></span>
<span id="L1797"><span class="lineNum">    1797</span> <span class="tlaGNC">          25 :                 if rangesWithChanges == nil {</span></span>
<span id="L1798"><span class="lineNum">    1798</span> <span class="tlaGNC">          16 :                         rangesWithChanges = make(map[roachpb.RangeID]struct{})</span></span>
<span id="L1799"><span class="lineNum">    1799</span> <span class="tlaGNC">          16 :                 }</span></span>
<span id="L1800"><span class="lineNum">    1800</span> <span class="tlaGNC">          25 :                 rangesWithChanges[pendingChange.rangeID] = struct{}{}</span></span>
<span id="L1801"><span class="lineNum">    1801</span>              :         }</span>
<span id="L1802"><span class="lineNum">    1802</span> <span class="tlaGNC">          45 :         for rangeID := range rangesWithChanges {</span></span>
<span id="L1803"><span class="lineNum">    1803</span> <span class="tlaGNC">          16 :                 rs, ok := cs.ranges[rangeID]</span></span>
<span id="L1804"><span class="lineNum">    1804</span> <span class="tlaGNC">          16 :                 if !ok {</span></span>
<span id="L1805"><span class="lineNum">    1805</span> <span class="tlaUNC">           0 :                         panic(errors.AssertionFailedf(&quot;range %v not found in cluster state&quot;, rangeID))</span></span>
<span id="L1806"><span class="lineNum">    1806</span>              :                 }</span>
<span id="L1807"><span class="lineNum">    1807</span>              : </span>
<span id="L1808"><span class="lineNum">    1808</span>              :                 // Unlike normal GC that reverts changes, we want to discard these pending</span>
<span id="L1809"><span class="lineNum">    1809</span>              :                 // changes. Do nothing here; processStoreLeaseholderMsgInternal will later</span>
<span id="L1810"><span class="lineNum">    1810</span>              :                 // detect and discard these pending changes. Note that</span>
<span id="L1811"><span class="lineNum">    1811</span>              :                 // processStoreLeaseholderMsgInternal will not revert the pending load</span>
<span id="L1812"><span class="lineNum">    1812</span>              :                 // change.</span>
<span id="L1813"><span class="lineNum">    1813</span> <span class="tlaGNC">          16 :                 if rs.pendingChangeNoRollback {</span></span>
<span id="L1814"><span class="lineNum">    1814</span> <span class="tlaGNC">           6 :                         continue</span></span>
<span id="L1815"><span class="lineNum">    1815</span>              :                 }</span>
<span id="L1816"><span class="lineNum">    1816</span> <span class="tlaGNC">          10 :                 if len(rs.pendingChanges) == 0 {</span></span>
<span id="L1817"><span class="lineNum">    1817</span> <span class="tlaUNC">           0 :                         panic(errors.AssertionFailedf(&quot;no pending changes in range %v&quot;, rangeID))</span></span>
<span id="L1818"><span class="lineNum">    1818</span>              :                 }</span>
<span id="L1819"><span class="lineNum">    1819</span> <span class="tlaGNC">          10 :                 gcTime := rs.pendingChanges[0].gcTime</span></span>
<span id="L1820"><span class="lineNum">    1820</span> <span class="tlaGNC">          10 :                 if !gcTime.Before(now) {</span></span>
<span id="L1821"><span class="lineNum">    1821</span> <span class="tlaGNC">           9 :                         continue</span></span>
<span id="L1822"><span class="lineNum">    1822</span>              :                 }</span>
<span id="L1823"><span class="lineNum">    1823</span> <span class="tlaGNC">           1 :                 if err := cs.preCheckOnUndoReplicaChanges(PendingRangeChange{</span></span>
<span id="L1824"><span class="lineNum">    1824</span> <span class="tlaGNC">           1 :                         RangeID:               rangeID,</span></span>
<span id="L1825"><span class="lineNum">    1825</span> <span class="tlaGNC">           1 :                         pendingReplicaChanges: rs.pendingChanges,</span></span>
<span id="L1826"><span class="lineNum">    1826</span> <span class="tlaGNC">           1 :                 }); err != nil {</span></span>
<span id="L1827"><span class="lineNum">    1827</span> <span class="tlaUNC">           0 :                         panic(err)</span></span>
<span id="L1828"><span class="lineNum">    1828</span>              :                 }</span>
<span id="L1829"><span class="lineNum">    1829</span>              :                 // Gather the changeIDs, since calls to undoPendingChange modify the</span>
<span id="L1830"><span class="lineNum">    1830</span>              :                 // rs.pendingChanges slice.</span>
<span id="L1831"><span class="lineNum">    1831</span> <span class="tlaGNC">           1 :                 var changeIDs []changeID</span></span>
<span id="L1832"><span class="lineNum">    1832</span> <span class="tlaGNC">           2 :                 for _, pendingChange := range rs.pendingChanges {</span></span>
<span id="L1833"><span class="lineNum">    1833</span> <span class="tlaGNC">           2 :                         changeIDs = append(changeIDs, pendingChange.changeID)</span></span>
<span id="L1834"><span class="lineNum">    1834</span> <span class="tlaGNC">           2 :                 }</span></span>
<span id="L1835"><span class="lineNum">    1835</span> <span class="tlaGNC">           2 :                 for _, changeID := range changeIDs {</span></span>
<span id="L1836"><span class="lineNum">    1836</span> <span class="tlaGNC">           2 :                         cs.undoPendingChange(changeID)</span></span>
<span id="L1837"><span class="lineNum">    1837</span> <span class="tlaGNC">           2 :                 }</span></span>
<span id="L1838"><span class="lineNum">    1838</span>              :         }</span>
<span id="L1839"><span class="lineNum">    1839</span>              : }</span>
<span id="L1840"><span class="lineNum">    1840</span>              : </span>
<span id="L1841"><span class="lineNum">    1841</span> <span class="tlaGNC">           9 : func (cs *clusterState) pendingChangeEnacted(cid changeID, enactedAt time.Time) {</span></span>
<span id="L1842"><span class="lineNum">    1842</span> <span class="tlaGNC">           9 :         change, ok := cs.pendingChanges[cid]</span></span>
<span id="L1843"><span class="lineNum">    1843</span> <span class="tlaGNC">           9 :         if !ok {</span></span>
<span id="L1844"><span class="lineNum">    1844</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(&quot;change %v not found %v&quot;, cid, printMapPendingChanges(cs.pendingChanges)))</span></span>
<span id="L1845"><span class="lineNum">    1845</span>              :         }</span>
<span id="L1846"><span class="lineNum">    1846</span> <span class="tlaGNC">           9 :         change.enactedAtTime = enactedAt</span></span>
<span id="L1847"><span class="lineNum">    1847</span> <span class="tlaGNC">           9 :         rs, ok := cs.ranges[change.rangeID]</span></span>
<span id="L1848"><span class="lineNum">    1848</span> <span class="tlaGNC">           9 :         if !ok {</span></span>
<span id="L1849"><span class="lineNum">    1849</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(&quot;range %v not found in cluster state&quot;, change.rangeID))</span></span>
<span id="L1850"><span class="lineNum">    1850</span>              :         }</span>
<span id="L1851"><span class="lineNum">    1851</span>              : </span>
<span id="L1852"><span class="lineNum">    1852</span> <span class="tlaGNC">           9 :         rs.removePendingChangeTracking(change.changeID)</span></span>
<span id="L1853"><span class="lineNum">    1853</span> <span class="tlaGNC">           9 :         delete(cs.pendingChanges, change.changeID)</span></span>
<span id="L1854"><span class="lineNum">    1854</span>              : }</span>
<span id="L1855"><span class="lineNum">    1855</span>              : </span>
<span id="L1856"><span class="lineNum">    1856</span>              : // undoPendingChange reverses the change with ID cid.</span>
<span id="L1857"><span class="lineNum">    1857</span>              : //</span>
<span id="L1858"><span class="lineNum">    1858</span>              : // REQUIRES: the change is not marked as no-rollback.</span>
<span id="L1859"><span class="lineNum">    1859</span> <span class="tlaGNC">           6 : func (cs *clusterState) undoPendingChange(cid changeID) {</span></span>
<span id="L1860"><span class="lineNum">    1860</span> <span class="tlaGNC">           6 :         change, ok := cs.pendingChanges[cid]</span></span>
<span id="L1861"><span class="lineNum">    1861</span> <span class="tlaGNC">           6 :         if !ok {</span></span>
<span id="L1862"><span class="lineNum">    1862</span> <span class="tlaGNC">           1 :                 panic(errors.AssertionFailedf(&quot;change %v not found %v&quot;, cid, printMapPendingChanges(cs.pendingChanges)))</span></span>
<span id="L1863"><span class="lineNum">    1863</span>              :         }</span>
<span id="L1864"><span class="lineNum">    1864</span> <span class="tlaGNC">           5 :         rs, ok := cs.ranges[change.rangeID]</span></span>
<span id="L1865"><span class="lineNum">    1865</span> <span class="tlaGNC">           5 :         if !ok {</span></span>
<span id="L1866"><span class="lineNum">    1866</span> <span class="tlaUNC">           0 :                 panic(errors.AssertionFailedf(&quot;range %v not found in cluster state&quot;, change.rangeID))</span></span>
<span id="L1867"><span class="lineNum">    1867</span>              :         }</span>
<span id="L1868"><span class="lineNum">    1868</span> <span class="tlaGNC">           5 :         if rs.pendingChangeNoRollback {</span></span>
<span id="L1869"><span class="lineNum">    1869</span> <span class="tlaGNC">           1 :                 // One cannot undo changes once no-rollback is true.</span></span>
<span id="L1870"><span class="lineNum">    1870</span> <span class="tlaGNC">           1 :                 panic(errors.AssertionFailedf(&quot;pending change is marked as no-rollback&quot;))</span></span>
<span id="L1871"><span class="lineNum">    1871</span>              :         }</span>
<span id="L1872"><span class="lineNum">    1872</span>              :         // Wipe the analyzed constraints, as the range has changed.</span>
<span id="L1873"><span class="lineNum">    1873</span> <span class="tlaGNC">           4 :         rs.clearAnalyzedConstraints()</span></span>
<span id="L1874"><span class="lineNum">    1874</span> <span class="tlaGNC">           4 :         rs.lastFailedChange = cs.ts.Now()</span></span>
<span id="L1875"><span class="lineNum">    1875</span> <span class="tlaGNC">           4 :         // Undo the change delta as well as the replica change and remove the pending</span></span>
<span id="L1876"><span class="lineNum">    1876</span> <span class="tlaGNC">           4 :         // change from all tracking (range, store, cluster).</span></span>
<span id="L1877"><span class="lineNum">    1877</span> <span class="tlaGNC">           4 :         cs.undoReplicaChange(change.ReplicaChange)</span></span>
<span id="L1878"><span class="lineNum">    1878</span> <span class="tlaGNC">           4 :         rs.removePendingChangeTracking(cid)</span></span>
<span id="L1879"><span class="lineNum">    1879</span> <span class="tlaGNC">           4 :         delete(cs.stores[change.target.StoreID].adjusted.loadPendingChanges, change.changeID)</span></span>
<span id="L1880"><span class="lineNum">    1880</span> <span class="tlaGNC">           4 :         delete(cs.pendingChanges, change.changeID)</span></span>
<span id="L1881"><span class="lineNum">    1881</span>              : }</span>
<span id="L1882"><span class="lineNum">    1882</span>              : </span>
<span id="L1883"><span class="lineNum">    1883</span> <span class="tlaGNC">           1 : func printMapPendingChanges(changes map[changeID]*pendingReplicaChange) string {</span></span>
<span id="L1884"><span class="lineNum">    1884</span> <span class="tlaGNC">           1 :         var buf strings.Builder</span></span>
<span id="L1885"><span class="lineNum">    1885</span> <span class="tlaGNC">           1 :         fmt.Fprintf(&amp;buf, &quot;pending(%d)&quot;, len(changes))</span></span>
<span id="L1886"><span class="lineNum">    1886</span> <span class="tlaGNC">           1 :         for k, v := range changes {</span></span>
<span id="L1887"><span class="lineNum">    1887</span> <span class="tlaGNC">           1 :                 fmt.Fprintf(&amp;buf, &quot;\nchange-id=%d store-id=%v node-id=%v range-id=%v load-delta=%v start=%v&quot;,</span></span>
<span id="L1888"><span class="lineNum">    1888</span> <span class="tlaGNC">           1 :                         k, v.target.StoreID, v.target.NodeID, v.rangeID,</span></span>
<span id="L1889"><span class="lineNum">    1889</span> <span class="tlaGNC">           1 :                         v.loadDelta, v.startTime,</span></span>
<span id="L1890"><span class="lineNum">    1890</span> <span class="tlaGNC">           1 :                 )</span></span>
<span id="L1891"><span class="lineNum">    1891</span> <span class="tlaGNC">           1 :                 if !(v.enactedAtTime == time.Time{}) {</span></span>
<span id="L1892"><span class="lineNum">    1892</span> <span class="tlaUNC">           0 :                         fmt.Fprintf(&amp;buf, &quot; enacted=%v&quot;,</span></span>
<span id="L1893"><span class="lineNum">    1893</span> <span class="tlaUNC">           0 :                                 v.enactedAtTime)</span></span>
<span id="L1894"><span class="lineNum">    1894</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L1895"><span class="lineNum">    1895</span>              :         }</span>
<span id="L1896"><span class="lineNum">    1896</span> <span class="tlaGNC">           1 :         return buf.String()</span></span>
<span id="L1897"><span class="lineNum">    1897</span>              : }</span>
<span id="L1898"><span class="lineNum">    1898</span>              : </span>
<span id="L1899"><span class="lineNum">    1899</span>              : // addPendingRangeChange takes a range change containing a set of replica</span>
<span id="L1900"><span class="lineNum">    1900</span>              : // changes, and applies the changes as pending. The application updates the</span>
<span id="L1901"><span class="lineNum">    1901</span>              : // adjusted load, tracked pending changes and changeIDs to reflect the pending</span>
<span id="L1902"><span class="lineNum">    1902</span>              : // application. It updates the *pendingReplicaChanges inside the change.</span>
<span id="L1903"><span class="lineNum">    1903</span>              : //</span>
<span id="L1904"><span class="lineNum">    1904</span>              : // REQUIRES: all the replica changes are to the same range, and that the range</span>
<span id="L1905"><span class="lineNum">    1905</span>              : // has no pending changes.</span>
<span id="L1906"><span class="lineNum">    1906</span> <span class="tlaGNC">           9 : func (cs *clusterState) addPendingRangeChange(change PendingRangeChange) {</span></span>
<span id="L1907"><span class="lineNum">    1907</span> <span class="tlaGNC">           9 :         if len(change.pendingReplicaChanges) == 0 {</span></span>
<span id="L1908"><span class="lineNum">    1908</span> <span class="tlaUNC">           0 :                 return</span></span>
<span id="L1909"><span class="lineNum">    1909</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L1910"><span class="lineNum">    1910</span> <span class="tlaGNC">           9 :         rangeID := change.RangeID</span></span>
<span id="L1911"><span class="lineNum">    1911</span> <span class="tlaGNC">          17 :         for _, c := range change.pendingReplicaChanges {</span></span>
<span id="L1912"><span class="lineNum">    1912</span> <span class="tlaGNC">          17 :                 if c.rangeID != rangeID {</span></span>
<span id="L1913"><span class="lineNum">    1913</span> <span class="tlaUNC">           0 :                         panic(errors.AssertionFailedf(&quot;all changes must be to the same range %d != %d&quot;,</span></span>
<span id="L1914"><span class="lineNum">    1914</span> <span class="tlaUNC">           0 :                                 c.rangeID, rangeID))</span></span>
<span id="L1915"><span class="lineNum">    1915</span>              :                 }</span>
<span id="L1916"><span class="lineNum">    1916</span>              :         }</span>
<span id="L1917"><span class="lineNum">    1917</span> <span class="tlaGNC">           9 :         rs := cs.ranges[rangeID]</span></span>
<span id="L1918"><span class="lineNum">    1918</span> <span class="tlaGNC">           9 :         if rs != nil &amp;&amp; len(rs.pendingChanges) &gt; 0 {</span></span>
<span id="L1919"><span class="lineNum">    1919</span> <span class="tlaUNC">           0 :                 panic(errors.AssertionFailedf(&quot;range r%v already has pending changes: %d&quot;,</span></span>
<span id="L1920"><span class="lineNum">    1920</span> <span class="tlaUNC">           0 :                         rangeID, len(rs.pendingChanges)))</span></span>
<span id="L1921"><span class="lineNum">    1921</span>              :         }</span>
<span id="L1922"><span class="lineNum">    1922</span>              :         // NB: rs != nil is also required, but we also check that in a method called</span>
<span id="L1923"><span class="lineNum">    1923</span>              :         // below.</span>
<span id="L1924"><span class="lineNum">    1924</span>              : </span>
<span id="L1925"><span class="lineNum">    1925</span> <span class="tlaGNC">           9 :         gcDuration := pendingReplicaChangeGCDuration</span></span>
<span id="L1926"><span class="lineNum">    1926</span> <span class="tlaGNC">           9 :         if change.isTransferLease() {</span></span>
<span id="L1927"><span class="lineNum">    1927</span> <span class="tlaGNC">           2 :                 // Only the lease is being transferred.</span></span>
<span id="L1928"><span class="lineNum">    1928</span> <span class="tlaGNC">           2 :                 gcDuration = pendingLeaseTransferGCDuration</span></span>
<span id="L1929"><span class="lineNum">    1929</span> <span class="tlaGNC">           2 :         }</span></span>
<span id="L1930"><span class="lineNum">    1930</span> <span class="tlaGNC">           9 :         pendingChanges := change.pendingReplicaChanges</span></span>
<span id="L1931"><span class="lineNum">    1931</span> <span class="tlaGNC">           9 :         now := cs.ts.Now()</span></span>
<span id="L1932"><span class="lineNum">    1932</span> <span class="tlaGNC">          17 :         for _, pendingChange := range pendingChanges {</span></span>
<span id="L1933"><span class="lineNum">    1933</span> <span class="tlaGNC">          17 :                 cs.applyReplicaChange(pendingChange.ReplicaChange, true)</span></span>
<span id="L1934"><span class="lineNum">    1934</span> <span class="tlaGNC">          17 :                 cs.changeSeqGen++</span></span>
<span id="L1935"><span class="lineNum">    1935</span> <span class="tlaGNC">          17 :                 cid := cs.changeSeqGen</span></span>
<span id="L1936"><span class="lineNum">    1936</span> <span class="tlaGNC">          17 :                 pendingChange.changeID = cid</span></span>
<span id="L1937"><span class="lineNum">    1937</span> <span class="tlaGNC">          17 :                 pendingChange.startTime = now</span></span>
<span id="L1938"><span class="lineNum">    1938</span> <span class="tlaGNC">          17 :                 pendingChange.gcTime = now.Add(gcDuration)</span></span>
<span id="L1939"><span class="lineNum">    1939</span> <span class="tlaGNC">          17 :                 pendingChange.enactedAtTime = time.Time{}</span></span>
<span id="L1940"><span class="lineNum">    1940</span> <span class="tlaGNC">          17 :                 storeState := cs.stores[pendingChange.target.StoreID]</span></span>
<span id="L1941"><span class="lineNum">    1941</span> <span class="tlaGNC">          17 :                 rangeState := cs.ranges[rangeID]</span></span>
<span id="L1942"><span class="lineNum">    1942</span> <span class="tlaGNC">          17 :                 cs.pendingChanges[cid] = pendingChange</span></span>
<span id="L1943"><span class="lineNum">    1943</span> <span class="tlaGNC">          17 :                 storeState.adjusted.loadPendingChanges[cid] = pendingChange</span></span>
<span id="L1944"><span class="lineNum">    1944</span> <span class="tlaGNC">          17 :                 rangeState.pendingChanges = append(rangeState.pendingChanges, pendingChange)</span></span>
<span id="L1945"><span class="lineNum">    1945</span> <span class="tlaGNC">          17 :                 rangeState.pendingChangeNoRollback = false</span></span>
<span id="L1946"><span class="lineNum">    1946</span> <span class="tlaGNC">          17 :                 log.KvDistribution.VInfof(context.Background(), 3,</span></span>
<span id="L1947"><span class="lineNum">    1947</span> <span class="tlaGNC">          17 :                         &quot;addPendingRangeChange: change_id=%v, range_id=%v, change=%v&quot;,</span></span>
<span id="L1948"><span class="lineNum">    1948</span> <span class="tlaGNC">          17 :                         cid, rangeID, pendingChange.ReplicaChange)</span></span>
<span id="L1949"><span class="lineNum">    1949</span> <span class="tlaGNC">          17 :                 pendingChanges = append(pendingChanges, pendingChange)</span></span>
<span id="L1950"><span class="lineNum">    1950</span> <span class="tlaGNC">          17 :         }</span></span>
<span id="L1951"><span class="lineNum">    1951</span>              : }</span>
<span id="L1952"><span class="lineNum">    1952</span>              : </span>
<span id="L1953"><span class="lineNum">    1953</span>              : // preCheckOnApplyReplicaChanges does some validation of the changes being</span>
<span id="L1954"><span class="lineNum">    1954</span>              : // proposed. It ensures the range is known and has no pending changes already.</span>
<span id="L1955"><span class="lineNum">    1955</span>              : //</span>
<span id="L1956"><span class="lineNum">    1956</span>              : // It only needs to be called for (a) new changes that are being proposed, or</span>
<span id="L1957"><span class="lineNum">    1957</span>              : // (b) when we have reset the rangeState.replicas using a StoreLeaseholderMsg</span>
<span id="L1958"><span class="lineNum">    1958</span>              : // and we have some previously proposed pending changes that have not been</span>
<span id="L1959"><span class="lineNum">    1959</span>              : // enacted yet, and we want to re-validate them before adjusting</span>
<span id="L1960"><span class="lineNum">    1960</span>              : // rangeState.replicas.</span>
<span id="L1961"><span class="lineNum">    1961</span>              : //</span>
<span id="L1962"><span class="lineNum">    1962</span>              : // For a removal, it validates that the replica exists. For non-removal, it</span>
<span id="L1963"><span class="lineNum">    1963</span>              : // blind applies the change without validating whether the current state is</span>
<span id="L1964"><span class="lineNum">    1964</span>              : // ReplicaChange.prev -- this blind application allows this pre-check to</span>
<span id="L1965"><span class="lineNum">    1965</span>              : // succeed when a ReplicaChange has been partially applied e.g. a replica has</span>
<span id="L1966"><span class="lineNum">    1966</span>              : // been added at a store, but it has not yet received the lease. Finally, it</span>
<span id="L1967"><span class="lineNum">    1967</span>              : // checks that after the changes are applied there is exactly one leaseholder.</span>
<span id="L1968"><span class="lineNum">    1968</span>              : // It returns a non-nil error if any of these checks fail.</span>
<span id="L1969"><span class="lineNum">    1969</span> <span class="tlaGNC">           6 : func (cs *clusterState) preCheckOnApplyReplicaChanges(rangeChange PendingRangeChange) error {</span></span>
<span id="L1970"><span class="lineNum">    1970</span> <span class="tlaGNC">           6 :         if len(rangeChange.pendingReplicaChanges) == 0 {</span></span>
<span id="L1971"><span class="lineNum">    1971</span> <span class="tlaUNC">           0 :                 return nil</span></span>
<span id="L1972"><span class="lineNum">    1972</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L1973"><span class="lineNum">    1973</span> <span class="tlaGNC">           6 :         rangeID := rangeChange.RangeID</span></span>
<span id="L1974"><span class="lineNum">    1974</span> <span class="tlaGNC">           6 :         curr, ok := cs.ranges[rangeID]</span></span>
<span id="L1975"><span class="lineNum">    1975</span> <span class="tlaGNC">           6 :         // Return early if range already has some pending changes or the range does not exist.</span></span>
<span id="L1976"><span class="lineNum">    1976</span> <span class="tlaGNC">           6 :         if !ok {</span></span>
<span id="L1977"><span class="lineNum">    1977</span> <span class="tlaUNC">           0 :                 return errors.Errorf(&quot;range does not exist in cluster state&quot;)</span></span>
<span id="L1978"><span class="lineNum">    1978</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L1979"><span class="lineNum">    1979</span> <span class="tlaGNC">           6 :         if len(curr.pendingChanges) &gt; 0 {</span></span>
<span id="L1980"><span class="lineNum">    1980</span> <span class="tlaUNC">           0 :                 return errors.Errorf(&quot;range %d has pending changes: %v&quot;,</span></span>
<span id="L1981"><span class="lineNum">    1981</span> <span class="tlaUNC">           0 :                         rangeID, curr.pendingChanges)</span></span>
<span id="L1982"><span class="lineNum">    1982</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L1983"><span class="lineNum">    1983</span>              : </span>
<span id="L1984"><span class="lineNum">    1984</span>              :         // Make a deep copy of the range state</span>
<span id="L1985"><span class="lineNum">    1985</span> <span class="tlaGNC">           6 :         copiedCurr := rangeState{</span></span>
<span id="L1986"><span class="lineNum">    1986</span> <span class="tlaGNC">           6 :                 replicas: append([]StoreIDAndReplicaState{}, curr.replicas...),</span></span>
<span id="L1987"><span class="lineNum">    1987</span> <span class="tlaGNC">           6 :         }</span></span>
<span id="L1988"><span class="lineNum">    1988</span> <span class="tlaGNC">           9 :         for _, change := range rangeChange.pendingReplicaChanges {</span></span>
<span id="L1989"><span class="lineNum">    1989</span> <span class="tlaGNC">           9 :                 // Check that all changes correspond to the same range. Panic otherwise.</span></span>
<span id="L1990"><span class="lineNum">    1990</span> <span class="tlaGNC">           9 :                 if change.rangeID != rangeID {</span></span>
<span id="L1991"><span class="lineNum">    1991</span> <span class="tlaUNC">           0 :                         panic(errors.AssertionFailedf(&quot;unexpected change rangeID %d != %d&quot;, change.rangeID, rangeID))</span></span>
<span id="L1992"><span class="lineNum">    1992</span>              :                 }</span>
<span id="L1993"><span class="lineNum">    1993</span> <span class="tlaGNC">           9 :                 if change.isRemoval() {</span></span>
<span id="L1994"><span class="lineNum">    1994</span> <span class="tlaGNC">           5 :                         if err := copiedCurr.removeReplica(change.target.StoreID); err != nil {</span></span>
<span id="L1995"><span class="lineNum">    1995</span> <span class="tlaUNC">           0 :                                 return err</span></span>
<span id="L1996"><span class="lineNum">    1996</span> <span class="tlaUNC">           0 :                         }</span></span>
<span id="L1997"><span class="lineNum">    1997</span> <span class="tlaGNC">           4 :                 } else if change.isAddition() || change.isUpdate() {</span></span>
<span id="L1998"><span class="lineNum">    1998</span> <span class="tlaGNC">           4 :                         // NB: see the blind apply comment on the method declaration.</span></span>
<span id="L1999"><span class="lineNum">    1999</span> <span class="tlaGNC">           4 :                         pendingRepl := StoreIDAndReplicaState{</span></span>
<span id="L2000"><span class="lineNum">    2000</span> <span class="tlaGNC">           4 :                                 StoreID: change.target.StoreID,</span></span>
<span id="L2001"><span class="lineNum">    2001</span> <span class="tlaGNC">           4 :                                 ReplicaState: ReplicaState{</span></span>
<span id="L2002"><span class="lineNum">    2002</span> <span class="tlaGNC">           4 :                                         ReplicaIDAndType: change.next,</span></span>
<span id="L2003"><span class="lineNum">    2003</span> <span class="tlaGNC">           4 :                                 },</span></span>
<span id="L2004"><span class="lineNum">    2004</span> <span class="tlaGNC">           4 :                         }</span></span>
<span id="L2005"><span class="lineNum">    2005</span> <span class="tlaGNC">           4 :                         copiedCurr.setReplica(pendingRepl)</span></span>
<span id="L2006"><span class="lineNum">    2006</span> <span class="tlaGNC">           4 :                 } else {</span></span>
<span id="L2007"><span class="lineNum">    2007</span> <span class="tlaUNC">           0 :                         panic(errors.AssertionFailedf(&quot;unknown replica change %+v&quot;, change))</span></span>
<span id="L2008"><span class="lineNum">    2008</span>              :                 }</span>
<span id="L2009"><span class="lineNum">    2009</span>              :         }</span>
<span id="L2010"><span class="lineNum">    2010</span>              :         // check on the final state of currCopy and whether it is valid</span>
<span id="L2011"><span class="lineNum">    2011</span> <span class="tlaGNC">           6 :         return replicaSetIsValid(copiedCurr.replicas)</span></span>
<span id="L2012"><span class="lineNum">    2012</span>              : }</span>
<span id="L2013"><span class="lineNum">    2013</span>              : </span>
<span id="L2014"><span class="lineNum">    2014</span>              : // preCheckOnUndoReplicaChanges does some validation of the changes being</span>
<span id="L2015"><span class="lineNum">    2015</span>              : // proposed for undo.</span>
<span id="L2016"><span class="lineNum">    2016</span>              : //</span>
<span id="L2017"><span class="lineNum">    2017</span>              : // REQUIRES: the rangeState.pendingChangeNoRollback is false.</span>
<span id="L2018"><span class="lineNum">    2018</span>              : //</span>
<span id="L2019"><span class="lineNum">    2019</span>              : // This method is defensive since if we always check against the current state</span>
<span id="L2020"><span class="lineNum">    2020</span>              : // before allowing a change to be added (including re-addition after a</span>
<span id="L2021"><span class="lineNum">    2021</span>              : // StoreLeaseholderMsg), we should never have invalidity during an undo, if</span>
<span id="L2022"><span class="lineNum">    2022</span>              : // all the changes are being undone.</span>
<span id="L2023"><span class="lineNum">    2023</span> <span class="tlaGNC">           1 : func (cs *clusterState) preCheckOnUndoReplicaChanges(rangeChange PendingRangeChange) error {</span></span>
<span id="L2024"><span class="lineNum">    2024</span> <span class="tlaGNC">           1 :         if len(rangeChange.pendingReplicaChanges) == 0 {</span></span>
<span id="L2025"><span class="lineNum">    2025</span> <span class="tlaUNC">           0 :                 return nil</span></span>
<span id="L2026"><span class="lineNum">    2026</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L2027"><span class="lineNum">    2027</span> <span class="tlaGNC">           1 :         rangeID := rangeChange.RangeID</span></span>
<span id="L2028"><span class="lineNum">    2028</span> <span class="tlaGNC">           1 :         curr, ok := cs.ranges[rangeID]</span></span>
<span id="L2029"><span class="lineNum">    2029</span> <span class="tlaGNC">           1 :         if !ok {</span></span>
<span id="L2030"><span class="lineNum">    2030</span> <span class="tlaUNC">           0 :                 return errors.Errorf(&quot;range %v does not exist in cluster state&quot;, rangeID)</span></span>
<span id="L2031"><span class="lineNum">    2031</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L2032"><span class="lineNum">    2032</span>              : </span>
<span id="L2033"><span class="lineNum">    2033</span> <span class="tlaGNC">           1 :         copiedCurr := &amp;rangeState{</span></span>
<span id="L2034"><span class="lineNum">    2034</span> <span class="tlaGNC">           1 :                 replicas: append([]StoreIDAndReplicaState{}, curr.replicas...),</span></span>
<span id="L2035"><span class="lineNum">    2035</span> <span class="tlaGNC">           1 :         }</span></span>
<span id="L2036"><span class="lineNum">    2036</span> <span class="tlaGNC">           2 :         for _, change := range rangeChange.pendingReplicaChanges {</span></span>
<span id="L2037"><span class="lineNum">    2037</span> <span class="tlaGNC">           2 :                 if change.rangeID != rangeID {</span></span>
<span id="L2038"><span class="lineNum">    2038</span> <span class="tlaUNC">           0 :                         panic(errors.AssertionFailedf(&quot;unexpected change rangeID %d != %d&quot;, change.rangeID, rangeID))</span></span>
<span id="L2039"><span class="lineNum">    2039</span>              :                 }</span>
<span id="L2040"><span class="lineNum">    2040</span>              :                 // TODO: for isRemoval it should check that the replica does not exist in</span>
<span id="L2041"><span class="lineNum">    2041</span>              :                 // copiedCurr. for isUpdate it should check that the replica exists in</span>
<span id="L2042"><span class="lineNum">    2042</span>              :                 // copiedCurr.</span>
<span id="L2043"><span class="lineNum">    2043</span> <span class="tlaGNC">           2 :                 if change.isRemoval() || change.isUpdate() {</span></span>
<span id="L2044"><span class="lineNum">    2044</span> <span class="tlaGNC">           1 :                         prevRepl := StoreIDAndReplicaState{</span></span>
<span id="L2045"><span class="lineNum">    2045</span> <span class="tlaGNC">           1 :                                 StoreID:      change.target.StoreID,</span></span>
<span id="L2046"><span class="lineNum">    2046</span> <span class="tlaGNC">           1 :                                 ReplicaState: change.prev,</span></span>
<span id="L2047"><span class="lineNum">    2047</span> <span class="tlaGNC">           1 :                         }</span></span>
<span id="L2048"><span class="lineNum">    2048</span> <span class="tlaGNC">           1 :                         copiedCurr.setReplica(prevRepl)</span></span>
<span id="L2049"><span class="lineNum">    2049</span> <span class="tlaGNC">           1 :                 } else if change.isAddition() {</span></span>
<span id="L2050"><span class="lineNum">    2050</span> <span class="tlaGNC">           1 :                         if err := copiedCurr.removeReplica(change.target.StoreID); err != nil {</span></span>
<span id="L2051"><span class="lineNum">    2051</span> <span class="tlaUNC">           0 :                                 return err</span></span>
<span id="L2052"><span class="lineNum">    2052</span> <span class="tlaUNC">           0 :                         }</span></span>
<span id="L2053"><span class="lineNum">    2053</span> <span class="tlaUNC">           0 :                 } else {</span></span>
<span id="L2054"><span class="lineNum">    2054</span> <span class="tlaUNC">           0 :                         panic(errors.AssertionFailedf(&quot;unknown replica change %+v&quot;, change))</span></span>
<span id="L2055"><span class="lineNum">    2055</span>              :                 }</span>
<span id="L2056"><span class="lineNum">    2056</span>              :         }</span>
<span id="L2057"><span class="lineNum">    2057</span> <span class="tlaGNC">           1 :         if err := replicaSetIsValid(copiedCurr.replicas); err != nil {</span></span>
<span id="L2058"><span class="lineNum">    2058</span> <span class="tlaUNC">           0 :                 return err</span></span>
<span id="L2059"><span class="lineNum">    2059</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L2060"><span class="lineNum">    2060</span> <span class="tlaGNC">           1 :         return nil</span></span>
<span id="L2061"><span class="lineNum">    2061</span>              : }</span>
<span id="L2062"><span class="lineNum">    2062</span>              : </span>
<span id="L2063"><span class="lineNum">    2063</span>              : // REQUIRES: the range and store are known to the allocator.</span>
<span id="L2064"><span class="lineNum">    2064</span> <span class="tlaGNC">          24 : func (cs *clusterState) applyReplicaChange(change ReplicaChange, applyLoadChange bool) {</span></span>
<span id="L2065"><span class="lineNum">    2065</span> <span class="tlaGNC">          24 :         storeState, ok := cs.stores[change.target.StoreID]</span></span>
<span id="L2066"><span class="lineNum">    2066</span> <span class="tlaGNC">          24 :         if !ok {</span></span>
<span id="L2067"><span class="lineNum">    2067</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(&quot;store %v not found in cluster state&quot;, change.target.StoreID))</span></span>
<span id="L2068"><span class="lineNum">    2068</span>              :         }</span>
<span id="L2069"><span class="lineNum">    2069</span> <span class="tlaGNC">          24 :         rangeState, ok := cs.ranges[change.rangeID]</span></span>
<span id="L2070"><span class="lineNum">    2070</span> <span class="tlaGNC">          24 :         if !ok {</span></span>
<span id="L2071"><span class="lineNum">    2071</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(&quot;range %v not found in cluster state&quot;, change.rangeID))</span></span>
<span id="L2072"><span class="lineNum">    2072</span>              :         }</span>
<span id="L2073"><span class="lineNum">    2073</span>              : </span>
<span id="L2074"><span class="lineNum">    2074</span> <span class="tlaGNC">          24 :         log.KvDistribution.VInfof(context.Background(), 2, &quot;applying replica change %v to range %d on store %d&quot;,</span></span>
<span id="L2075"><span class="lineNum">    2075</span> <span class="tlaGNC">          24 :                 change, change.rangeID, change.target.StoreID)</span></span>
<span id="L2076"><span class="lineNum">    2076</span> <span class="tlaGNC">          24 :         if change.isRemoval() {</span></span>
<span id="L2077"><span class="lineNum">    2077</span> <span class="tlaGNC">          12 :                 delete(storeState.adjusted.replicas, change.rangeID)</span></span>
<span id="L2078"><span class="lineNum">    2078</span> <span class="tlaGNC">          12 :                 if err := rangeState.removeReplica(change.target.StoreID); err != nil {</span></span>
<span id="L2079"><span class="lineNum">    2079</span> <span class="tlaUNC">           0 :                         panic(err)</span></span>
<span id="L2080"><span class="lineNum">    2080</span>              :                 }</span>
<span id="L2081"><span class="lineNum">    2081</span> <span class="tlaGNC">          12 :         } else if change.isAddition() {</span></span>
<span id="L2082"><span class="lineNum">    2082</span> <span class="tlaGNC">           8 :                 pendingRepl := StoreIDAndReplicaState{</span></span>
<span id="L2083"><span class="lineNum">    2083</span> <span class="tlaGNC">           8 :                         StoreID: change.target.StoreID,</span></span>
<span id="L2084"><span class="lineNum">    2084</span> <span class="tlaGNC">           8 :                         ReplicaState: ReplicaState{</span></span>
<span id="L2085"><span class="lineNum">    2085</span> <span class="tlaGNC">           8 :                                 ReplicaIDAndType: change.next,</span></span>
<span id="L2086"><span class="lineNum">    2086</span> <span class="tlaGNC">           8 :                         },</span></span>
<span id="L2087"><span class="lineNum">    2087</span> <span class="tlaGNC">           8 :                 }</span></span>
<span id="L2088"><span class="lineNum">    2088</span> <span class="tlaGNC">           8 :                 storeState.adjusted.replicas[change.rangeID] = pendingRepl.ReplicaState</span></span>
<span id="L2089"><span class="lineNum">    2089</span> <span class="tlaGNC">           8 :                 rangeState.setReplica(pendingRepl)</span></span>
<span id="L2090"><span class="lineNum">    2090</span> <span class="tlaGNC">           8 :         } else if change.isUpdate() {</span></span>
<span id="L2091"><span class="lineNum">    2091</span> <span class="tlaGNC">           4 :                 replState := storeState.adjusted.replicas[change.rangeID]</span></span>
<span id="L2092"><span class="lineNum">    2092</span> <span class="tlaGNC">           4 :                 replState.ReplicaIDAndType = change.next</span></span>
<span id="L2093"><span class="lineNum">    2093</span> <span class="tlaGNC">           4 :                 storeState.adjusted.replicas[change.rangeID] = replState</span></span>
<span id="L2094"><span class="lineNum">    2094</span> <span class="tlaGNC">           4 :                 rangeState.setReplica(StoreIDAndReplicaState{</span></span>
<span id="L2095"><span class="lineNum">    2095</span> <span class="tlaGNC">           4 :                         StoreID:      change.target.StoreID,</span></span>
<span id="L2096"><span class="lineNum">    2096</span> <span class="tlaGNC">           4 :                         ReplicaState: replState,</span></span>
<span id="L2097"><span class="lineNum">    2097</span> <span class="tlaGNC">           4 :                 })</span></span>
<span id="L2098"><span class="lineNum">    2098</span> <span class="tlaGNC">           4 :         } else {</span></span>
<span id="L2099"><span class="lineNum">    2099</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(&quot;unknown replica change %+v&quot;, change))</span></span>
<span id="L2100"><span class="lineNum">    2100</span>              :         }</span>
<span id="L2101"><span class="lineNum">    2101</span> <span class="tlaGNC">          24 :         if applyLoadChange {</span></span>
<span id="L2102"><span class="lineNum">    2102</span> <span class="tlaGNC">          17 :                 cs.applyChangeLoadDelta(change)</span></span>
<span id="L2103"><span class="lineNum">    2103</span> <span class="tlaGNC">          17 :         }</span></span>
<span id="L2104"><span class="lineNum">    2104</span>              : }</span>
<span id="L2105"><span class="lineNum">    2105</span>              : </span>
<span id="L2106"><span class="lineNum">    2106</span> <span class="tlaGNC">           4 : func (cs *clusterState) undoReplicaChange(change ReplicaChange) {</span></span>
<span id="L2107"><span class="lineNum">    2107</span> <span class="tlaGNC">           4 :         log.KvDistribution.Infof(context.Background(), &quot;undoing replica change %v to range %d on store %d&quot;,</span></span>
<span id="L2108"><span class="lineNum">    2108</span> <span class="tlaGNC">           4 :                 change, change.rangeID, change.target.StoreID)</span></span>
<span id="L2109"><span class="lineNum">    2109</span> <span class="tlaGNC">           4 :         rangeState := cs.ranges[change.rangeID]</span></span>
<span id="L2110"><span class="lineNum">    2110</span> <span class="tlaGNC">           4 :         storeState := cs.stores[change.target.StoreID]</span></span>
<span id="L2111"><span class="lineNum">    2111</span> <span class="tlaGNC">           4 :         if change.isRemoval() || change.isUpdate() {</span></span>
<span id="L2112"><span class="lineNum">    2112</span> <span class="tlaGNC">           3 :                 prevRepl := StoreIDAndReplicaState{</span></span>
<span id="L2113"><span class="lineNum">    2113</span> <span class="tlaGNC">           3 :                         StoreID:      change.target.StoreID,</span></span>
<span id="L2114"><span class="lineNum">    2114</span> <span class="tlaGNC">           3 :                         ReplicaState: change.prev,</span></span>
<span id="L2115"><span class="lineNum">    2115</span> <span class="tlaGNC">           3 :                 }</span></span>
<span id="L2116"><span class="lineNum">    2116</span> <span class="tlaGNC">           3 :                 rangeState.setReplica(prevRepl)</span></span>
<span id="L2117"><span class="lineNum">    2117</span> <span class="tlaGNC">           3 :                 storeState.adjusted.replicas[change.rangeID] = prevRepl.ReplicaState</span></span>
<span id="L2118"><span class="lineNum">    2118</span> <span class="tlaGNC">           3 :         } else if change.isAddition() {</span></span>
<span id="L2119"><span class="lineNum">    2119</span> <span class="tlaGNC">           1 :                 delete(storeState.adjusted.replicas, change.rangeID)</span></span>
<span id="L2120"><span class="lineNum">    2120</span> <span class="tlaGNC">           1 :                 if err := rangeState.removeReplica(change.target.StoreID); err != nil {</span></span>
<span id="L2121"><span class="lineNum">    2121</span> <span class="tlaUNC">           0 :                         panic(err)</span></span>
<span id="L2122"><span class="lineNum">    2122</span>              :                 }</span>
<span id="L2123"><span class="lineNum">    2123</span> <span class="tlaUNC">           0 :         } else {</span></span>
<span id="L2124"><span class="lineNum">    2124</span> <span class="tlaUNC">           0 :                 panic(fmt.Sprintf(&quot;unknown replica change %+v&quot;, change))</span></span>
<span id="L2125"><span class="lineNum">    2125</span>              :         }</span>
<span id="L2126"><span class="lineNum">    2126</span> <span class="tlaGNC">           4 :         cs.undoChangeLoadDelta(change)</span></span>
<span id="L2127"><span class="lineNum">    2127</span>              : }</span>
<span id="L2128"><span class="lineNum">    2128</span>              : </span>
<span id="L2129"><span class="lineNum">    2129</span>              : // applyChangeLoadDelta adds the change load delta to the adjusted load of the</span>
<span id="L2130"><span class="lineNum">    2130</span>              : // store and node affected.</span>
<span id="L2131"><span class="lineNum">    2131</span> <span class="tlaGNC">          21 : func (cs *clusterState) applyChangeLoadDelta(change ReplicaChange) {</span></span>
<span id="L2132"><span class="lineNum">    2132</span> <span class="tlaGNC">          21 :         ss := cs.stores[change.target.StoreID]</span></span>
<span id="L2133"><span class="lineNum">    2133</span> <span class="tlaGNC">          21 :         ss.adjusted.load.add(change.loadDelta)</span></span>
<span id="L2134"><span class="lineNum">    2134</span> <span class="tlaGNC">          21 :         ss.adjusted.secondaryLoad.add(change.secondaryLoadDelta)</span></span>
<span id="L2135"><span class="lineNum">    2135</span> <span class="tlaGNC">          21 :         ss.loadSeqNum++</span></span>
<span id="L2136"><span class="lineNum">    2136</span> <span class="tlaGNC">          21 :         ss.computeMaxFractionPending()</span></span>
<span id="L2137"><span class="lineNum">    2137</span> <span class="tlaGNC">          21 :         cs.nodes[ss.NodeID].adjustedCPU += change.loadDelta[CPURate]</span></span>
<span id="L2138"><span class="lineNum">    2138</span> <span class="tlaGNC">          21 : }</span></span>
<span id="L2139"><span class="lineNum">    2139</span>              : </span>
<span id="L2140"><span class="lineNum">    2140</span>              : // undoChangeLoadDelta subtracts the change load delta from the adjusted load</span>
<span id="L2141"><span class="lineNum">    2141</span>              : // of the store and node affected.</span>
<span id="L2142"><span class="lineNum">    2142</span> <span class="tlaGNC">           6 : func (cs *clusterState) undoChangeLoadDelta(change ReplicaChange) {</span></span>
<span id="L2143"><span class="lineNum">    2143</span> <span class="tlaGNC">           6 :         ss := cs.stores[change.target.StoreID]</span></span>
<span id="L2144"><span class="lineNum">    2144</span> <span class="tlaGNC">           6 :         ss.adjusted.load.subtract(change.loadDelta)</span></span>
<span id="L2145"><span class="lineNum">    2145</span> <span class="tlaGNC">           6 :         ss.adjusted.secondaryLoad.subtract(change.secondaryLoadDelta)</span></span>
<span id="L2146"><span class="lineNum">    2146</span> <span class="tlaGNC">           6 :         ss.loadSeqNum++</span></span>
<span id="L2147"><span class="lineNum">    2147</span> <span class="tlaGNC">           6 :         ss.computeMaxFractionPending()</span></span>
<span id="L2148"><span class="lineNum">    2148</span> <span class="tlaGNC">           6 :         cs.nodes[ss.NodeID].adjustedCPU -= change.loadDelta[CPURate]</span></span>
<span id="L2149"><span class="lineNum">    2149</span> <span class="tlaGNC">           6 : }</span></span>
<span id="L2150"><span class="lineNum">    2150</span>              : </span>
<span id="L2151"><span class="lineNum">    2151</span>              : // setStore updates the store attributes and locality in the cluster state. If</span>
<span id="L2152"><span class="lineNum">    2152</span>              : // the store hasn't been seen before, it is also added to the cluster state.</span>
<span id="L2153"><span class="lineNum">    2153</span>              : //</span>
<span id="L2154"><span class="lineNum">    2154</span>              : // TODO: We currently assume that the locality and attributes associated with a</span>
<span id="L2155"><span class="lineNum">    2155</span>              : // store/node are fixed. This is a reasonable assumption for the locality,</span>
<span id="L2156"><span class="lineNum">    2156</span>              : // however it is not for the attributes.</span>
<span id="L2157"><span class="lineNum">    2157</span> <span class="tlaGNC">          22 : func (cs *clusterState) setStore(sal StoreAttributesAndLocality) {</span></span>
<span id="L2158"><span class="lineNum">    2158</span> <span class="tlaGNC">          22 :         ns, ok := cs.nodes[sal.NodeID]</span></span>
<span id="L2159"><span class="lineNum">    2159</span> <span class="tlaGNC">          22 :         if !ok {</span></span>
<span id="L2160"><span class="lineNum">    2160</span> <span class="tlaGNC">          18 :                 // This is the first time seeing the associated node.</span></span>
<span id="L2161"><span class="lineNum">    2161</span> <span class="tlaGNC">          18 :                 ns = newNodeState(sal.NodeID)</span></span>
<span id="L2162"><span class="lineNum">    2162</span> <span class="tlaGNC">          18 :                 cs.nodes[sal.NodeID] = ns</span></span>
<span id="L2163"><span class="lineNum">    2163</span> <span class="tlaGNC">          18 :         }</span></span>
<span id="L2164"><span class="lineNum">    2164</span> <span class="tlaGNC">          22 :         _, ok = cs.stores[sal.StoreID]</span></span>
<span id="L2165"><span class="lineNum">    2165</span> <span class="tlaGNC">          22 :         if !ok {</span></span>
<span id="L2166"><span class="lineNum">    2166</span> <span class="tlaGNC">          20 :                 // This is the first time seeing this store.</span></span>
<span id="L2167"><span class="lineNum">    2167</span> <span class="tlaGNC">          20 :                 ss := newStoreState()</span></span>
<span id="L2168"><span class="lineNum">    2168</span> <span class="tlaGNC">          20 :                 // At this point, the store's health is unknown. It will need to be marked</span></span>
<span id="L2169"><span class="lineNum">    2169</span> <span class="tlaGNC">          20 :                 // as healthy separately. Until we know more, we won't place leases or</span></span>
<span id="L2170"><span class="lineNum">    2170</span> <span class="tlaGNC">          20 :                 // replicas on it (nor will we try to shed any that are already reported to</span></span>
<span id="L2171"><span class="lineNum">    2171</span> <span class="tlaGNC">          20 :                 // have replicas on it).</span></span>
<span id="L2172"><span class="lineNum">    2172</span> <span class="tlaGNC">          20 :                 ss.status = MakeStatus(HealthUnknown, LeaseDispositionRefusing, ReplicaDispositionRefusing)</span></span>
<span id="L2173"><span class="lineNum">    2173</span> <span class="tlaGNC">          20 :                 ss.localityTiers = cs.localityTierInterner.intern(sal.locality())</span></span>
<span id="L2174"><span class="lineNum">    2174</span> <span class="tlaGNC">          20 :                 ss.overloadStartTime = cs.ts.Now()</span></span>
<span id="L2175"><span class="lineNum">    2175</span> <span class="tlaGNC">          20 :                 ss.overloadEndTime = cs.ts.Now()</span></span>
<span id="L2176"><span class="lineNum">    2176</span> <span class="tlaGNC">          20 :                 ss.StoreAttributesAndLocality = sal</span></span>
<span id="L2177"><span class="lineNum">    2177</span> <span class="tlaGNC">          20 :                 cs.constraintMatcher.setStore(sal)</span></span>
<span id="L2178"><span class="lineNum">    2178</span> <span class="tlaGNC">          20 :                 cs.stores[sal.StoreID] = ss</span></span>
<span id="L2179"><span class="lineNum">    2179</span> <span class="tlaGNC">          20 :                 ns.stores = append(ns.stores, sal.StoreID)</span></span>
<span id="L2180"><span class="lineNum">    2180</span> <span class="tlaGNC">          20 :         }</span></span>
<span id="L2181"><span class="lineNum">    2181</span>              : }</span>
<span id="L2182"><span class="lineNum">    2182</span>              : </span>
<span id="L2183"><span class="lineNum">    2183</span>              : //======================================================================</span>
<span id="L2184"><span class="lineNum">    2184</span>              : // clusterState accessors:</span>
<span id="L2185"><span class="lineNum">    2185</span>              : //</span>
<span id="L2186"><span class="lineNum">    2186</span>              : // Not all accesses need to use these accessors.</span>
<span id="L2187"><span class="lineNum">    2187</span>              : //======================================================================</span>
<span id="L2188"><span class="lineNum">    2188</span>              : </span>
<span id="L2189"><span class="lineNum">    2189</span>              : // For meansMemo.</span>
<span id="L2190"><span class="lineNum">    2190</span>              : var _ loadInfoProvider = &amp;clusterState{}</span>
<span id="L2191"><span class="lineNum">    2191</span>              : </span>
<span id="L2192"><span class="lineNum">    2192</span> <span class="tlaGNC">          58 : func (cs *clusterState) getStoreReportedLoad(storeID roachpb.StoreID) (roachpb.NodeID, *storeLoad) {</span></span>
<span id="L2193"><span class="lineNum">    2193</span> <span class="tlaGNC">          58 :         if storeState, ok := cs.stores[storeID]; ok {</span></span>
<span id="L2194"><span class="lineNum">    2194</span> <span class="tlaGNC">          58 :                 return storeState.NodeID, &amp;storeState.storeLoad</span></span>
<span id="L2195"><span class="lineNum">    2195</span> <span class="tlaGNC">          58 :         }</span></span>
<span id="L2196"><span class="lineNum">    2196</span> <span class="tlaUNC">           0 :         return 0, nil</span></span>
<span id="L2197"><span class="lineNum">    2197</span>              : }</span>
<span id="L2198"><span class="lineNum">    2198</span>              : </span>
<span id="L2199"><span class="lineNum">    2199</span> <span class="tlaGNC">          49 : func (cs *clusterState) getNodeReportedLoad(nodeID roachpb.NodeID) *NodeLoad {</span></span>
<span id="L2200"><span class="lineNum">    2200</span> <span class="tlaGNC">          49 :         if nodeState, ok := cs.nodes[nodeID]; ok {</span></span>
<span id="L2201"><span class="lineNum">    2201</span> <span class="tlaGNC">          49 :                 return &amp;nodeState.NodeLoad</span></span>
<span id="L2202"><span class="lineNum">    2202</span> <span class="tlaGNC">          49 :         }</span></span>
<span id="L2203"><span class="lineNum">    2203</span> <span class="tlaUNC">           0 :         return nil</span></span>
<span id="L2204"><span class="lineNum">    2204</span>              : }</span>
<span id="L2205"><span class="lineNum">    2205</span>              : </span>
<span id="L2206"><span class="lineNum">    2206</span>              : // canShedAndAddLoad returns true if the delta can be added to the target</span>
<span id="L2207"><span class="lineNum">    2207</span>              : // store and removed from the src store, such that the relative load summaries</span>
<span id="L2208"><span class="lineNum">    2208</span>              : // will not get worse.</span>
<span id="L2209"><span class="lineNum">    2209</span>              : //</span>
<span id="L2210"><span class="lineNum">    2210</span>              : // It does not change any state between the call and return.</span>
<span id="L2211"><span class="lineNum">    2211</span>              : //</span>
<span id="L2212"><span class="lineNum">    2212</span>              : // overloadDim represents the dimension that is overloaded in the source and</span>
<span id="L2213"><span class="lineNum">    2213</span>              : // the function requires that the target must be currently &lt; loadNoChange</span>
<span id="L2214"><span class="lineNum">    2214</span>              : // along that dimension.</span>
<span id="L2215"><span class="lineNum">    2215</span>              : func (cs *clusterState) canShedAndAddLoad(</span>
<span id="L2216"><span class="lineNum">    2216</span>              :         ctx context.Context,</span>
<span id="L2217"><span class="lineNum">    2217</span>              :         srcSS *storeState,</span>
<span id="L2218"><span class="lineNum">    2218</span>              :         targetSS *storeState,</span>
<span id="L2219"><span class="lineNum">    2219</span>              :         delta LoadVector,</span>
<span id="L2220"><span class="lineNum">    2220</span>              :         means *meansLoad,</span>
<span id="L2221"><span class="lineNum">    2221</span>              :         onlyConsiderTargetCPUSummary bool,</span>
<span id="L2222"><span class="lineNum">    2222</span>              :         overloadedDim LoadDimension,</span>
<span id="L2223"><span class="lineNum">    2223</span> <span class="tlaGNC">           1 : ) (canAddLoad bool) {</span></span>
<span id="L2224"><span class="lineNum">    2224</span> <span class="tlaGNC">           1 :         if overloadedDim == NumLoadDimensions {</span></span>
<span id="L2225"><span class="lineNum">    2225</span> <span class="tlaUNC">           0 :                 panic(&quot;overloadedDim must not be NumLoadDimensions&quot;)</span></span>
<span id="L2226"><span class="lineNum">    2226</span>              :         }</span>
<span id="L2227"><span class="lineNum">    2227</span>              :         // TODO(tbg): in experiments, we often see interesting behavior right when</span>
<span id="L2228"><span class="lineNum">    2228</span>              :         // the load delta addition flips the loadSummary for either the target or the</span>
<span id="L2229"><span class="lineNum">    2229</span>              :         // source, which suggests it might be useful to add this to verbose logging.</span>
<span id="L2230"><span class="lineNum">    2230</span>              : </span>
<span id="L2231"><span class="lineNum">    2231</span> <span class="tlaGNC">           1 :         targetNS := cs.nodes[targetSS.NodeID]</span></span>
<span id="L2232"><span class="lineNum">    2232</span> <span class="tlaGNC">           1 :         // Add the delta.</span></span>
<span id="L2233"><span class="lineNum">    2233</span> <span class="tlaGNC">           1 :         deltaToAdd := loadVectorToAdd(delta)</span></span>
<span id="L2234"><span class="lineNum">    2234</span> <span class="tlaGNC">           1 :         targetSS.adjusted.load.add(deltaToAdd)</span></span>
<span id="L2235"><span class="lineNum">    2235</span> <span class="tlaGNC">           1 :         // TODO(tbg): why does NodeLoad have an adjustedCPU field but not fields for</span></span>
<span id="L2236"><span class="lineNum">    2236</span> <span class="tlaGNC">           1 :         // the other load dimensions? We just added deltaToAdd to targetSS.adjusted,</span></span>
<span id="L2237"><span class="lineNum">    2237</span> <span class="tlaGNC">           1 :         // shouldn't this be wholly reflected in targetNS as well, not just for CPU?</span></span>
<span id="L2238"><span class="lineNum">    2238</span> <span class="tlaGNC">           1 :         // Or maybe CPU is the only dimension that matters at the node level. It feels</span></span>
<span id="L2239"><span class="lineNum">    2239</span> <span class="tlaGNC">           1 :         // sloppy/confusing though.</span></span>
<span id="L2240"><span class="lineNum">    2240</span> <span class="tlaGNC">           1 :         targetNS.adjustedCPU += deltaToAdd[CPURate]</span></span>
<span id="L2241"><span class="lineNum">    2241</span> <span class="tlaGNC">           1 :         targetSLS := computeLoadSummary(ctx, targetSS, targetNS, &amp;means.storeLoad, &amp;means.nodeLoad)</span></span>
<span id="L2242"><span class="lineNum">    2242</span> <span class="tlaGNC">           1 :         // Undo the addition.</span></span>
<span id="L2243"><span class="lineNum">    2243</span> <span class="tlaGNC">           1 :         targetSS.adjusted.load.subtract(deltaToAdd)</span></span>
<span id="L2244"><span class="lineNum">    2244</span> <span class="tlaGNC">           1 :         targetNS.adjustedCPU -= deltaToAdd[CPURate]</span></span>
<span id="L2245"><span class="lineNum">    2245</span> <span class="tlaGNC">           1 : </span></span>
<span id="L2246"><span class="lineNum">    2246</span> <span class="tlaGNC">           1 :         // Remove the delta.</span></span>
<span id="L2247"><span class="lineNum">    2247</span> <span class="tlaGNC">           1 :         srcNS := cs.nodes[srcSS.NodeID]</span></span>
<span id="L2248"><span class="lineNum">    2248</span> <span class="tlaGNC">           1 :         srcSS.adjusted.load.subtract(delta)</span></span>
<span id="L2249"><span class="lineNum">    2249</span> <span class="tlaGNC">           1 :         srcNS.adjustedCPU -= delta[CPURate]</span></span>
<span id="L2250"><span class="lineNum">    2250</span> <span class="tlaGNC">           1 :         srcSLS := computeLoadSummary(ctx, srcSS, srcNS, &amp;means.storeLoad, &amp;means.nodeLoad)</span></span>
<span id="L2251"><span class="lineNum">    2251</span> <span class="tlaGNC">           1 :         // Undo the removal.</span></span>
<span id="L2252"><span class="lineNum">    2252</span> <span class="tlaGNC">           1 :         srcSS.adjusted.load.add(delta)</span></span>
<span id="L2253"><span class="lineNum">    2253</span> <span class="tlaGNC">           1 :         srcNS.adjustedCPU += delta[CPURate]</span></span>
<span id="L2254"><span class="lineNum">    2254</span> <span class="tlaGNC">           1 : </span></span>
<span id="L2255"><span class="lineNum">    2255</span> <span class="tlaGNC">           1 :         var reason strings.Builder</span></span>
<span id="L2256"><span class="lineNum">    2256</span> <span class="tlaGNC">           1 :         defer func() {</span></span>
<span id="L2257"><span class="lineNum">    2257</span> <span class="tlaGNC">           1 :                 if canAddLoad {</span></span>
<span id="L2258"><span class="lineNum">    2258</span> <span class="tlaGNC">           1 :                         log.KvDistribution.VInfof(ctx, 3, &quot;can add load to n%vs%v: %v targetSLS[%v] srcSLS[%v]&quot;,</span></span>
<span id="L2259"><span class="lineNum">    2259</span> <span class="tlaGNC">           1 :                                 targetNS.NodeID, targetSS.StoreID, canAddLoad, targetSLS, srcSLS)</span></span>
<span id="L2260"><span class="lineNum">    2260</span> <span class="tlaGNC">           1 :                 } else {</span></span>
<span id="L2261"><span class="lineNum">    2261</span> <span class="tlaUNC">           0 :                         log.KvDistribution.VInfof(ctx, 2, &quot;cannot add load to n%vs%v: due to %s&quot;, targetNS.NodeID, targetSS.StoreID, reason.String())</span></span>
<span id="L2262"><span class="lineNum">    2262</span> <span class="tlaUNC">           0 :                         log.KvDistribution.VInfof(ctx, 2, &quot;[target_sls:%v,src_sls:%v]&quot;, targetSLS, srcSLS)</span></span>
<span id="L2263"><span class="lineNum">    2263</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L2264"><span class="lineNum">    2264</span>              :         }()</span>
<span id="L2265"><span class="lineNum">    2265</span> <span class="tlaGNC">           1 :         if targetSLS.highDiskSpaceUtilization {</span></span>
<span id="L2266"><span class="lineNum">    2266</span> <span class="tlaUNC">           0 :                 reason.WriteString(&quot;targetSLS.highDiskSpaceUtilization&quot;)</span></span>
<span id="L2267"><span class="lineNum">    2267</span> <span class="tlaUNC">           0 :                 return false</span></span>
<span id="L2268"><span class="lineNum">    2268</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L2269"><span class="lineNum">    2269</span>              :         // We define targetSummary as a summarization across all dimensions of the</span>
<span id="L2270"><span class="lineNum">    2270</span>              :         // target. A targetSummary &lt; loadNoChange always accepts the change. When</span>
<span id="L2271"><span class="lineNum">    2271</span>              :         // the targetSummary &gt;= loadNoChange, we are stricter and require both that</span>
<span id="L2272"><span class="lineNum">    2272</span>              :         // there are no pending changes in the target, and the target is &quot;not worse&quot;</span>
<span id="L2273"><span class="lineNum">    2273</span>              :         // in a way that will cause thrashing, where the details are defined below.</span>
<span id="L2274"><span class="lineNum">    2274</span>              :         // The no pending changes requirement is to delay making a potentially</span>
<span id="L2275"><span class="lineNum">    2275</span>              :         // non-ideal choice of the target.</span>
<span id="L2276"><span class="lineNum">    2276</span>              :         //</span>
<span id="L2277"><span class="lineNum">    2277</span>              :         // NB: The target's overload dimension summary must have been &lt;</span>
<span id="L2278"><span class="lineNum">    2278</span>              :         // loadNoChange, and the source must have been &gt; loadNoChange.</span>
<span id="L2279"><span class="lineNum">    2279</span> <span class="tlaGNC">           1 :         var targetSummary loadSummary</span></span>
<span id="L2280"><span class="lineNum">    2280</span> <span class="tlaGNC">           1 :         if onlyConsiderTargetCPUSummary {</span></span>
<span id="L2281"><span class="lineNum">    2281</span> <span class="tlaGNC">           1 :                 targetSummary = targetSLS.dimSummary[CPURate]</span></span>
<span id="L2282"><span class="lineNum">    2282</span> <span class="tlaGNC">           1 :                 if targetSummary &lt; targetSLS.nls {</span></span>
<span id="L2283"><span class="lineNum">    2283</span> <span class="tlaUNC">           0 :                         targetSummary = targetSLS.nls</span></span>
<span id="L2284"><span class="lineNum">    2284</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L2285"><span class="lineNum">    2285</span> <span class="tlaUNC">           0 :         } else {</span></span>
<span id="L2286"><span class="lineNum">    2286</span> <span class="tlaUNC">           0 :                 targetSummary = targetSLS.sls</span></span>
<span id="L2287"><span class="lineNum">    2287</span> <span class="tlaUNC">           0 :                 if targetSummary &lt; targetSLS.nls {</span></span>
<span id="L2288"><span class="lineNum">    2288</span> <span class="tlaUNC">           0 :                         targetSummary = targetSLS.nls</span></span>
<span id="L2289"><span class="lineNum">    2289</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L2290"><span class="lineNum">    2290</span>              :         }</span>
<span id="L2291"><span class="lineNum">    2291</span>              : </span>
<span id="L2292"><span class="lineNum">    2292</span> <span class="tlaGNC">           1 :         if targetSummary &lt; loadNoChange {</span></span>
<span id="L2293"><span class="lineNum">    2293</span> <span class="tlaUNC">           0 :                 return true</span></span>
<span id="L2294"><span class="lineNum">    2294</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L2295"><span class="lineNum">    2295</span> <span class="tlaGNC">           1 :         if targetSummary &gt;= overloadUrgent {</span></span>
<span id="L2296"><span class="lineNum">    2296</span> <span class="tlaUNC">           0 :                 reason.WriteString(&quot;overloadUrgent&quot;)</span></span>
<span id="L2297"><span class="lineNum">    2297</span> <span class="tlaUNC">           0 :                 return false</span></span>
<span id="L2298"><span class="lineNum">    2298</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L2299"><span class="lineNum">    2299</span>              :         // Need to consider additional factors.</span>
<span id="L2300"><span class="lineNum">    2300</span>              :         //</span>
<span id="L2301"><span class="lineNum">    2301</span>              :         // It is possible that both are overloadSlow in aggregate. We want to make</span>
<span id="L2302"><span class="lineNum">    2302</span>              :         // sure that this exchange doesn't make the target worse than the source in</span>
<span id="L2303"><span class="lineNum">    2303</span>              :         // the dimension being shed.</span>
<span id="L2304"><span class="lineNum">    2304</span> <span class="tlaGNC">           1 :         overloadedDimPermitsChange :=</span></span>
<span id="L2305"><span class="lineNum">    2305</span> <span class="tlaGNC">           1 :                 targetSLS.dimSummary[overloadedDim] &lt;= srcSLS.dimSummary[overloadedDim]</span></span>
<span id="L2306"><span class="lineNum">    2306</span> <span class="tlaGNC">           1 :         // For the other dimensions, we want to make sure that the target is not</span></span>
<span id="L2307"><span class="lineNum">    2307</span> <span class="tlaGNC">           1 :         // getting worse than it was before the change, if it was already overloaded</span></span>
<span id="L2308"><span class="lineNum">    2308</span> <span class="tlaGNC">           1 :         // in that dimension. This is to prevent thrashing. One way to do this is to</span></span>
<span id="L2309"><span class="lineNum">    2309</span> <span class="tlaGNC">           1 :         // simply reject the change if for any i != overloadedDim,</span></span>
<span id="L2310"><span class="lineNum">    2310</span> <span class="tlaGNC">           1 :         // initialTargetSLS.dimSummary[i] &lt; targetSLS.dimSummary[i] &amp;&amp; targetSLS.dimSummary[i] &gt; loadNoChange</span></span>
<span id="L2311"><span class="lineNum">    2311</span> <span class="tlaGNC">           1 :         //</span></span>
<span id="L2312"><span class="lineNum">    2312</span> <span class="tlaGNC">           1 :         // where initialTargetSLS is the target's load summary before the attempted</span></span>
<span id="L2313"><span class="lineNum">    2313</span> <span class="tlaGNC">           1 :         // change.</span></span>
<span id="L2314"><span class="lineNum">    2314</span> <span class="tlaGNC">           1 :         //</span></span>
<span id="L2315"><span class="lineNum">    2315</span> <span class="tlaGNC">           1 :         // This is what we initially did, but note that this is not quite</span></span>
<span id="L2316"><span class="lineNum">    2316</span> <span class="tlaGNC">           1 :         // strict enough. We may have picked the top range wrt overloadedDim, to</span></span>
<span id="L2317"><span class="lineNum">    2317</span> <span class="tlaGNC">           1 :         // shed from the source, but it may also add significant load to the target</span></span>
<span id="L2318"><span class="lineNum">    2318</span> <span class="tlaGNC">           1 :         // along a different dimension, dim2, along with the target is already</span></span>
<span id="L2319"><span class="lineNum">    2319</span> <span class="tlaGNC">           1 :         // overloaded. This happens because the set of ranges this store can fiddle</span></span>
<span id="L2320"><span class="lineNum">    2320</span> <span class="tlaGNC">           1 :         // with are limited. To improve this, we also check that the target is</span></span>
<span id="L2321"><span class="lineNum">    2321</span> <span class="tlaGNC">           1 :         // seeing dim2 increase at a smaller fraction than it is seeing</span></span>
<span id="L2322"><span class="lineNum">    2322</span> <span class="tlaGNC">           1 :         // overloadedDim increase.</span></span>
<span id="L2323"><span class="lineNum">    2323</span> <span class="tlaGNC">           1 :         //</span></span>
<span id="L2324"><span class="lineNum">    2324</span> <span class="tlaGNC">           1 :         // That boolean predicate can also be too strict, in that we should permit</span></span>
<span id="L2325"><span class="lineNum">    2325</span> <span class="tlaGNC">           1 :         // transitions to overloadSlow along one dimension, to allow for an</span></span>
<span id="L2326"><span class="lineNum">    2326</span> <span class="tlaGNC">           1 :         // exchange.</span></span>
<span id="L2327"><span class="lineNum">    2327</span> <span class="tlaGNC">           1 :         overloadedDimFractionIncrease := math.MaxFloat64</span></span>
<span id="L2328"><span class="lineNum">    2328</span> <span class="tlaGNC">           1 :         if targetSS.adjusted.load[overloadedDim] &gt; 0 {</span></span>
<span id="L2329"><span class="lineNum">    2329</span> <span class="tlaGNC">           1 :                 overloadedDimFractionIncrease = float64(deltaToAdd[overloadedDim]) /</span></span>
<span id="L2330"><span class="lineNum">    2330</span> <span class="tlaGNC">           1 :                         float64(targetSS.adjusted.load[overloadedDim])</span></span>
<span id="L2331"><span class="lineNum">    2331</span> <span class="tlaGNC">           1 :         } else {</span></span>
<span id="L2332"><span class="lineNum">    2332</span> <span class="tlaUNC">           0 :                 // Else, the adjusted load on the overloadedDim is zero or negative, which</span></span>
<span id="L2333"><span class="lineNum">    2333</span> <span class="tlaUNC">           0 :                 // is possible, but extremely rare in practice. We arbitrarily set the</span></span>
<span id="L2334"><span class="lineNum">    2334</span> <span class="tlaUNC">           0 :                 // fraction increase to 1.0 in this case.</span></span>
<span id="L2335"><span class="lineNum">    2335</span> <span class="tlaUNC">           0 :                 overloadedDimFractionIncrease = 1.0</span></span>
<span id="L2336"><span class="lineNum">    2336</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L2337"><span class="lineNum">    2337</span> <span class="tlaGNC">           1 :         otherDimensionsBecameWorseInTarget := false</span></span>
<span id="L2338"><span class="lineNum">    2338</span> <span class="tlaGNC">           3 :         for i := range targetSLS.dimSummary {</span></span>
<span id="L2339"><span class="lineNum">    2339</span> <span class="tlaGNC">           3 :                 dim := LoadDimension(i)</span></span>
<span id="L2340"><span class="lineNum">    2340</span> <span class="tlaGNC">           3 :                 if dim == overloadedDim {</span></span>
<span id="L2341"><span class="lineNum">    2341</span> <span class="tlaGNC">           1 :                         continue</span></span>
<span id="L2342"><span class="lineNum">    2342</span>              :                 }</span>
<span id="L2343"><span class="lineNum">    2343</span> <span class="tlaGNC">           2 :                 if targetSLS.dimSummary[i] &lt;= loadNoChange {</span></span>
<span id="L2344"><span class="lineNum">    2344</span> <span class="tlaGNC">           2 :                         continue</span></span>
<span id="L2345"><span class="lineNum">    2345</span>              :                 }</span>
<span id="L2346"><span class="lineNum">    2346</span>              :                 // This is an overloaded dimension in the target. Only allow small</span>
<span id="L2347"><span class="lineNum">    2347</span>              :                 // increases along this dimension.</span>
<span id="L2348"><span class="lineNum">    2348</span> <span class="tlaUNC">           0 :                 if targetSS.adjusted.load[dim] &gt; 0 {</span></span>
<span id="L2349"><span class="lineNum">    2349</span> <span class="tlaUNC">           0 :                         dimFractionIncrease := float64(deltaToAdd[dim]) / float64(targetSS.adjusted.load[dim])</span></span>
<span id="L2350"><span class="lineNum">    2350</span> <span class="tlaUNC">           0 :                         // The use of 33% is arbitrary.</span></span>
<span id="L2351"><span class="lineNum">    2351</span> <span class="tlaUNC">           0 :                         if dimFractionIncrease &gt; overloadedDimFractionIncrease/3 {</span></span>
<span id="L2352"><span class="lineNum">    2352</span> <span class="tlaUNC">           0 :                                 log.KvDistribution.Infof(ctx, &quot;%v: %f &gt; %f/3&quot;, dim, dimFractionIncrease, overloadedDimFractionIncrease)</span></span>
<span id="L2353"><span class="lineNum">    2353</span> <span class="tlaUNC">           0 :                                 otherDimensionsBecameWorseInTarget = true</span></span>
<span id="L2354"><span class="lineNum">    2354</span> <span class="tlaUNC">           0 :                                 break</span></span>
<span id="L2355"><span class="lineNum">    2355</span>              :                         }</span>
<span id="L2356"><span class="lineNum">    2356</span>              :                 }</span>
<span id="L2357"><span class="lineNum">    2357</span>              :                 // Else the adjusted load in dimension dim is zero or negative, which is</span>
<span id="L2358"><span class="lineNum">    2358</span>              :                 // possible, but extremely rare in practice. We ignore this dimension in</span>
<span id="L2359"><span class="lineNum">    2359</span>              :                 // that case.</span>
<span id="L2360"><span class="lineNum">    2360</span>              :         }</span>
<span id="L2361"><span class="lineNum">    2361</span> <span class="tlaGNC">           1 :         canAddLoad = overloadedDimPermitsChange &amp;&amp; !otherDimensionsBecameWorseInTarget &amp;&amp;</span></span>
<span id="L2362"><span class="lineNum">    2362</span> <span class="tlaGNC">           1 :                 targetSLS.maxFractionPendingIncrease &lt; epsilon &amp;&amp;</span></span>
<span id="L2363"><span class="lineNum">    2363</span> <span class="tlaGNC">           1 :                 targetSLS.maxFractionPendingDecrease &lt; epsilon &amp;&amp;</span></span>
<span id="L2364"><span class="lineNum">    2364</span> <span class="tlaGNC">           1 :                 // NB: targetSLS.nls &lt;= targetSLS.sls is not a typo, in that we are</span></span>
<span id="L2365"><span class="lineNum">    2365</span> <span class="tlaGNC">           1 :                 // comparing targetSLS with itself. The nls only captures node-level</span></span>
<span id="L2366"><span class="lineNum">    2366</span> <span class="tlaGNC">           1 :                 // CPU, so if a store that is overloaded wrt WriteBandwidth wants to</span></span>
<span id="L2367"><span class="lineNum">    2367</span> <span class="tlaGNC">           1 :                 // shed to a store that is overloaded wrt CPURate, we need to permit</span></span>
<span id="L2368"><span class="lineNum">    2368</span> <span class="tlaGNC">           1 :                 // that. However, the nls of the former will be less than the that of</span></span>
<span id="L2369"><span class="lineNum">    2369</span> <span class="tlaGNC">           1 :                 // the latter. By looking at the nls of the target here, we are making</span></span>
<span id="L2370"><span class="lineNum">    2370</span> <span class="tlaGNC">           1 :                 // sure that it is no worse than the sls of the target, since if it</span></span>
<span id="L2371"><span class="lineNum">    2371</span> <span class="tlaGNC">           1 :                 // is, the node is overloaded wrt CPU due to some other store on that</span></span>
<span id="L2372"><span class="lineNum">    2372</span> <span class="tlaGNC">           1 :                 // node, and we should be shedding that load first.</span></span>
<span id="L2373"><span class="lineNum">    2373</span> <span class="tlaGNC">           1 :                 targetSLS.nls &lt;= targetSLS.sls</span></span>
<span id="L2374"><span class="lineNum">    2374</span> <span class="tlaGNC">           1 :         if canAddLoad {</span></span>
<span id="L2375"><span class="lineNum">    2375</span> <span class="tlaGNC">           1 :                 return true</span></span>
<span id="L2376"><span class="lineNum">    2376</span> <span class="tlaGNC">           1 :         }</span></span>
<span id="L2377"><span class="lineNum">    2377</span> <span class="tlaUNC">           0 :         if !overloadedDimPermitsChange {</span></span>
<span id="L2378"><span class="lineNum">    2378</span> <span class="tlaUNC">           0 :                 if reason.Len() != 0 {</span></span>
<span id="L2379"><span class="lineNum">    2379</span> <span class="tlaUNC">           0 :                         reason.WriteRune(',')</span></span>
<span id="L2380"><span class="lineNum">    2380</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L2381"><span class="lineNum">    2381</span> <span class="tlaUNC">           0 :                 reason.WriteString(&quot;!overloadedDimPermitsChange&quot;)</span></span>
<span id="L2382"><span class="lineNum">    2382</span>              :         }</span>
<span id="L2383"><span class="lineNum">    2383</span> <span class="tlaUNC">           0 :         if otherDimensionsBecameWorseInTarget {</span></span>
<span id="L2384"><span class="lineNum">    2384</span> <span class="tlaUNC">           0 :                 if reason.Len() != 0 {</span></span>
<span id="L2385"><span class="lineNum">    2385</span> <span class="tlaUNC">           0 :                         reason.WriteRune(',')</span></span>
<span id="L2386"><span class="lineNum">    2386</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L2387"><span class="lineNum">    2387</span> <span class="tlaUNC">           0 :                 reason.WriteString(&quot;otherDimensionsBecameWorseInTarget&quot;)</span></span>
<span id="L2388"><span class="lineNum">    2388</span>              :         }</span>
<span id="L2389"><span class="lineNum">    2389</span> <span class="tlaUNC">           0 :         if targetSummary &gt;= loadNoChange {</span></span>
<span id="L2390"><span class="lineNum">    2390</span> <span class="tlaUNC">           0 :                 if reason.Len() != 0 {</span></span>
<span id="L2391"><span class="lineNum">    2391</span> <span class="tlaUNC">           0 :                         reason.WriteRune(',')</span></span>
<span id="L2392"><span class="lineNum">    2392</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L2393"><span class="lineNum">    2393</span> <span class="tlaUNC">           0 :                 reason.WriteString(fmt.Sprintf(&quot;target_summary(%s)&gt;=loadNoChange&quot;, targetSummary))</span></span>
<span id="L2394"><span class="lineNum">    2394</span>              :         }</span>
<span id="L2395"><span class="lineNum">    2395</span> <span class="tlaUNC">           0 :         if targetSLS.maxFractionPendingIncrease &gt;= epsilon || targetSLS.maxFractionPendingDecrease &gt;= epsilon {</span></span>
<span id="L2396"><span class="lineNum">    2396</span> <span class="tlaUNC">           0 :                 if reason.Len() != 0 {</span></span>
<span id="L2397"><span class="lineNum">    2397</span> <span class="tlaUNC">           0 :                         reason.WriteRune(',')</span></span>
<span id="L2398"><span class="lineNum">    2398</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L2399"><span class="lineNum">    2399</span> <span class="tlaUNC">           0 :                 reason.WriteString(fmt.Sprintf(&quot;targetSLS.frac_pending(%.2for%.2f&gt;=epsilon)&quot;,</span></span>
<span id="L2400"><span class="lineNum">    2400</span> <span class="tlaUNC">           0 :                         targetSLS.maxFractionPendingIncrease, targetSLS.maxFractionPendingDecrease))</span></span>
<span id="L2401"><span class="lineNum">    2401</span>              :         }</span>
<span id="L2402"><span class="lineNum">    2402</span> <span class="tlaUNC">           0 :         if targetSLS.sls &gt; srcSLS.sls {</span></span>
<span id="L2403"><span class="lineNum">    2403</span> <span class="tlaUNC">           0 :                 if reason.Len() != 0 {</span></span>
<span id="L2404"><span class="lineNum">    2404</span> <span class="tlaUNC">           0 :                         reason.WriteRune(',')</span></span>
<span id="L2405"><span class="lineNum">    2405</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L2406"><span class="lineNum">    2406</span> <span class="tlaUNC">           0 :                 reason.WriteString(fmt.Sprintf(&quot;target-store(%s)&gt;src-store(%s)&quot;, targetSLS.sls, srcSLS.sls))</span></span>
<span id="L2407"><span class="lineNum">    2407</span>              :         }</span>
<span id="L2408"><span class="lineNum">    2408</span> <span class="tlaUNC">           0 :         if targetSLS.nls &gt; targetSLS.sls {</span></span>
<span id="L2409"><span class="lineNum">    2409</span> <span class="tlaUNC">           0 :                 if reason.Len() != 0 {</span></span>
<span id="L2410"><span class="lineNum">    2410</span> <span class="tlaUNC">           0 :                         reason.WriteRune(',')</span></span>
<span id="L2411"><span class="lineNum">    2411</span> <span class="tlaUNC">           0 :                 }</span></span>
<span id="L2412"><span class="lineNum">    2412</span> <span class="tlaUNC">           0 :                 reason.WriteString(fmt.Sprintf(&quot;target-node(%s)&gt;target-store(%s)&quot;,</span></span>
<span id="L2413"><span class="lineNum">    2413</span> <span class="tlaUNC">           0 :                         targetSLS.nls, targetSLS.sls))</span></span>
<span id="L2414"><span class="lineNum">    2414</span>              :         }</span>
<span id="L2415"><span class="lineNum">    2415</span> <span class="tlaUNC">           0 :         return false</span></span>
<span id="L2416"><span class="lineNum">    2416</span>              : }</span>
<span id="L2417"><span class="lineNum">    2417</span>              : </span>
<span id="L2418"><span class="lineNum">    2418</span>              : func (cs *clusterState) computeLoadSummary(</span>
<span id="L2419"><span class="lineNum">    2419</span>              :         ctx context.Context, storeID roachpb.StoreID, msl *meanStoreLoad, mnl *meanNodeLoad,</span>
<span id="L2420"><span class="lineNum">    2420</span> <span class="tlaGNC">          61 : ) storeLoadSummary {</span></span>
<span id="L2421"><span class="lineNum">    2421</span> <span class="tlaGNC">          61 :         ss := cs.stores[storeID]</span></span>
<span id="L2422"><span class="lineNum">    2422</span> <span class="tlaGNC">          61 :         ns := cs.nodes[ss.NodeID]</span></span>
<span id="L2423"><span class="lineNum">    2423</span> <span class="tlaGNC">          61 :         return computeLoadSummary(ctx, ss, ns, msl, mnl)</span></span>
<span id="L2424"><span class="lineNum">    2424</span> <span class="tlaGNC">          61 : }</span></span>
<span id="L2425"><span class="lineNum">    2425</span>              : </span>
<span id="L2426"><span class="lineNum">    2426</span>              : // TODO(wenyihu6): check to make sure obs here is correct</span>
<span id="L2427"><span class="lineNum">    2427</span> <span class="tlaUNC">           0 : func (cs *clusterState) loadSummaryForAllStores(ctx context.Context) string {</span></span>
<span id="L2428"><span class="lineNum">    2428</span> <span class="tlaUNC">           0 :         var b strings.Builder</span></span>
<span id="L2429"><span class="lineNum">    2429</span> <span class="tlaUNC">           0 :         clusterMeans := cs.meansMemo.getMeans(nil)</span></span>
<span id="L2430"><span class="lineNum">    2430</span> <span class="tlaUNC">           0 :         b.WriteString(fmt.Sprintf(&quot;cluster means: (stores-load %s) (stores-capacity %s)\n&quot;,</span></span>
<span id="L2431"><span class="lineNum">    2431</span> <span class="tlaUNC">           0 :                 clusterMeans.storeLoad.load, clusterMeans.storeLoad.capacity))</span></span>
<span id="L2432"><span class="lineNum">    2432</span> <span class="tlaUNC">           0 :         b.WriteString(fmt.Sprintf(&quot;(nodes-cpu-load %d) (nodes-cpu-capacity %d)\n&quot;,</span></span>
<span id="L2433"><span class="lineNum">    2433</span> <span class="tlaUNC">           0 :                 clusterMeans.nodeLoad.loadCPU, clusterMeans.nodeLoad.capacityCPU))</span></span>
<span id="L2434"><span class="lineNum">    2434</span> <span class="tlaUNC">           0 :         for storeID, ss := range cs.stores {</span></span>
<span id="L2435"><span class="lineNum">    2435</span> <span class="tlaUNC">           0 :                 sls := cs.meansMemo.getStoreLoadSummary(ctx, clusterMeans, storeID, ss.loadSeqNum)</span></span>
<span id="L2436"><span class="lineNum">    2436</span> <span class="tlaUNC">           0 :                 b.WriteString(fmt.Sprintf(&quot;evaluating store s%d for shedding: load summary %v&quot;, storeID, sls))</span></span>
<span id="L2437"><span class="lineNum">    2437</span> <span class="tlaUNC">           0 :         }</span></span>
<span id="L2438"><span class="lineNum">    2438</span> <span class="tlaUNC">           0 :         return b.String()</span></span>
<span id="L2439"><span class="lineNum">    2439</span>              : }</span>
<span id="L2440"><span class="lineNum">    2440</span>              : </span>
<span id="L2441"><span class="lineNum">    2441</span>              : func computeLoadSummary(</span>
<span id="L2442"><span class="lineNum">    2442</span>              :         ctx context.Context, ss *storeState, ns *nodeState, msl *meanStoreLoad, mnl *meanNodeLoad,</span>
<span id="L2443"><span class="lineNum">    2443</span> <span class="tlaGNC">          63 : ) storeLoadSummary {</span></span>
<span id="L2444"><span class="lineNum">    2444</span> <span class="tlaGNC">          63 :         sls := loadLow</span></span>
<span id="L2445"><span class="lineNum">    2445</span> <span class="tlaGNC">          63 :         var highDiskSpaceUtil bool</span></span>
<span id="L2446"><span class="lineNum">    2446</span> <span class="tlaGNC">          63 :         var dimSummary [NumLoadDimensions]loadSummary</span></span>
<span id="L2447"><span class="lineNum">    2447</span> <span class="tlaGNC">          63 :         var worstDim LoadDimension</span></span>
<span id="L2448"><span class="lineNum">    2448</span> <span class="tlaGNC">         189 :         for i := range msl.load {</span></span>
<span id="L2449"><span class="lineNum">    2449</span> <span class="tlaGNC">         189 :                 const nodeIDForLogging = 0</span></span>
<span id="L2450"><span class="lineNum">    2450</span> <span class="tlaGNC">         189 :                 ls := loadSummaryForDimension(ctx, ss.StoreID, nodeIDForLogging, LoadDimension(i), ss.adjusted.load[i], ss.capacity[i],</span></span>
<span id="L2451"><span class="lineNum">    2451</span> <span class="tlaGNC">         189 :                         msl.load[i], msl.util[i])</span></span>
<span id="L2452"><span class="lineNum">    2452</span> <span class="tlaGNC">         189 :                 if ls &gt; sls {</span></span>
<span id="L2453"><span class="lineNum">    2453</span> <span class="tlaGNC">          53 :                         sls = ls</span></span>
<span id="L2454"><span class="lineNum">    2454</span> <span class="tlaGNC">          53 :                         worstDim = LoadDimension(i)</span></span>
<span id="L2455"><span class="lineNum">    2455</span> <span class="tlaGNC">          53 :                 }</span></span>
<span id="L2456"><span class="lineNum">    2456</span> <span class="tlaGNC">         189 :                 dimSummary[i] = ls</span></span>
<span id="L2457"><span class="lineNum">    2457</span> <span class="tlaGNC">         189 :                 switch LoadDimension(i) {</span></span>
<span id="L2458"><span class="lineNum">    2458</span> <span class="tlaGNC">          63 :                 case ByteSize:</span></span>
<span id="L2459"><span class="lineNum">    2459</span> <span class="tlaGNC">          63 :                         highDiskSpaceUtil = highDiskSpaceUtilization(ss.adjusted.load[i], ss.capacity[i])</span></span>
<span id="L2460"><span class="lineNum">    2460</span>              :                 }</span>
<span id="L2461"><span class="lineNum">    2461</span>              :         }</span>
<span id="L2462"><span class="lineNum">    2462</span> <span class="tlaGNC">          63 :         const storeIDForLogging = 0</span></span>
<span id="L2463"><span class="lineNum">    2463</span> <span class="tlaGNC">          63 :         nls := loadSummaryForDimension(ctx, storeIDForLogging, ns.NodeID, CPURate, ns.adjustedCPU, ns.CapacityCPU, mnl.loadCPU, mnl.utilCPU)</span></span>
<span id="L2464"><span class="lineNum">    2464</span> <span class="tlaGNC">          63 :         return storeLoadSummary{</span></span>
<span id="L2465"><span class="lineNum">    2465</span> <span class="tlaGNC">          63 :                 worstDim:                   worstDim,</span></span>
<span id="L2466"><span class="lineNum">    2466</span> <span class="tlaGNC">          63 :                 sls:                        sls,</span></span>
<span id="L2467"><span class="lineNum">    2467</span> <span class="tlaGNC">          63 :                 nls:                        nls,</span></span>
<span id="L2468"><span class="lineNum">    2468</span> <span class="tlaGNC">          63 :                 dimSummary:                 dimSummary,</span></span>
<span id="L2469"><span class="lineNum">    2469</span> <span class="tlaGNC">          63 :                 highDiskSpaceUtilization:   highDiskSpaceUtil,</span></span>
<span id="L2470"><span class="lineNum">    2470</span> <span class="tlaGNC">          63 :                 maxFractionPendingIncrease: ss.maxFractionPendingIncrease,</span></span>
<span id="L2471"><span class="lineNum">    2471</span> <span class="tlaGNC">          63 :                 maxFractionPendingDecrease: ss.maxFractionPendingDecrease,</span></span>
<span id="L2472"><span class="lineNum">    2472</span> <span class="tlaGNC">          63 :                 loadSeqNum:                 ss.loadSeqNum,</span></span>
<span id="L2473"><span class="lineNum">    2473</span> <span class="tlaGNC">          63 :         }</span></span>
<span id="L2474"><span class="lineNum">    2474</span>              : }</span>
<span id="L2475"><span class="lineNum">    2475</span>              : </span>
<span id="L2476"><span class="lineNum">    2476</span>              : type StoreAttributesAndLocality struct {</span>
<span id="L2477"><span class="lineNum">    2477</span>              :         roachpb.StoreID</span>
<span id="L2478"><span class="lineNum">    2478</span>              :         roachpb.NodeID</span>
<span id="L2479"><span class="lineNum">    2479</span>              :         NodeAttrs    roachpb.Attributes</span>
<span id="L2480"><span class="lineNum">    2480</span>              :         NodeLocality roachpb.Locality</span>
<span id="L2481"><span class="lineNum">    2481</span>              :         StoreAttrs   roachpb.Attributes</span>
<span id="L2482"><span class="lineNum">    2482</span>              : }</span>
<span id="L2483"><span class="lineNum">    2483</span>              : </span>
<span id="L2484"><span class="lineNum">    2484</span>              : // locality returns the locality of the Store, which is the Locality of the</span>
<span id="L2485"><span class="lineNum">    2485</span>              : // node plus an extra tier for the node itself. Copied from</span>
<span id="L2486"><span class="lineNum">    2486</span>              : // StoreDescriptor.Locality.</span>
<span id="L2487"><span class="lineNum">    2487</span> <span class="tlaGNC">          82 : func (saal StoreAttributesAndLocality) locality() roachpb.Locality {</span></span>
<span id="L2488"><span class="lineNum">    2488</span> <span class="tlaGNC">          82 :         return saal.NodeLocality.AddTier(</span></span>
<span id="L2489"><span class="lineNum">    2489</span> <span class="tlaGNC">          82 :                 roachpb.Tier{Key: &quot;node&quot;, Value: saal.NodeID.String()})</span></span>
<span id="L2490"><span class="lineNum">    2490</span> <span class="tlaGNC">          82 : }</span></span>
<span id="L2491"><span class="lineNum">    2491</span>              : </span>
<span id="L2492"><span class="lineNum">    2492</span>              : // Avoid unused lint errors.</span>
<span id="L2493"><span class="lineNum">    2493</span>              : var _ = rangeState{}.diversityIncreaseLastFailedAttempt</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.3.2-1</a></td></tr>
          </table>
          <br>

</body>
</html>
